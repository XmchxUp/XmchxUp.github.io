---
author: 'éŸ©ç«‹'
title: '2024-01-07 å‘¨è®° 0x003'
date: '2024-01-07'
description: 'weekly'
ShowBreadCrumbs: false
categories: ['Weekly']
tags: ['Weekly']
---

## Life

å‰æ®µæ—¶é—´æ™šä¸Šè·‘æ­¥é¡¶ä¸ä½ï¼Œå¤ªå†·äº†ï¼Œç°åœ¨æ¸©åº¦ç¨å¾®å¥½è½¬ï¼Œä¸€å‘¨ä¸¤æ¬¡äº”å…¬é‡Œå§ã€‚åšç‚¹å®¤å†…çš„é”»ç‚¼æ´»åŠ¨ã€‚

æ¯å¤©äº”åä¸ªä¿¯å§æ’‘ã€‚ã€‚ã€‚

æ¯å‘¨è¿˜æ˜¯æœ‰ä¸ªå›ºå®šæ—¶é—´çœ‹çœ‹ç”µè§†ï¼Œæ¸¸æˆæ”¾æ¾ä¸‹ã€‚

è¿™å‘¨æ²¡æœ‰åƒå¤–å–ï¼Œå¥åº·çš„ä¸€å‘¨ ğŸ˜Šã€‚

æ„Ÿè§‰åŒä¼‘æ—¥æ¯æ¬¡åƒå®Œé¥­å¯ä»¥æ•£æ­¥åŠå°æ—¶å·¦å³ã€‚

## Share

### SAT Solver

[repo](https://github.com/XmchxUp/goSudoku) å†™äº†ä¸ª Sudoku ä½¿ç”¨ SAT æ¥è§£([Boolean satisfiability problem](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem))

```go
ä¾‹å¦‚ 3\*3 çš„ board
X X 3
4 X 6
7 8 X

æ¡ä»¶æœ‰ï¼š
å¤–ç»´æ•°ç»„æ˜¯é‡Œçš„å…ƒç´ æ˜¯andçš„å…³ç³»
é‡Œé¢å­æ•°ç»„é‡Œçš„å…ƒç´ æ˜¯orçš„å…³ç³»
[
  [((0,2,3), True)], //è¡¨ç¤º(0,2)çš„ä½ç½®æ˜¯3 And
  ...
  [((2,1,8), True)],
  // æŒ‰ä¸‹é¢çš„æ€æƒ³, ç»§ç»­åˆ—å‡ºæ‰€æœ‰æ¡ä»¶ï¼Œè¿™é‡Œåªä¸¾ä¾‹
  // å³ (0,0)==2 and (0,1)!=2 and (0,2)!=2
  [((0,0,2), True)]
  [((0,1,2), False)]
  [((0,2,2), False)]

  ...
]
```

æ€æƒ³:

- åˆå§‹åŒ–å·²ç»åœ¨ board ä¸Šç¡®å®šçš„å…ƒç´ çš„æ¡ä»¶ã€‚
- å¯¹äºæ¯ä¸ª cell è¦æ±‚åªèƒ½æ˜¯ 1-9 ä¸­çš„æ•°ï¼Œå¹¶ä¸”ä¸èƒ½å‡ºç°ä¸¤ç§æƒ…å†µ(å³æ˜¯ 1 åˆæ˜¯ 2)ã€‚
- æ¯è¡Œï¼Œæ¯åˆ—è¦æ±‚åªèƒ½å‡ºç°ä¸€æ¬¡æ˜¯ 1-9ã€‚å¦‚è¡Œè¦æ±‚ä¸¾ä¾‹:Pos(0,0)=1 æ—¶è¦æ±‚ Pos(0,1)..Pos(0,8)ä¸èƒ½æ˜¯ 1ã€‚
- åŒç†å¯¹ 3\*3 å—åšè¦æ±‚ã€‚

```go
// SudokuBoardToSatFormula converts a sudoku board to a SAT formula
func SudokuBoardToSatFormula(sudokuBoard [][]int) Formula {
	N := 9
	n := 3
	formula := Formula{}

	// Initial state constraints
	for r := 0; r < N; r++ {
		for c := 0; c < N; c++ {
			d := sudokuBoard[r][c]
			if d != 0 {
				literal := Literal{Variable: literalVar(r, c, d), Value: true}
				clause := Clause{literal}
				formula = append(formula, clause)
			}
		}
	}

	// Cell constraints
	for r := 0; r < N; r++ {
		for c := 0; c < N; c++ {
			// At least one number in each cell
			clause := Clause{}
			for d := 1; d <= N; d++ {
				clause = append(clause, Literal{Variable: literalVar(r, c, d), Value: true})
			}
			formula = append(formula, clause)

			// At most one number in each cell
			for i := 1; i <= N; i++ {
				clause = Clause{}
				for j := i + 1; j <= N; j++ {
					clause = append(clause, Literal{Variable: literalVar(r, c, i), Value: false},
						Literal{Variable: literalVar(r, c, j), Value: false})
				}
				if len(clause) > 0 {
					formula = append(formula, clause)
				}
			}
		}
	}

	// Row and Column constraints
	for d := 1; d <= N; d++ {
		for r := 0; r < N; r++ {
			// Row constraint
			clause := Clause{}
			for c := 0; c < N; c++ {
				clause = append(clause, Literal{Variable: literalVar(r, c, d), Value: true})
			}
			formula = append(formula, clause)

			// Column constraint
			clause = Clause{}
			for c := 0; c < N; c++ {
				clause = append(clause, Literal{Variable: literalVar(c, r, d), Value: true})
			}
			formula = append(formula, clause)

			// At most one number in each row and column
			for c1 := 0; c1 < N; c1++ {
				for c2 := c1 + 1; c2 < N; c2++ {
					formula = append(formula, Clause{
						Literal{Variable: literalVar(r, c1, d), Value: false},
						Literal{Variable: literalVar(r, c2, d), Value: false},
					}, Clause{
						Literal{Variable: literalVar(c1, r, d), Value: false},
						Literal{Variable: literalVar(c2, r, d), Value: false},
					})
				}
			}
		}
	}

	// Block constraints
	for d := 1; d <= N; d++ {
		for br := 0; br < n; br++ {
			for bc := 0; bc < n; bc++ {
				// At least one number in each block
				clause := Clause{}
				for rr := 0; rr < n; rr++ {
					for cc := 0; cc < n; cc++ {
						clause = append(clause, Literal{Variable: literalVar(br*n+rr, bc*n+cc, d), Value: true})
					}
				}
				formula = append(formula, clause)

				// At most one number in each block
				for i := 0; i < n*n; i++ {
					for j := i + 1; j < n*n; j++ {
						r1, c1 := i/n, i%n
						r2, c2 := j/n, j%n
						formula = append(formula, Clause{
							Literal{Variable: literalVar(br*n+r1, bc*n+c1, d), Value: false},
							Literal{Variable: literalVar(br*n+r2, bc*n+c2, d), Value: false},
						})
					}
				}
			}
		}
	}

	return formula
}
```

### åœ¨ä¸€å°æœºå™¨ä¸Šæ¨¡æ‹Ÿ Kubernetes çš„æ–¹å¼

- [kind](https://kind.sigs.k8s.io/docs/user/quick-start/#installation)
- [minikube](https://minikube.sigs.k8s.io/docs/start/)

## Algorithm

[1235. Maximum Profit in Job Scheduling](https://leetcode.com/problems/maximum-profit-in-job-scheduling/)

æ€è·¯:

- é¦–å…ˆå¯¹æ¯ä¸ª job æŒ‰ start time æ’åº
- DFS æœç´¢ï¼Œå¯¹äº job[i]ï¼Œåªæœ‰é€‰ï¼Œä¸é€‰ä¸¤ä¸ªé€‰é¡¹
  - ä¸é€‰ï¼Œé‚£ä¹ˆå°±éå† job[i+1]
  - é€‰ï¼Œå¯»æ‰¾ job[i] end time å job[j]
    - è¿™é‡Œå¯ä»¥ä½¿ç”¨äºŒåˆ†æœç´¢ä¼˜åŒ–ï¼Œæ‰¾ç¬¬ä¸€ä¸ª>=job[i][endtime]
- ç»“æœå°±æ˜¯å¯¹ä¸¤ä¸ªé€‰æ‹©å– max

```python
from typing import List
import bisect

class Solution:
    def jobScheduling(
        self, startTime: List[int], endTime: List[int], profit: List[int]
    ) -> int:
        """
        DFSæœç´¢: å¯¹å½“å‰i jobæ˜¯å¦é€‰æˆ–ä¸é€‰ä¸¤ç§æƒ…å†µéå†ã€‚
        """
        intervals = sorted(zip(startTime, endTime, profit))
        cache = {}

        def dfs(i: int):
            if i == len(intervals):
                return 0
            if i in cache:
                return cache[i]

            # dont include i job
            res = dfs(i + 1)

            # include i job
            # j = i + 1
            # while j < len(intervals):
            #     if intervals[i][1] <= intervals[j][0]:
            #         break
            #     j += 1
            j = bisect.bisect_left(intervals, (intervals[i][1], -1, -1))
            cache[i] = res = max(res, intervals[i][2] + dfs(j))

            return res

        return dfs(0)

```
