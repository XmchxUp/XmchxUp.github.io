<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Problemsets on Kevin Sun</title>
    <link>https://xmchxup.github.io/problemset/</link>
    <description>Recent content in Problemsets on Kevin Sun</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Kevin Sun</copyright><atom:link href="https://xmchxup.github.io/problemset/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/01-matrix/01-matrix.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/01-matrix/01-matrix.java/</guid>
      <description>// @Title: 01 矩阵 (01 Matrix) // @Author: 1394466835@qq.com // @Date: 2021-07-23 20:32:35 // @Runtime: 16 ms // @Memory: 40.2 MB class Solution { public int[][] updateMatrix(int[][] mat) { int m = mat.length; int n = mat[0].length; Queue&amp;lt;int[]&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; m; i++) { for (int j = 0; j &amp;lt; n; j++) { if (mat[i][j] == 0) { queue.offer(new int[]{i, j}); } else { mat[i][j] = Integer.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/01-matrix/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/01-matrix/readme/</guid>
      <description>| English | 简体中文 |
542. 01 矩阵 题目描述 给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。
两个相邻元素间的距离为 1 。
 示例 1：
输入：mat = [[0,0,0],[0,1,0],[0,0,0]]输出：[[0,0,0],[0,1,0],[0,0,0]]示例 2：
输入：mat = [[0,0,0],[0,1,0],[1,1,1]]输出：[[0,0,0],[0,1,0],[1,2,1]] 提示：
m == mat.lengthn == mat[i].length1 41 4mat[i][j] is either 0 or 1.mat 中至少有一个 0 相关话题  广度优先搜索 数组 动态规划 矩阵  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/3sum-closest/3sum-closest.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/3sum-closest/3sum-closest.java/</guid>
      <description>// @Title: 最接近的三数之和 (3Sum Closest) // @Author: 1394466835@qq.com // @Date: 2021-08-15 19:34:14 // @Runtime: 9 ms // @Memory: 38.1 MB class Solution { public int threeSumClosest(int[] nums, int target) { int res = Integer.MAX_VALUE; int diff = Integer.MAX_VALUE; Arrays.sort(nums); for (int i = 0; i &amp;lt; nums.length - 2; i++) { int low = i + 1, high = nums.length - 1; while (low &amp;lt; high) { int sum = nums[low] + nums[high] + nums[i]; if (Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/3sum-closest/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/3sum-closest/readme/</guid>
      <description>| English | 简体中文 |
16. 最接近的三数之和 题目描述 给定一个包括&amp;nbsp;n 个整数的数组&amp;nbsp;nums&amp;nbsp;和 一个目标值&amp;nbsp;target。找出&amp;nbsp;nums&amp;nbsp;中的三个整数，使得它们的和与&amp;nbsp;target&amp;nbsp;最接近。返回这三个数的和。假定每组输入只存在唯一答案。
&amp;nbsp;
示例：
输入：nums = [-1,2,1,-4], target = 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。&amp;nbsp;
提示：
3 &amp;lt;= nums.length &amp;lt;= 10^3-10^3&amp;nbsp;&amp;lt;= nums[i]&amp;nbsp;&amp;lt;= 10^3-10^4&amp;nbsp;&amp;lt;= target&amp;nbsp;&amp;lt;= 10^4相关话题  数组 双指针 排序  相似题目  三数之和 较小的三数之和  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/3sum/3sum.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/3sum/3sum.java/</guid>
      <description>// @Title: 三数之和 (3Sum) // @Author: 1394466835@qq.com // @Date: 2021-08-14 07:12:47 // @Runtime: 19 ms // @Memory: 42.1 MB class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) { Arrays.sort(nums); List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length - 2; i++) { if (nums[i] &amp;gt; 0) break; if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) continue; int sum = 0 - nums[i]; int lo = i + 1, hi = nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/3sum/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/3sum/readme/</guid>
      <description>| English | 简体中文 |
15. 三数之和 题目描述 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
 示例 1：
输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]示例 2：
输入：nums = []输出：[]示例 3：
输入：nums = [0]输出：[] 提示：
0 -105 5相关话题  数组 双指针 排序  相似题目  两数之和 最接近的三数之和 四数之和 较小的三数之和  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/add-binary/add-binary.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-binary/add-binary.java/</guid>
      <description>// @Title: 二进制求和 (Add Binary) // @Author: 1394466835@qq.com // @Date: 2021-07-08 21:05:39 // @Runtime: 2 ms // @Memory: 38.4 MB class Solution { public String addBinary(String a, String b) { StringBuilder sb = new StringBuilder(); int i = a.length() - 1, j = b.length() - 1; int carry = 0, sum = 0; while (i &amp;gt;= 0 || j &amp;gt;= 0) { sum = carry; if (i &amp;gt;= 0) sum += a.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/add-binary/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-binary/readme/</guid>
      <description>| English | 简体中文 |
67. 二进制求和 题目描述 给你两个二进制字符串，返回它们的和（用二进制表示）。
输入为 非空 字符串且只包含数字&amp;nbsp;1&amp;nbsp;和&amp;nbsp;0。
&amp;nbsp;
示例&amp;nbsp;1:
输入: a = &amp;quot;11&amp;quot;, b = &amp;quot;1&amp;quot;输出: &amp;quot;100&amp;quot;示例&amp;nbsp;2:
输入: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot;输出: &amp;quot;10101&amp;quot;&amp;nbsp;
提示：
每个字符串仅由字符 &amp;#39;0&amp;#39; 或 &amp;#39;1&amp;#39; 组成。1 &amp;lt;= a.length, b.length &amp;lt;= 10^4字符串如果不是 &amp;quot;0&amp;quot; ，就都不含前导零。相关话题  位运算 数学 字符串 模拟  相似题目  两数相加 字符串相乘 加一 数组形式的整数加法  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/add-digits/add-digits.c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-digits/add-digits.c/</guid>
      <description>// @Title: 各位相加 (Add Digits) // @Author: 1394466835@qq.com // @Date: 2019-04-26 10:48:43 // @Runtime: 12 ms // @Memory: 6.5 MB int addDigits(int num) { return 1+(num-1)%9; } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/add-digits/add-digits.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-digits/add-digits.cpp/</guid>
      <description>// @Title: 各位相加 (Add Digits) // @Author: 1394466835@qq.com // @Date: 2019-04-26 10:47:14 // @Runtime: 12 ms // @Memory: 8 MB class Solution { public: //https://en.wikipedia.org/wiki/Digital_root  //dr(n) = 1 +((n-1) mod 9)  int addDigits(int num) { return 1+(num-1)%9; } //递归  int addDigits(int num, int k, int m) { if (num &amp;gt;= 0 &amp;amp;&amp;amp; num &amp;lt;= 9) return num; return addDigits((num/10+num%10)); } //循环  int addDigits(int num, int k) { int tempNum = num; while (true) { tempNum = tempNum/10 + tempNum%10; if (tempNum &amp;gt;= 0 &amp;amp;&amp;amp; tempNum &amp;lt;= 9) break; } return tempNum; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/add-digits/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-digits/readme/</guid>
      <description>| English | 简体中文 |
258. 各位相加 题目描述 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。
示例:
输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于&amp;nbsp;2 是一位数，所以返回 2。进阶:
你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？
相关话题  数学 数论 模拟  相似题目  快乐数 最小元素各数位之和  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/add-two-numbers-ii/add-two-numbers-ii.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-two-numbers-ii/add-two-numbers-ii.java/</guid>
      <description>// @Title: 两数相加 II (Add Two Numbers II) // @Author: 1394466835@qq.com // @Date: 2021-07-12 07:54:55 // @Runtime: 3 ms // @Memory: 38.7 MB /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { Deque&amp;lt;ListNode&amp;gt; s1 = new LinkedList&amp;lt;&amp;gt;(); Deque&amp;lt;ListNode&amp;gt; s2 = new LinkedList&amp;lt;&amp;gt;(); while (l1 !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/add-two-numbers-ii/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-two-numbers-ii/readme/</guid>
      <description>| English | 简体中文 |
445. 两数相加 II 题目描述 给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
你可以假设除了数字 0 之外，这两个数字都不会以零开头。
 示例1：
输入：l1 = [7,2,4,3], l2 = [5,6,4]输出：[7,8,0,7]示例2：
输入：l1 = [2,4,3], l2 = [5,6,4]输出：[8,0,7]示例3：
输入：l1 = [0], l2 = [0]输出：[0] 提示：
链表的长度范围为 [1, 100]0 输入数据保证链表代表的数字无前导 0 进阶：如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。
相关话题  栈 链表 数学  相似题目  两数相加  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/add-two-numbers/add-two-numbers.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-two-numbers/add-two-numbers.cpp/</guid>
      <description>// @Title: 两数相加 (Add Two Numbers) // @Author: 1394466835@qq.com // @Date: 2019-01-25 11:07:20 // @Runtime: 48 ms // @Memory: 1.7 MB /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { int x = 0, y = 0; //存储l1 l2当前的值  int carry = 0; //存储进位值  int sum = 0; //存储当前两个值的和  ListNode* h = NULL, **t = &amp;amp;h; //h用于返回的结果链表 t用于操作h链表  while(l1 !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/add-two-numbers/add-two-numbers.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-two-numbers/add-two-numbers.java/</guid>
      <description>// @Title: 两数相加 (Add Two Numbers) // @Author: 1394466835@qq.com // @Date: 2021-10-07 17:27:31 // @Runtime: 2 ms // @Memory: 38.9 MB /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(); ListNode prev = dummy; int sum = 0; while (l1 !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/add-two-numbers/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-two-numbers/readme/</guid>
      <description>| English | 简体中文 |
2. 两数相加 题目描述 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
 示例 1：
输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.示例 2：
输入：l1 = [0], l2 = [0]输出：[0]示例 3：
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示：
每个链表中的节点数在范围 [1, 100] 内0 题目数据保证列表表示的数字不含前导零相关话题  递归 链表 数学  相似题目  字符串相乘 二进制求和 两整数之和 字符串相加 两数相加 II 数组形式的整数加法  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/arranging-coins/arranging-coins.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/arranging-coins/arranging-coins.java/</guid>
      <description>// @Title: 排列硬币 (Arranging Coins) // @Author: 1394466835@qq.com // @Date: 2021-07-15 21:02:20 // @Runtime: 8 ms // @Memory: 35.6 MB class Solution { public int arrangeCoins(int n) { int c = 0; while (n &amp;gt; c) { c = c + 1; n = n - c; } return c; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/arranging-coins/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/arranging-coins/readme/</guid>
      <description>| English | 简体中文 |
441. 排列硬币 题目描述 你总共有&amp;nbsp;n&amp;nbsp;枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。
给你一个数字&amp;nbsp;n ，计算并返回可形成 完整阶梯行 的总行数。
&amp;nbsp;
示例 1：
输入：n = 5输出：2解释：因为第三行不完整，所以返回 2 。示例 2：
输入：n = 8输出：3解释：因为第四行不完整，所以返回 3 。&amp;nbsp;
提示：
1 &amp;lt;= n &amp;lt;= 231 - 1相关话题  数学 二分查找  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/array-nesting/array-nesting.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/array-nesting/array-nesting.cpp/</guid>
      <description>// @Title: 数组嵌套 (Array Nesting) // @Author: 1394466835@qq.com // @Date: 2019-08-25 09:43:01 // @Runtime: 20 ms // @Memory: 9.6 MB class Solution { public: int arrayNesting(vector&amp;lt;int&amp;gt;&amp;amp; nums) { size_t maxsize = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { size_t size = 0; for (int k = i; nums[k] != -1; size++) { int tmp = nums[k]; nums[k] = -1; k = tmp; } maxsize = max(maxsize, size); } return maxsize; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/array-nesting/array-nesting.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/array-nesting/array-nesting.java/</guid>
      <description>// @Title: 数组嵌套 (Array Nesting) // @Author: 1394466835@qq.com // @Date: 2019-08-25 09:37:41 // @Runtime: 5 ms // @Memory: 49.6 MB class Solution { public int arrayNesting(int[] nums) { int max_count = 0; for (int i = 0; i &amp;lt; nums.length; i++) { int index = i, count = 0; while (index != -1 &amp;amp;&amp;amp; nums[index] != -1) { int temp = index; index = nums[index]; nums[temp] = -1; count++; } max_count = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/array-nesting/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/array-nesting/readme/</guid>
      <description>| English | 简体中文 |
565. 数组嵌套 题目描述 索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到最大的集合S并返回其大小，其中 S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }且遵守以下的规则。
假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]... 以此类推，不断添加直到S出现重复的元素。
&amp;nbsp;
示例&amp;nbsp;1:
输入: A = [5,4,0,3,1,6,2]输出: 4解释: A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.其中一种最长的 S[K]:S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}&amp;nbsp;
提示：
N是[1, 20,000]之间的整数。A中不含有重复的元素。A中的元素大小在[0, N-1]之间。相关话题  深度优先搜索 数组  相似题目  嵌套列表权重和 扁平化嵌套列表迭代器 加权嵌套序列和 II  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/assign-cookies/assign-cookies.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/assign-cookies/assign-cookies.cpp/</guid>
      <description>// @Title: 分发饼干 (Assign Cookies) // @Author: 1394466835@qq.com // @Date: 2021-10-06 20:48:24 // @Runtime: 28 ms // @Memory: 17.1 MB class Solution { public: int findContentChildren(vector&amp;lt;int&amp;gt;&amp;amp; g, vector&amp;lt;int&amp;gt;&amp;amp; s) { sort(g.begin(), g.end()); sort(s.begin(), s.end()); int child = 0, cookie = 0; while (child &amp;lt; g.size() &amp;amp;&amp;amp; cookie &amp;lt; s.size()) { if (g[child] &amp;lt;= s[cookie]) { child++; } cookie++; } return child; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/assign-cookies/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/assign-cookies/readme/</guid>
      <description>| English | 简体中文 |
455. 分发饼干 题目描述 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] = g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
示例 1:
输入: g = [1,2,3], s = [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。示例 2:
输入: g = [1,2], s = [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 提示：
1 40 41 31 - 1相关话题  贪心 数组 排序  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/backspace-string-compare/backspace-string-compare.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/backspace-string-compare/backspace-string-compare.java/</guid>
      <description>// @Title: 比较含退格的字符串 (Backspace String Compare) // @Author: 1394466835@qq.com // @Date: 2021-06-02 06:48:01 // @Runtime: 1 ms // @Memory: 36.4 MB class Solution { public boolean backspaceCompare(String S, String T) { int i = S.length() - 1; int j = T.length() - 1; int countS = 0; int countT = 0; while (i &amp;gt;= 0 || j &amp;gt;= 0) { while (i &amp;gt;= 0 &amp;amp;&amp;amp; (countS &amp;gt; 0 || S.charAt(i) == &amp;#39;#&amp;#39;)) { if (S.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/backspace-string-compare/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/backspace-string-compare/readme/</guid>
      <description>| English | 简体中文 |
844. 比较含退格的字符串 题目描述 给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。
注意：如果对空文本输入退格字符，文本继续为空。
 示例 1：
输入：S = &#34;ab#c&#34;, T = &#34;ad#c&#34;输出：true解释：S 和 T 都会变成 “ac”。示例 2：
输入：S = &#34;ab##&#34;, T = &#34;c#d#&#34;输出：true解释：S 和 T 都会变成 “”。示例 3：
输入：S = &#34;a##c&#34;, T = &#34;#a#c&#34;输出：true解释：S 和 T 都会变成 “c”。示例 4：
输入：S = &#34;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/balanced-binary-tree/balanced-binary-tree.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/balanced-binary-tree/balanced-binary-tree.java/</guid>
      <description>// @Title: 平衡二叉树 (Balanced Binary Tree) // @Author: 1394466835@qq.com // @Date: 2020-03-12 16:43:20 // @Runtime: 1 ms // @Memory: 41.1 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean isBalanced(TreeNode root) { if (root == null) return true; return helper(root) !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/balanced-binary-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/balanced-binary-tree/readme/</guid>
      <description>| English | 简体中文 |
110. 平衡二叉树 题目描述 给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
 示例 1：
输入：root = [3,9,20,null,null,15,7]输出：true示例 2：
输入：root = [1,2,2,3,3,null,null,4,4]输出：false示例 3：
输入：root = []输出：true 提示：
树中的节点数在范围 [0, 5000] 内-104 4相关话题  树 深度优先搜索 二叉树  相似题目  二叉树的最大深度  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/best-time-to-buy-and-sell-stock-ii/best-time-to-buy-and-sell-stock-ii.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/best-time-to-buy-and-sell-stock-ii/best-time-to-buy-and-sell-stock-ii.java/</guid>
      <description>// @Title: 买卖股票的最佳时机 II (Best Time to Buy and Sell Stock II) // @Author: 1394466835@qq.com // @Date: 2021-05-03 06:07:30 // @Runtime: 1 ms // @Memory: 38.1 MB class Solution { public int maxProfit(int[] prices) { int total = 0; for (int i = 0; i &amp;lt; prices.length - 1; i++) { if (prices[i + 1] - prices[i] &amp;gt; 0) total += prices[i+1] - prices[i]; } return total; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/best-time-to-buy-and-sell-stock-ii/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/best-time-to-buy-and-sell-stock-ii/readme/</guid>
      <description>| English | 简体中文 |
122. 买卖股票的最佳时机 II 题目描述 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
 示例 1:
输入: prices = [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:
输入: prices = [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-search-tree-iterator/binary-search-tree-iterator.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-search-tree-iterator/binary-search-tree-iterator.java/</guid>
      <description>// @Title: 二叉搜索树迭代器 (Binary Search Tree Iterator) // @Author: 1394466835@qq.com // @Date: 2020-10-28 21:02:30 // @Runtime: 22 ms // @Memory: 43.1 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class BSTIterator { private TreeNode visit; private Stack&amp;lt;TreeNode&amp;gt; stack; public BSTIterator(TreeNode root) { stack = new Stack&amp;lt;&amp;gt;(); visit = root; } /** @return the next smallest number */ public int next() { while (visit !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-search-tree-iterator/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-search-tree-iterator/readme/</guid>
      <description>| English | 简体中文 |
173. 二叉搜索树迭代器 题目描述 实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。int next()将指针向右移动，然后返回指针处的数字。注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。
你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。
 示例：
输入[&#34;BSTIterator&#34;, &#34;next&#34;, &#34;next&#34;, &#34;hasNext&#34;, &#34;next&#34;, &#34;hasNext&#34;, &#34;next&#34;, &#34;hasNext&#34;, &#34;next&#34;, &#34;hasNext&#34;][[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]输出[null, 3, 7, true, 9, true, 15, true, 20, false]解释BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);bSTIterator.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-search/binary-search.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-search/binary-search.java/</guid>
      <description>// @Title: 二分查找 (Binary Search) // @Author: 1394466835@qq.com // @Date: 2021-10-03 07:07:07 // @Runtime: 0 ms // @Memory: 39.3 MB class Solution { public int search(int[] nums, int target) { int lo = 0, hi = nums.length; int mid = 0; while (lo &amp;lt; hi) { mid = ((hi - lo) &amp;gt;&amp;gt; 1) + lo; if (target == nums[mid]) { return mid; } else if (target &amp;lt; nums[mid]) { hi = mid; } else { lo = mid + 1; } } return -1; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-search/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-search/readme/</guid>
      <description>| English | 简体中文 |
704. 二分查找 题目描述 给定一个&amp;nbsp;n&amp;nbsp;个元素有序的（升序）整型数组&amp;nbsp;nums 和一个目标值&amp;nbsp;target &amp;nbsp;，写一个函数搜索&amp;nbsp;nums&amp;nbsp;中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:
输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4示例&amp;nbsp;2:
输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1&amp;nbsp;
提示：
你可以假设 nums&amp;nbsp;中的所有元素是不重复的。n&amp;nbsp;将在&amp;nbsp;[1, 10000]之间。nums&amp;nbsp;的每个元素都将在&amp;nbsp;[-9999, 9999]之间。相关话题  数组 二分查找  相似题目  搜索长度未知的有序数组  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-tree-inorder-traversal/binary-tree-inorder-traversal.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-inorder-traversal/binary-tree-inorder-traversal.cpp/</guid>
      <description>// @Title: 二叉树的中序遍历 (Binary Tree Inorder Traversal) // @Author: 1394466835@qq.com // @Date: 2019-10-05 17:26:44 // @Runtime: 0 ms // @Memory: 8.9 MB /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) { vector&amp;lt;int&amp;gt; nodes; stack&amp;lt;TreeNode*&amp;gt; s; TreeNode* cur = root; while (cur || !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-tree-inorder-traversal/binary-tree-inorder-traversal.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-inorder-traversal/binary-tree-inorder-traversal.java/</guid>
      <description>// @Title: 二叉树的中序遍历 (Binary Tree Inorder Traversal) // @Author: 1394466835@qq.com // @Date: 2019-10-05 17:17:58 // @Runtime: 1 ms // @Memory: 34 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) { List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;(); helper(root, list); return list; } private void helper(TreeNode node, List&amp;lt;Integer&amp;gt; list) { if (node == null) { return; } helper(node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-tree-inorder-traversal/binary-tree-inorder-traversal.py/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-inorder-traversal/binary-tree-inorder-traversal.py/</guid>
      <description># @Title: 二叉树的中序遍历 (Binary Tree Inorder Traversal) # @Author: 1394466835@qq.com # @Date: 2019-06-14 13:34:00 # @Runtime: 20 ms # @Memory: 11.4 MB # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def inorderTraversal(self, root): &amp;#34;&amp;#34;&amp;#34; :type root: TreeNode :rtype: List[int] &amp;#34;&amp;#34;&amp;#34; if not root: return [] return self.inorderTraversal(root.left) + [root.val] + self.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-tree-inorder-traversal/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-inorder-traversal/readme/</guid>
      <description>| English | 简体中文 |
94. 二叉树的中序遍历 题目描述 给定一个二叉树的根节点 root ，返回它的 中序 遍历。
 示例 1：
输入：root = [1,null,2,3]输出：[1,3,2]示例 2：
输入：root = []输出：[]示例 3：
输入：root = [1]输出：[1]示例 4：
输入：root = [1,2]输出：[2,1]示例 5：
输入：root = [1,null,2]输出：[1,2] 提示：
树中节点数目在范围 [0, 100] 内-100  进阶: 递归算法很简单，你可以通过迭代算法完成吗？
相关话题  栈 树 深度优先搜索 二叉树  相似题目  验证二叉搜索树 二叉树的前序遍历 二叉树的后序遍历 二叉搜索树迭代器 二叉搜索树中第K小的元素 最接近的二叉搜索树值 II 二叉搜索树中的中序后继 将二叉搜索树转化为排序的双向链表 二叉搜索树节点最小距离  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-tree-level-order-traversal/binary-tree-level-order-traversal.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-level-order-traversal/binary-tree-level-order-traversal.cpp/</guid>
      <description>// @Title: 二叉树的层序遍历 (Binary Tree Level Order Traversal) // @Author: 1394466835@qq.com // @Date: 2019-04-28 16:04:07 // @Runtime: 16 ms // @Memory: 13.4 MB /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ret; if (root == NULL) return ret; queue&amp;lt;TreeNode*&amp;gt; q; q.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-tree-level-order-traversal/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-level-order-traversal/readme/</guid>
      <description>| English | 简体中文 |
102. 二叉树的层序遍历 题目描述 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
 示例：
二叉树：[3,9,20,null,null,15,7],
3/ \9 20/ \15 7返回其层序遍历结果：
[[3],[9,20],[15,7]]相关话题  树 广度优先搜索 二叉树  相似题目  二叉树的锯齿形层序遍历 二叉树的层序遍历 II 二叉树的最小深度 二叉树的垂直遍历 二叉树的层平均值 N 叉树的层序遍历 二叉树的堂兄弟节点  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-tree-maximum-path-sum/binary-tree-maximum-path-sum.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-maximum-path-sum/binary-tree-maximum-path-sum.java/</guid>
      <description>// @Title: 二叉树中的最大路径和 (Binary Tree Maximum Path Sum) // @Author: 1394466835@qq.com // @Date: 2020-03-04 09:18:54 // @Runtime: 1 ms // @Memory: 39.9 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { private int result = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) { oneSideMax(root); return result; } private int oneSideMax(TreeNode root) { if (root == null) return 0; int left = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-tree-maximum-path-sum/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-maximum-path-sum/readme/</guid>
      <description>| English | 简体中文 |
124. 二叉树中的最大路径和 题目描述 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和 。
 示例 1：
输入：root = [1,2,3]输出：6解释：最优路径是 2 - 1 - 3 ，路径和为 2 + 1 + 3 = 6示例 2：
输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 - 20 - 7 ，路径和为 15 + 20 + 7 = 42 提示：
树中节点数目范围是 [1, 3 * 104]-1000 相关话题  树 深度优先搜索 动态规划 二叉树  相似题目  路径总和 求根节点到叶节点数字之和 路径总和 IV 最长同值路径  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-tree-tilt/binary-tree-tilt.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-tilt/binary-tree-tilt.java/</guid>
      <description>// @Title: 二叉树的坡度 (Binary Tree Tilt) // @Author: 1394466835@qq.com // @Date: 2020-03-21 19:00:38 // @Runtime: 0 ms // @Memory: 40.7 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { private int tilt = 0; public int findTilt(TreeNode root) { traverse(root); return tilt; } private int traverse(TreeNode root) { if (root == null) return 0; int leftValue = traverse(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/binary-tree-tilt/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-tilt/readme/</guid>
      <description>| English | 简体中文 |
563. 二叉树的坡度 题目描述 给定一个二叉树，计算 整个树 的坡度 。
一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。
整个树 的坡度就是其所有节点的坡度之和。
 示例 1：
输入：root = [1,2,3]输出：1解释：节点 2 的坡度：|0-0| = 0（没有子节点）节点 3 的坡度：|0-0| = 0（没有子节点）节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）坡度总和：0 + 0 + 1 = 1示例 2：
输入：root = [4,2,9,3,5,null,7]输出：15解释：节点 3 的坡度：|0-0| = 0（没有子节点）节点 5 的坡度：|0-0| = 0（没有子节点）节点 7 的坡度：|0-0| = 0（没有子节点）节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15示例 3：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/can-place-flowers/can-place-flowers.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/can-place-flowers/can-place-flowers.java/</guid>
      <description>// @Title: 种花问题 (Can Place Flowers) // @Author: 1394466835@qq.com // @Date: 2021-04-27 20:34:49 // @Runtime: 1 ms // @Memory: 39.9 MB class Solution { public boolean canPlaceFlowers(int[] flowerbed, int n) { for (int i = 0; i &amp;lt; flowerbed.length; i++) { if (flowerbed[i] == 0 &amp;amp;&amp;amp; (i + 1 == flowerbed.length || flowerbed[i + 1] == 0) &amp;amp;&amp;amp; (i == 0 || flowerbed[i - 1] == 0) ) { flowerbed[i] = 1; n--; } } return n &amp;lt;= 0; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/can-place-flowers/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/can-place-flowers/readme/</guid>
      <description>| English | 简体中文 |
605. 种花问题 题目描述 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。
 示例 1：
输入：flowerbed = [1,0,0,0,1], n = 1输出：true示例 2：
输入：flowerbed = [1,0,0,0,1], n = 2输出：false 提示：
1 4flowerbed[i] 为 0 或 1flowerbed 中不存在相邻的两朵花0 相关话题  贪心 数组  相似题目  提莫攻击 行星碰撞  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/candy/candy.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/candy/candy.cpp/</guid>
      <description>// @Title: 分发糖果 (Candy) // @Author: 1394466835@qq.com // @Date: 2021-10-06 21:05:28 // @Runtime: 24 ms // @Memory: 17.3 MB class Solution { public: int candy(vector&amp;lt;int&amp;gt;&amp;amp; ratings) { int size = ratings.size(); if (size &amp;lt; 2) { return size; } vector&amp;lt;int&amp;gt; nums(size, 1); // 从左往右  for (int i = 1; i &amp;lt; size; i++) { if (ratings[i] &amp;gt; ratings[i - 1]) { nums[i] = nums[i - 1] + 1; } } // 从右往左  for (int i = size - 1; i &amp;gt; 0; i--) { if (ratings[i - 1] &amp;gt; ratings[i]) { nums[i - 1] = max(nums[i - 1], nums[i] + 1); } } return accumulate(nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/candy/candy.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/candy/candy.java/</guid>
      <description>// @Title: 分发糖果 (Candy) // @Author: 1394466835@qq.com // @Date: 2021-04-26 20:28:56 // @Runtime: 7 ms // @Memory: 39.3 MB class Solution { public int candy(int[] ratings) { int[] tempCount = new int[ratings.length]; Arrays.fill(tempCount, 1); for (int i = 0; i &amp;lt; ratings.length - 1; i++) { if (ratings[i + 1] &amp;gt; ratings[i]) { tempCount[i + 1] = tempCount[i] + 1; } } for (int i = ratings.length - 1; i &amp;gt; 0; i--) { if (ratings[i - 1] &amp;gt; ratings[i]) { tempCount[i - 1] = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/candy/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/candy/readme/</guid>
      <description>| English | 简体中文 |
135. 分发糖果 题目描述 老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
你需要按照以下要求，帮助老师给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。那么这样下来，老师至少需要准备多少颗糖果呢？
 示例 1：
输入：[1,0,2]输出：5解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。示例 2：
输入：[1,2,2]输出：4解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。相关话题  贪心 数组  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/climbing-stairs/climbing-stairs.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/climbing-stairs/climbing-stairs.java/</guid>
      <description>// @Title: 爬楼梯 (Climbing Stairs) // @Author: 1394466835@qq.com // @Date: 2021-09-12 20:36:32 // @Runtime: 0 ms // @Memory: 35.1 MB class Solution { public int climbStairs(int n) { if (n &amp;lt;= 2) return n; int prev1 = 1, prev2 = 2, curr = 0; for (int i = 3; i &amp;lt;= n; i++) { curr = prev1 + prev2; prev1 = prev2; prev2 = curr; } return curr; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/climbing-stairs/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/climbing-stairs/readme/</guid>
      <description>| English | 简体中文 |
70. 爬楼梯 题目描述 假设你正在爬楼梯。需要 n&amp;nbsp;阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
示例 1：
输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶示例 2：
输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶相关话题  记忆化搜索 数学 动态规划  相似题目  使用最小花费爬楼梯 斐波那契数 第 N 个泰波那契数  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/combination-sum-ii/combination-sum-ii.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combination-sum-ii/combination-sum-ii.java/</guid>
      <description>// @Title: 组合总和 II (Combination Sum II) // @Author: 1394466835@qq.com // @Date: 2021-10-01 20:00:12 // @Runtime: 2 ms // @Memory: 38.6 MB class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; cur = new ArrayList&amp;lt;&amp;gt;(); dfs(candidates, ans, 0, target, cur); return ans; } private void dfs(int[] candidates, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans, int s, int target, List&amp;lt;Integer&amp;gt; cur) { if (target == 0) { ans.add(new ArrayList&amp;lt;&amp;gt;(cur)); return; } for (int i = s; i &amp;lt; candidates.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/combination-sum-ii/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combination-sum-ii/readme/</guid>
      <description>| English | 简体中文 |
40. 组合总和 II 题目描述 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
注意：解集不能包含重复的组合。  示例 1:
输入: candidates = [10,1,2,7,6,1,5], target = 8,输出:[[1,1,6],[1,2,5],[1,7],[2,6]]示例 2:
输入: candidates = [2,5,2,1,2], target = 5,输出:[[1,2,2],[5]] 提示:
1 1 1 相关话题  数组 回溯  相似题目  组合总和  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/combination-sum-iii/combination-sum-iii.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combination-sum-iii/combination-sum-iii.java/</guid>
      <description>// @Title: 组合总和 III (Combination Sum III) // @Author: 1394466835@qq.com // @Date: 2021-08-08 06:32:33 // @Runtime: 0 ms // @Memory: 36 MB class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum3(int k, int n) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; cur = new ArrayList&amp;lt;&amp;gt;(); dfs(1, k, n, cur, ans); return ans; } private void dfs(int start, int k, int target, List&amp;lt;Integer&amp;gt; cur, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans) { if (k == 0) { if (target == 0) { ans.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/combination-sum-iii/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combination-sum-iii/readme/</guid>
      <description>| English | 简体中文 |
216. 组合总和 III 题目描述 找出所有相加之和为&amp;nbsp;n 的&amp;nbsp;k&amp;nbsp;个数的组合。组合中只允许含有 1 -&amp;nbsp;9 的正整数，并且每种组合中不存在重复的数字。
说明：
所有数字都是正整数。解集不能包含重复的组合。&amp;nbsp;示例 1:
输入: k = 3, n = 7输出: [[1,2,4]]示例 2:
输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]]相关话题  数组 回溯  相似题目  组合总和  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/combination-sum/combination-sum.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combination-sum/combination-sum.java/</guid>
      <description>// @Title: 组合总和 (Combination Sum) // @Author: 1394466835@qq.com // @Date: 2021-09-30 21:40:59 // @Runtime: 2 ms // @Memory: 38.8 MB class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(int[] candidates, int target) { Arrays.sort(candidates); List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; cur = new ArrayList&amp;lt;&amp;gt;(); dfs(ans, candidates, target, cur, 0); return ans; } private void dfs(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans, int[] candidates, int target, List&amp;lt;Integer&amp;gt; cur, int s) { if (target == 0) { ans.add(new ArrayList&amp;lt;&amp;gt;(cur)); return; } for (int i = s; i &amp;lt; candidates.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/combination-sum/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combination-sum/readme/</guid>
      <description>| English | 简体中文 |
39. 组合总和 题目描述 给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。
candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 对于给定的输入，保证和为 target 的唯一组合数少于 150 个。
 示例 1：
输入: candidates = [2,3,6,7], target = 7输出: [[7],[2,2,3]]示例 2：
输入: candidates = [2,3,5], target = 8输出: [[2,2,2,2],[2,3,3],[3,5]]示例 3：
输入: candidates = [2], target = 1输出: []示例 4：
输入: candidates = [1], target = 1输出: [[1]]示例 5：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/combinations/combinations.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combinations/combinations.java/</guid>
      <description>// @Title: 组合 (Combinations) // @Author: 1394466835@qq.com // @Date: 2021-10-02 21:38:08 // @Runtime: 17 ms // @Memory: 39.5 MB class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine(int n, int k) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); dfs(1, n, new ArrayList&amp;lt;&amp;gt;(), ans, k); return ans; } private void dfs(int start, int end, List&amp;lt;Integer&amp;gt; cur, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans, int len) { if (len == cur.size()) { ans.add(new ArrayList&amp;lt;&amp;gt;(cur)); return; } for (int i = start; i &amp;lt;= end; i++) { cur.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/combinations/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combinations/readme/</guid>
      <description>| English | 简体中文 |
77. 组合 题目描述 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
你可以按 任何顺序 返回答案。
 示例 1：
输入：n = 4, k = 2输出：[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],]示例 2：
输入：n = 1, k = 1输出：[[1]] 提示：
1 1 相关话题  数组 回溯  相似题目  组合总和 全排列  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/combine-two-tables/combine-two-tables.sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combine-two-tables/combine-two-tables.sql/</guid>
      <description>-- @Title: 组合两个表 (Combine Two Tables) -- @Author: 1394466835@qq.com -- @Date: 2019-01-25 10:32:37 -- @Runtime: 604 ms -- @Memory: N/A # Write your MySQL query statement below select a.FirstName, a.LastName, b.City, b.State from Person as a left join Address as b on a.PersonId = b.PersonId </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/combine-two-tables/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combine-two-tables/readme/</guid>
      <description>| English | 简体中文 |
175. 组合两个表 题目描述 表1: Person
+-------------+---------+| 列名 | 类型 |+-------------+---------+| PersonId | int || FirstName | varchar || LastName | varchar |+-------------+---------+PersonId 是上表主键表2: Address
+-------------+---------+| 列名 | 类型 |+-------------+---------+| AddressId | int || PersonId | int || City | varchar || State | varchar |+-------------+---------+AddressId 是上表主键&amp;nbsp;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/container-with-most-water/container-with-most-water.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/container-with-most-water/container-with-most-water.java/</guid>
      <description>// @Title: 盛最多水的容器 (Container With Most Water) // @Author: 1394466835@qq.com // @Date: 2021-08-11 21:14:23 // @Runtime: 4 ms // @Memory: 51.8 MB class Solution { public int maxArea(int[] height) { int res = 0; int j = height.length-1; for (int i = 0; i &amp;lt; j;) { res = Math.max(res, Math.min(height[i], height[j]) * (j-i)); if (height[i] &amp;lt; height[j]) { i++; } else { j--; } } return res; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/container-with-most-water/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/container-with-most-water/readme/</guid>
      <description>| English | 简体中文 |
11. 盛最多水的容器 题目描述 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点&amp;nbsp;(i,&amp;nbsp;ai) 。在坐标内画 n 条垂直线，垂直线 i&amp;nbsp;的两个端点分别为&amp;nbsp;(i,&amp;nbsp;ai) 和 (i, 0) 。找出其中的两条线，使得它们与&amp;nbsp;x&amp;nbsp;轴共同构成的容器可以容纳最多的水。
说明：你不能倾斜容器。
&amp;nbsp;
示例 1：
输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&amp;nbsp;49。示例 2：
输入：height = [1,1]输出：1示例 3：
输入：height = [4,3,2,1,4]输出：16示例 4：
输入：height = [1,2,1]输出：2&amp;nbsp;
提示：
n == height.length2 &amp;lt;= n &amp;lt;= 1050 &amp;lt;= height[i] &amp;lt;= 104相关话题  贪心 数组 双指针  相似题目  接雨水  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/contains-duplicate/contains-duplicate.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/contains-duplicate/contains-duplicate.cpp/</guid>
      <description>// @Title: 存在重复元素 (Contains Duplicate) // @Author: 1394466835@qq.com // @Date: 2019-06-14 19:25:28 // @Runtime: 48 ms // @Memory: 16.2 MB class Solution { public: // Using HashTable  // Time Complexity: O(n)  // Space Complexity: O(n)  bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_set&amp;lt;int&amp;gt; record; for (int i = 0; i &amp;lt; nums.size(); i++) { if (record.find(nums[i]) == record.end()) record.insert(nums[i]); else return true; } return false; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/contains-duplicate/contains-duplicate.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/contains-duplicate/contains-duplicate.java/</guid>
      <description>// @Title: 存在重复元素 (Contains Duplicate) // @Author: 1394466835@qq.com // @Date: 2019-06-14 18:37:39 // @Runtime: 415 ms // @Memory: 44.9 MB class Solution { public boolean containsDuplicate(int[] nums) { for (int i = 0; i &amp;lt; nums.length; i++) { for (int j = i + 1; j &amp;lt; nums.length; j++) { if (nums[i] == nums[j]) return true; } } return false; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/contains-duplicate/contains-duplicate.py/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/contains-duplicate/contains-duplicate.py/</guid>
      <description># @Title: 存在重复元素 (Contains Duplicate) # @Author: 1394466835@qq.com # @Date: 2019-06-14 19:27:17 # @Runtime: 148 ms # @Memory: 16.8 MB class Solution(object): def containsDuplicate(self, nums): &amp;#34;&amp;#34;&amp;#34; :type nums: List[int] :rtype: bool &amp;#34;&amp;#34;&amp;#34; return len(nums) != len(set(nums)) </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/contains-duplicate/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/contains-duplicate/readme/</guid>
      <description>| English | 简体中文 |
217. 存在重复元素 题目描述 给定一个整数数组，判断是否存在重复元素。
如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。
 示例 1:
输入: [1,2,3,1]输出: true示例 2:
输入: [1,2,3,4]输出: false示例 3:
输入: [1,1,1,3,3,4,3,2,4,2]输出: true相关话题  数组 哈希表 排序  相似题目  存在重复元素 II 存在重复元素 III  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/convert-a-number-to-hexadecimal/convert-a-number-to-hexadecimal.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/convert-a-number-to-hexadecimal/convert-a-number-to-hexadecimal.java/</guid>
      <description>// @Title: 数字转换为十六进制数 (Convert a Number to Hexadecimal) // @Author: 1394466835@qq.com // @Date: 2021-10-03 15:09:28 // @Runtime: 0 ms // @Memory: 35.7 MB class Solution { public String toHex(int _num) { if (_num == 0) return &amp;#34;0&amp;#34;; StringBuilder sb = new StringBuilder(); long num = _num; // 负数 转换成一个二进制表示形式一样的数 	if (num &amp;lt; 0) num = (long) (Math.pow(2, 32) + num); while (num != 0) { long r = num % 16; if (r &amp;gt;= 10) { sb.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/convert-a-number-to-hexadecimal/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/convert-a-number-to-hexadecimal/readme/</guid>
      <description>| English | 简体中文 |
405. 数字转换为十六进制数 题目描述 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用&amp;nbsp;补码运算&amp;nbsp;方法。
注意:
十六进制中所有字母(a-f)都必须是小写。十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符&amp;#39;0&amp;#39;来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。&amp;nbsp;给定的数确保在32位有符号整数范围内。不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。示例 1：
输入:26输出:&amp;quot;1a&amp;quot;示例 2：
输入:-1输出:&amp;quot;ffffffff&amp;quot;相关话题  位运算 数学  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/convert-bst-to-greater-tree/convert-bst-to-greater-tree.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/convert-bst-to-greater-tree/convert-bst-to-greater-tree.java/</guid>
      <description>// @Title: 把二叉搜索树转换为累加树 (Convert BST to Greater Tree) // @Author: 1394466835@qq.com // @Date: 2019-10-31 16:37:51 // @Runtime: 1 ms // @Memory: 40.4 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { private int sum = 0; public TreeNode convertBST(TreeNode root) { if (root !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/convert-bst-to-greater-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/convert-bst-to-greater-tree/readme/</guid>
      <description>| English | 简体中文 |
538. 把二叉搜索树转换为累加树 题目描述 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node&amp;nbsp;的新值等于原树中大于或等于&amp;nbsp;node.val&amp;nbsp;的值之和。
提醒一下，二叉搜索树满足下列约束条件：
节点的左子树仅包含键 小于 节点键的节点。节点的右子树仅包含键 大于 节点键的节点。左右子树也必须是二叉搜索树。注意：本题和 1038:&amp;nbsp;https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同
&amp;nbsp;
示例 1：

输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]示例 2：
输入：root = [0,null,1]输出：[1,null,1]示例 3：
输入：root = [1,0,2]输出：[3,3,2]示例 4：
输入：root = [3,2,4,1]输出：[7,9,4,10]&amp;nbsp;
提示：
树中的节点数介于 0&amp;nbsp;和 104&amp;nbsp;之间。每个节点的值介于 -104&amp;nbsp;和&amp;nbsp;104&amp;nbsp;之间。树中的所有值 互不相同 。给定的树为二叉搜索树。相关话题  树 深度优先搜索 二叉搜索树 二叉树  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/convert-sorted-array-to-binary-search-tree/convert-sorted-array-to-binary-search-tree.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/convert-sorted-array-to-binary-search-tree/convert-sorted-array-to-binary-search-tree.java/</guid>
      <description>// @Title: 将有序数组转换为二叉搜索树 (Convert Sorted Array to Binary Search Tree) // @Author: 1394466835@qq.com // @Date: 2020-10-26 08:41:31 // @Runtime: 0 ms // @Memory: 38.2 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode sortedArrayToBST(int[] nums) { return helper(nums, 0, nums.length - 1); } private TreeNode helper(int[] nums, int lo, int hi) { if (lo &amp;gt; hi) { return null; } int mid = (hi - lo) / 2 + lo; TreeNode root = new TreeNode(nums[mid]); root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/convert-sorted-array-to-binary-search-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/convert-sorted-array-to-binary-search-tree/readme/</guid>
      <description>| English | 简体中文 |
108. 将有序数组转换为二叉搜索树 题目描述 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
 示例 1：
输入：nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：示例 2：
输入：nums = [1,3]输出：[3,1]解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。 提示：
1 4-104 4nums 按 严格递增 顺序排列相关话题  树 二叉搜索树 数组 分治 二叉树  相似题目  有序链表转换二叉搜索树  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/convert-to-base-2/convert-to-base-2.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/convert-to-base-2/convert-to-base-2.java/</guid>
      <description>// @Title: 负二进制转换 (Convert to Base -2) // @Author: 1394466835@qq.com // @Date: 2019-09-08 10:29:29 // @Runtime: 2 ms // @Memory: 33.8 MB class Solution { public String baseNeg2(int N) { StringBuilder res = new StringBuilder(); while (N != 0) { res.append(N &amp;amp; 1); N = -(N &amp;gt;&amp;gt; 1); } return res.length() &amp;gt; 0 ? res.reverse().toString() : &amp;#34;0&amp;#34;; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/convert-to-base-2/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/convert-to-base-2/readme/</guid>
      <description>| English | 简体中文 |
1017. 负二进制转换 题目描述 给出数字&amp;nbsp;N，返回由若干&amp;nbsp;&amp;quot;0&amp;quot;&amp;nbsp;和&amp;nbsp;&amp;quot;1&amp;quot;组成的字符串，该字符串为 N&amp;nbsp;的负二进制（base -2）表示。
除非字符串就是&amp;nbsp;&amp;quot;0&amp;quot;，否则返回的字符串中不能含有前导零。
&amp;nbsp;
示例 1：
输入：2输出：&amp;quot;110&amp;quot;解释：(-2) ^ 2 + (-2) ^ 1 = 2示例 2：
输入：3输出：&amp;quot;111&amp;quot;解释：(-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3示例 3：
输入：4输出：&amp;quot;100&amp;quot;解释：(-2) ^ 2 = 4&amp;nbsp;
提示：
0 &amp;lt;= N &amp;lt;= 10^9相关话题  数学  相似题目  加密数字  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/customers-who-never-order/customers-who-never-order.sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/customers-who-never-order/customers-who-never-order.sql/</guid>
      <description>-- @Title: 从不订购的客户 (Customers Who Never Order) -- @Author: 1394466835@qq.com -- @Date: 2019-04-15 17:04:44 -- @Runtime: 764 ms -- @Memory: N/A # Write your MySQL query statement below select customers.name as &amp;#39;Customers&amp;#39; from customers where customers.id not in( select customerid from orders ) </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/customers-who-never-order/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/customers-who-never-order/readme/</guid>
      <description>| English | 简体中文 |
183. 从不订购的客户 题目描述 某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。
Customers 表：
+----+-------+| Id | Name |+----+-------+| 1 | Joe || 2 | Henry || 3 | Sam || 4 | Max |+----+-------+Orders 表：
+----+------------+| Id | CustomerId |+----+------------+| 1 | 3 || 2 | 1 |+----+------------+例如给定上述表格，你的查询应返回：
+-----------+| Customers |+-----------+| Henry || Max |+-----------+相关话题  数据库  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/decoded-string-at-index/decoded-string-at-index.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/decoded-string-at-index/decoded-string-at-index.cpp/</guid>
      <description>// @Title: 索引处的解码字符串 (Decoded String at Index) // @Author: 1394466835@qq.com // @Date: 2019-04-26 17:21:29 // @Runtime: 8 ms // @Memory: 8.2 MB class Solution { public: /// Recursion  /// Time Complexity: O(len(S)*logK)  /// Space Complexity: O(logK)  string decodeAtIndex(string S, int K) { int curl = 0; int repeat = 1; for (auto c : S) { if (isalpha(c)) { if (curl*repeat+1 == K) { return string(1,c); } curl = curl * repeat + 1; repeat = 1; } else { repeat *= (c - &amp;#39;0&amp;#39;); if ((long long)K &amp;lt;= (long long)curl * (long long)repeat) { return decodeAtIndex(S, (K-1) % curl + 1); } } } return &amp;#34;&amp;#34;; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/decoded-string-at-index/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/decoded-string-at-index/readme/</guid>
      <description>| English | 简体中文 |
880. 索引处的解码字符串 题目描述 给定一个编码字符串 S。请你找出 解码字符串 并将其写入磁带。解码时，从编码字符串中 每次读取一个字符 ，并采取以下步骤：
如果所读的字符是字母，则将该字母写在磁带上。如果所读的字符是数字（例如 d），则整个当前磁带总共会被重复写&amp;nbsp;d-1 次。现在，对于给定的编码字符串 S 和索引 K，查找并返回解码字符串中的第&amp;nbsp;K&amp;nbsp;个字母。
&amp;nbsp;
示例 1：
输入：S = &amp;quot;leet2code3&amp;quot;, K = 10输出：&amp;quot;o&amp;quot;解释：解码后的字符串为 &amp;quot;leetleetcodeleetleetcodeleetleetcode&amp;quot;。字符串中的第 10 个字母是 &amp;quot;o&amp;quot;。示例 2：
输入：S = &amp;quot;ha22&amp;quot;, K = 5输出：&amp;quot;h&amp;quot;解释：解码后的字符串为 &amp;quot;hahahaha&amp;quot;。第 5 个字母是 &amp;quot;h&amp;quot;。示例 3：
输入：S = &amp;quot;a2345678999999999999999&amp;quot;, K = 1输出：&amp;quot;a&amp;quot;解释：解码后的字符串为 &amp;quot;a&amp;quot; 重复 8301530446056247680 次。第 1 个字母是 &amp;quot;a&amp;quot;。&amp;nbsp;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/delete-node-in-a-bst/delete-node-in-a-bst.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/delete-node-in-a-bst/delete-node-in-a-bst.java/</guid>
      <description>// @Title: 删除二叉搜索树中的节点 (Delete Node in a BST) // @Author: 1394466835@qq.com // @Date: 2020-10-22 09:56:31 // @Runtime: 0 ms // @Memory: 38.7 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/delete-node-in-a-bst/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/delete-node-in-a-bst/readme/</guid>
      <description>| English | 简体中文 |
450. 删除二叉搜索树中的节点 题目描述 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的&amp;nbsp;key&amp;nbsp;对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
一般来说，删除节点可分为两个步骤：
首先找到需要删除的节点；如果找到了，删除它。说明： 要求算法时间复杂度为&amp;nbsp;O(h)，h 为树的高度。
示例:
root = [5,3,6,2,4,null,7]key = 35/ \3 6/ \ \2 4 7给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。5/ \4 6/ \2 7另一个正确答案是 [5,2,6,null,4,null,7]。5/ \2 6\ \4 7相关话题  树 二叉搜索树 二叉树  相似题目  拆分二叉搜索树  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/design-linked-list/design-linked-list.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/design-linked-list/design-linked-list.java/</guid>
      <description>// @Title: 设计链表 (Design Linked List) // @Author: 1394466835@qq.com // @Date: 2021-07-09 20:48:48 // @Runtime: 11 ms // @Memory: 39.2 MB class MyLinkedList { private class Node { public int val; public Node next; public Node(int val) { this.val = val; this.next = null; } } private int size; private Node head; private Node node(int index) { Node res = head; for (int i = 0; i &amp;lt; index; i++) { res = res.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/design-linked-list/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/design-linked-list/readme/</guid>
      <description>| English | 简体中文 |
707. 设计链表 题目描述 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val&amp;nbsp;和&amp;nbsp;next。val&amp;nbsp;是当前节点的值，next&amp;nbsp;是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性&amp;nbsp;prev&amp;nbsp;以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。
在链表类中实现这些功能：
get(index)：获取链表中第&amp;nbsp;index&amp;nbsp;个节点的值。如果索引无效，则返回-1。addAtHead(val)：在链表的第一个元素之前添加一个值为&amp;nbsp;val&amp;nbsp;的节点。插入后，新节点将成为链表的第一个节点。addAtTail(val)：将值为&amp;nbsp;val 的节点追加到链表的最后一个元素。addAtIndex(index,val)：在链表中的第&amp;nbsp;index&amp;nbsp;个节点之前添加值为&amp;nbsp;val&amp;nbsp; 的节点。如果&amp;nbsp;index&amp;nbsp;等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。deleteAtIndex(index)：如果索引&amp;nbsp;index 有效，则删除链表中的第&amp;nbsp;index 个节点。&amp;nbsp;
示例：
MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2); //链表变为1-&amp;gt; 2-&amp;gt; 3linkedList.get(1); //返回2linkedList.deleteAtIndex(1); //现在链表是1-&amp;gt; 3linkedList.get(1); //返回3&amp;nbsp;
提示：
所有val值都在&amp;nbsp;[1, 1000]&amp;nbsp;之内。操作次数将在&amp;nbsp;&amp;nbsp;[1, 1000]&amp;nbsp;之内。请不要使用内置的 LinkedList 库。相关话题  设计 链表  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/destination-city/destination-city.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/destination-city/destination-city.java/</guid>
      <description>// @Title: 旅行终点站 (Destination City) // @Author: 1394466835@qq.com // @Date: 2021-10-03 14:35:51 // @Runtime: 2 ms // @Memory: 38 MB class Solution { public String destCity(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; paths) { Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for (var path : paths) { set.add(path.get(0)); } for (var path : paths) { if (!set.contains(path.get(1))) { return path.get(1); } } return null; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/destination-city/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/destination-city/readme/</guid>
      <description>| English | 简体中文 |
1436. 旅行终点站 题目描述 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。
题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。
&amp;nbsp;
示例 1：
输入：paths = [[&#34;London&#34;,&#34;New York&#34;],[&#34;New York&#34;,&#34;Lima&#34;],[&#34;Lima&#34;,&#34;Sao Paulo&#34;]]输出：&#34;Sao Paulo&#34; 解释：从 &#34;London&#34; 出发，最后抵达终点站 &#34;Sao Paulo&#34; 。本次旅行的路线是 &#34;London&#34; -&amp;gt; &#34;New York&#34; -&amp;gt; &#34;Lima&#34; -&amp;gt; &#34;Sao Paulo&#34; 。示例 2：
输入：paths = [[&#34;B&#34;,&#34;C&#34;],[&#34;D&#34;,&#34;B&#34;],[&#34;C&#34;,&#34;A&#34;]]输出：&#34;A&#34;解释：所有可能的线路是：&#34;D&#34; -&amp;gt; &#34;B&#34; -&amp;gt; &#34;C&#34; -&amp;gt; &#34;A&#34;.&amp;nbsp;&#34;B&#34; -&amp;gt; &#34;C&#34; -&amp;gt; &#34;A&#34;.&amp;nbsp;&#34;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/diameter-of-binary-tree/diameter-of-binary-tree.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/diameter-of-binary-tree/diameter-of-binary-tree.java/</guid>
      <description>// @Title: 二叉树的直径 (Diameter of Binary Tree) // @Author: 1394466835@qq.com // @Date: 2020-05-04 15:43:08 // @Runtime: 1 ms // @Memory: 39.2 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { private int max; public int diameterOfBinaryTree(TreeNode root) { maxDepth(root); return max; } private int maxDepth(TreeNode root) { if (root == null) return 0; int l = maxDepth(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/diameter-of-binary-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/diameter-of-binary-tree/readme/</guid>
      <description>| English | 简体中文 |
543. 二叉树的直径 题目描述 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
&amp;nbsp;
示例 :
给定二叉树
 1/ \2 3/ \ 4 5 返回&amp;nbsp;3, 它的长度是路径 [4,2,1,3] 或者&amp;nbsp;[5,2,1,3]。
&amp;nbsp;
注意：两结点之间的路径长度是以它们之间边的数目表示。
相关话题  树 深度优先搜索 二叉树  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/dui-lie-de-zui-da-zhi-lcof/dui-lie-de-zui-da-zhi-lcof.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/dui-lie-de-zui-da-zhi-lcof/dui-lie-de-zui-da-zhi-lcof.java/</guid>
      <description>// @Title: 队列的最大值 (队列的最大值 LCOF) // @Author: 1394466835@qq.com // @Date: 2020-03-07 20:43:13 // @Runtime: 37 ms // @Memory: 44.4 MB class MaxQueue { private Deque&amp;lt;Integer&amp;gt; q; private Deque&amp;lt;Integer&amp;gt; m; public MaxQueue() { q = new ArrayDeque&amp;lt;&amp;gt;(); m = new ArrayDeque&amp;lt;&amp;gt;(); } public int max_value() { return q.isEmpty() ? -1 : m.peek(); } public void push_back(int value) { q.offer(value); while (!m.isEmpty() &amp;amp;&amp;amp; value &amp;gt; m.peekLast()) m.pollLast(); m.offer(value); } public int pop_front() { if (q.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/dui-lie-de-zui-da-zhi-lcof/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/dui-lie-de-zui-da-zhi-lcof/readme/</guid>
      <description>| English | 简体中文 |
剑指 Offer 59 - II. 队列的最大值 题目描述 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。
若队列为空，pop_front 和 max_value&amp;nbsp;需要返回 -1
示例 1：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;push_back&amp;quot;,&amp;quot;max_value&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;][[],[1],[2],[],[],[]]输出:&amp;nbsp;[null,null,null,2,1,2]示例 2：
输入: [&amp;quot;MaxQueue&amp;quot;,&amp;quot;pop_front&amp;quot;,&amp;quot;max_value&amp;quot;][[],[],[]]输出:&amp;nbsp;[null,-1,-1]&amp;nbsp;
限制：
1 &amp;lt;= push_back,pop_front,max_value的总操作数&amp;nbsp;&amp;lt;= 100001 &amp;lt;= value &amp;lt;= 10^5相关话题  设计 队列 单调队列  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/er-cha-shu-de-shen-du-lcof/er-cha-shu-de-shen-du-lcof.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/er-cha-shu-de-shen-du-lcof/er-cha-shu-de-shen-du-lcof.java/</guid>
      <description>// @Title: 二叉树的深度 (二叉树的深度 LCOF) // @Author: 1394466835@qq.com // @Date: 2020-03-14 17:54:46 // @Runtime: 0 ms // @Memory: 37.8 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/er-cha-shu-de-shen-du-lcof/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/er-cha-shu-de-shen-du-lcof/readme/</guid>
      <description>| English | 简体中文 |
剑指 Offer 55 - I. 二叉树的深度 题目描述 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
例如：
给定二叉树 [3,9,20,null,null,15,7]，
 3/ \9 20/ \15 7返回它的最大深度&amp;nbsp;3 。
&amp;nbsp;
提示：
节点总数 &amp;lt;= 10000注意：本题与主站 104&amp;nbsp;题相同：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/
相关话题  树 深度优先搜索 广度优先搜索 二叉树  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/find-first-and-last-position-of-element-in-sorted-array/find-first-and-last-position-of-element-in-sorted-array.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/find-first-and-last-position-of-element-in-sorted-array/find-first-and-last-position-of-element-in-sorted-array.java/</guid>
      <description>// @Title: 在排序数组中查找元素的第一个和最后一个位置 (Find First and Last Position of Element in Sorted Array) // @Author: 1394466835@qq.com // @Date: 2021-05-19 14:09:20 // @Runtime: 0 ms // @Memory: 41.7 MB class Solution { public int[] searchRange(int[] nums, int target) { int[] result = new int[]{-1, -1}; if (nums.length == 0) return result; int begin = 0, end = nums.length - 1; int mid; // 二分搜索找第一个位置 	while (begin &amp;lt; end) { mid = ((end - begin) &amp;gt;&amp;gt; 1) + begin; if (target &amp;gt; nums[mid]) { begin = mid + 1; } else { end = mid; } } if (target !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/find-first-and-last-position-of-element-in-sorted-array/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/find-first-and-last-position-of-element-in-sorted-array/readme/</guid>
      <description>| English | 简体中文 |
34. 在排序数组中查找元素的第一个和最后一个位置 题目描述 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
进阶：
你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 示例 1：
输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]示例 2：
输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]示例 3：
输入：nums = [], target = 0输出：[-1,-1] 提示：
0 5-109 9nums 是一个非递减数组-109 9相关话题  数组 二分查找  相似题目  第一个错误的版本  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/find-the-difference/find-the-difference.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/find-the-difference/find-the-difference.cpp/</guid>
      <description>// @Title: 找不同 (Find the Difference) // @Author: 1394466835@qq.com // @Date: 2019-04-15 16:59:53 // @Runtime: 12 ms // @Memory: 8.9 MB class Solution { public: char findTheDifference(string s, string t) { unordered_map&amp;lt;char, int&amp;gt; m; for(auto c : s) m[c]++; for(auto c : t) { m[c]--; if(m[c] &amp;lt; 0) return c; } return &amp;#39;\0&amp;#39;; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/find-the-difference/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/find-the-difference/readme/</guid>
      <description>| English | 简体中文 |
389. 找不同 题目描述 给定两个字符串 s 和 t，它们只包含小写字母。
字符串&amp;nbsp;t&amp;nbsp;由字符串&amp;nbsp;s&amp;nbsp;随机重排，然后在随机位置添加一个字母。
请找出在 t 中被添加的字母。
&amp;nbsp;
示例 1：
输入：s = &amp;quot;abcd&amp;quot;, t = &amp;quot;abcde&amp;quot;输出：&amp;quot;e&amp;quot;解释：&amp;#39;e&amp;#39; 是那个被添加的字母。示例 2：
输入：s = &amp;quot;&amp;quot;, t = &amp;quot;y&amp;quot;输出：&amp;quot;y&amp;quot;示例 3：
输入：s = &amp;quot;a&amp;quot;, t = &amp;quot;aa&amp;quot;输出：&amp;quot;a&amp;quot;示例 4：
输入：s = &amp;quot;ae&amp;quot;, t = &amp;quot;aea&amp;quot;输出：&amp;quot;a&amp;quot;&amp;nbsp;
提示：
0 &amp;lt;= s.length &amp;lt;= 1000t.length == s.length + 1s 和 t 只包含小写字母相关话题  位运算 哈希表 字符串 排序  相似题目  只出现一次的数字  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/first-bad-version/first-bad-version.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/first-bad-version/first-bad-version.cpp/</guid>
      <description>// @Title: 第一个错误的版本 (First Bad Version) // @Author: 1394466835@qq.com // @Date: 2019-04-15 17:16:47 // @Runtime: 4 ms // @Memory: 7.9 MB // Forward declaration of isBadVersion API. bool isBadVersion(int version); class Solution { public: int firstBadVersion(int n) { //Binary search  int low = 1, high = n; while(low &amp;lt;= high) { int mid = low + (high-low) / 2; if(isBadVersion(mid) &amp;amp;&amp;amp; !isBadVersion(mid-1)) return mid; if(isBadVersion(mid)) { high = mid - 1; } else { low = mid + 1; } } return -1; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/first-bad-version/first-bad-version.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/first-bad-version/first-bad-version.java/</guid>
      <description>// @Title: 第一个错误的版本 (First Bad Version) // @Author: 1394466835@qq.com // @Date: 2021-10-03 07:15:00 // @Runtime: 11 ms // @Memory: 35.2 MB /* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */ public class Solution extends VersionControl { public int firstBadVersion(int n) { // [low, high]  int low = 1, high = n; int mid; while (low &amp;lt; high) { mid = (high - low) / 2 + low; if (isBadVersion(mid)) { high = mid; } else { low = mid + 1; } } return low; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/first-bad-version/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/first-bad-version/readme/</guid>
      <description>| English | 简体中文 |
278. 第一个错误的版本 题目描述 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
示例 1：
输入：n = 5, bad = 4输出：4解释：调用 isBadVersion(3) - false 调用 isBadVersion(5) - true 调用 isBadVersion(4) - true所以，4 是第一个错误的版本。示例 2：
输入：n = 1, bad = 1输出：1 提示：
1 31 - 1相关话题  二分查找 交互  相似题目  在排序数组中查找元素的第一个和最后一个位置 搜索插入位置 猜数字大小  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/flood-fill/flood-fill.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/flood-fill/flood-fill.java/</guid>
      <description>// @Title: 图像渲染 (Flood Fill) // @Author: 1394466835@qq.com // @Date: 2021-07-21 19:01:28 // @Runtime: 1 ms // @Memory: 39.3 MB class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int newColor) { boolean[][] visited = new boolean[image.length][image[0].length]; helper(image, sr, sc, image[sr][sc], newColor, visited); return image; } public void helper(int[][] image, int sr, int sc, int baseColor, int newColor, boolean[][] visited) { if (sr &amp;lt; 0 || sr &amp;gt;= image.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/flood-fill/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/flood-fill/readme/</guid>
      <description>| English | 简体中文 |
733. 图像渲染 题目描述 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。
给你一个坐标&amp;nbsp;(sr, sc)&amp;nbsp;表示图像渲染开始的像素值（行 ，列）和一个新的颜色值&amp;nbsp;newColor，让你重新上色这幅图像。
为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，&amp;hellip;&amp;hellip;，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。
最后返回经过上色渲染后的图像。
示例 1:
输入: image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2输出: [[2,2,2],[2,2,0],[2,0,1]]解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。注意:
image 和&amp;nbsp;image[0]&amp;nbsp;的长度在范围&amp;nbsp;[1, 50] 内。给出的初始点将满足&amp;nbsp;0 &amp;lt;= sr &amp;lt; image.length 和&amp;nbsp;0 &amp;lt;= sc &amp;lt; image[0].length。image[i][j] 和&amp;nbsp;newColor&amp;nbsp;表示的颜色值在范围&amp;nbsp;[0, 65535]内。相关话题  深度优先搜索 广度优先搜索 数组 矩阵  相似题目  岛屿的周长  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/fraction-to-recurring-decimal/fraction-to-recurring-decimal.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/fraction-to-recurring-decimal/fraction-to-recurring-decimal.java/</guid>
      <description>// @Title: 分数到小数 (Fraction to Recurring Decimal) // @Author: 1394466835@qq.com // @Date: 2021-10-03 08:53:09 // @Runtime: 1 ms // @Memory: 35.8 MB class Solution { public String fractionToDecimal(int numerator, int denominator) { if (numerator == 0) { return &amp;#34;0&amp;#34;; } StringBuilder sb = new StringBuilder(); String sign = (numerator &amp;gt; 0) ^ (denominator &amp;gt; 0) ? &amp;#34;-&amp;#34; : &amp;#34;&amp;#34;; sb.append(sign); Long num = Math.abs((long) numerator); Long den = Math.abs((long) denominator); // 整数部分 	sb.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/fraction-to-recurring-decimal/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/fraction-to-recurring-decimal/readme/</guid>
      <description>| English | 简体中文 |
166. 分数到小数 题目描述 给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。
如果小数部分为循环小数，则将循环的部分括在括号内。
如果存在多个答案，只需返回 任意一个 。
对于所有给定的输入，保证 答案字符串的长度小于 104 。
 示例 1：
输入：numerator = 1, denominator = 2输出：&#34;0.5&#34;示例 2：
输入：numerator = 2, denominator = 1输出：&#34;2&#34;示例 3：
输入：numerator = 2, denominator = 3输出：&#34;0.(6)&#34;示例 4：
输入：numerator = 4, denominator = 333输出：&#34;0.(012)&#34;示例 5：
输入：numerator = 1, denominator = 5输出：&#34;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/group-anagrams/group-anagrams.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/group-anagrams/group-anagrams.java/</guid>
      <description>// @Title: 字母异位词分组 (Group Anagrams) // @Author: 1394466835@qq.com // @Date: 2020-04-20 08:14:11 // @Runtime: 10 ms // @Memory: 42.3 MB class Solution { public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupAnagrams(String[] strs) { if (strs == null || strs.length == 0) return new ArrayList&amp;lt;&amp;gt;(); Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (String s : strs) { char[] ca = new char[26]; for (char c : s.toCharArray()) { ca[c-&amp;#39;a&amp;#39;]++; } String keyStr = String.valueOf(ca); if (!map.containsKey(keyStr)) map.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/group-anagrams/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/group-anagrams/readme/</guid>
      <description>| English | 简体中文 |
49. 字母异位词分组 题目描述 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母都恰好只用一次。
&amp;nbsp;
示例 1:
输入: strs = [&#34;eat&#34;, &#34;tea&#34;, &#34;tan&#34;, &#34;ate&#34;, &#34;nat&#34;, &#34;bat&#34;]输出: [[&#34;bat&#34;],[&#34;nat&#34;,&#34;tan&#34;],[&#34;ate&#34;,&#34;eat&#34;,&#34;tea&#34;]]示例 2:
输入: strs = [&#34;&#34;]输出: [[&#34;&#34;]]示例 3:
输入: strs = [&#34;a&#34;]输出: [[&#34;a&#34;]]&amp;nbsp;
提示：
1 &amp;lt;= strs.length &amp;lt;= 1040 &amp;lt;= strs[i].length &amp;lt;= 100strs[i]&amp;nbsp;仅包含小写字母相关话题  哈希表 字符串 排序  相似题目  有效的字母异位词 移位字符串分组  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/guess-number-higher-or-lower/guess-number-higher-or-lower.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/guess-number-higher-or-lower/guess-number-higher-or-lower.cpp/</guid>
      <description>// @Title: 猜数字大小 (Guess Number Higher or Lower) // @Author: 1394466835@qq.com // @Date: 2019-04-15 17:27:18 // @Runtime: 8 ms // @Memory: 8 MB // Forward declaration of guess API. // @param num, your guess // @return -1 if my number is lower, 1 if my number is higher, otherwise return 0 int guess(int num); class Solution { public: int guessNumber(int n) { //Binary Search  int low = 1, high = n; while(low &amp;lt;= high) { int mid = low + (high - low) / 2; if(guess(mid) == 1) { low = mid + 1; } else if (guess(mid) == -1) { high = mid - 1; } else if (guess(mid) == 0) { return mid; } } return 0; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/guess-number-higher-or-lower/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/guess-number-higher-or-lower/readme/</guid>
      <description>| English | 简体中文 |
374. 猜数字大小 题目描述 猜数字游戏的规则如下：
每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：
-1：我选出的数字比你猜的数字小 pick 1：我选出的数字比你猜的数字大 pick  num0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num返回我选出的数字。
 示例 1：
输入：n = 10, pick = 6输出：6示例 2：
输入：n = 1, pick = 1输出：1示例 3：
输入：n = 2, pick = 1输出：1示例 4：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/happy-number/happy-number.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/happy-number/happy-number.java/</guid>
      <description>// @Title: 快乐数 (Happy Number) // @Author: 1394466835@qq.com // @Date: 2020-04-05 19:21:04 // @Runtime: 1 ms // @Memory: 35.7 MB class Solution { public boolean isHappy(int n) { if (n &amp;lt;= 0) return false; if (n == 1) return true; int nextNum = n; while (true) { nextNum = getNextNum(nextNum); if (nextNum == 1) return true; if (nextNum == 89) return false; } } public int getNextNum(int n) { int nextNum = 0; while (n !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/happy-number/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/happy-number/readme/</guid>
      <description>| English | 简体中文 |
202. 快乐数 题目描述 编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。如果 n 是快乐数就返回 true ；不是，则返回 false 。
 示例 1：
输入：19输出：true解释：12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1示例 2：
输入：n = 2输出：false 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/insertion-sort-list/insertion-sort-list.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/insertion-sort-list/insertion-sort-list.java/</guid>
      <description>// @Title: 对链表进行插入排序 (Insertion Sort List) // @Author: 1394466835@qq.com // @Date: 2021-07-06 19:24:53 // @Runtime: 25 ms // @Memory: 38.2 MB /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode insertionSortList(ListNode head) { ListNode dummy = new ListNode(-1); ListNode cur = head, next; ListNode pre; while (cur !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/insertion-sort-list/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/insertion-sort-list/readme/</guid>
      <description>| English | 简体中文 |
147. 对链表进行插入排序 题目描述 对链表进行插入排序。
插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。
&amp;nbsp;
插入排序算法：
插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。重复直到所有输入数据插入完为止。&amp;nbsp;
示例 1：
输入: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4示例&amp;nbsp;2：
输入: -1-&amp;gt;5-&amp;gt;3-&amp;gt;4-&amp;gt;0输出: -1-&amp;gt;0-&amp;gt;3-&amp;gt;4-&amp;gt;5相关话题  链表 排序  相似题目  排序链表 循环有序列表的插入  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/intersection-of-two-arrays-ii/intersection-of-two-arrays-ii.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/intersection-of-two-arrays-ii/intersection-of-two-arrays-ii.java/</guid>
      <description>// @Title: 两个数组的交集 II (Intersection of Two Arrays II) // @Author: 1394466835@qq.com // @Date: 2019-06-15 19:08:00 // @Runtime: 8 ms // @Memory: 35.6 MB class Solution { // Use HashMap  public int[] intersect(int[] nums1, int[] nums2) { HashMap&amp;lt;Integer,Integer&amp;gt; record = new HashMap&amp;lt;Integer, Integer&amp;gt;(); for (int num : nums1) { if (!record.containsKey(num)) { record.put(num, 1); } else { record.put(num, record.get(num)+1); } } ArrayList&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;Integer&amp;gt;(); for (int num : nums2) { if (record.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/intersection-of-two-arrays-ii/intersection-of-two-arrays-ii.py/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/intersection-of-two-arrays-ii/intersection-of-two-arrays-ii.py/</guid>
      <description># @Title: 两个数组的交集 II (Intersection of Two Arrays II) # @Author: 1394466835@qq.com # @Date: 2019-06-15 19:33:38 # @Runtime: 40 ms # @Memory: 11.4 MB class Solution(object): def intersect(self, nums1, nums2): &amp;#34;&amp;#34;&amp;#34; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &amp;#34;&amp;#34;&amp;#34; nums1.sort() nums2.sort() i, j = 0, 0 ret = [] while i &amp;lt; len(nums1) and j &amp;lt; len(nums2): if (nums1[i] == nums2[j]): ret.append(nums1[i]) i += 1 j += 1 elif nums1[i] &amp;lt; nums2[j]: i += 1 else: j += 1 return ret </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/intersection-of-two-arrays-ii/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/intersection-of-two-arrays-ii/readme/</guid>
      <description>| English | 简体中文 |
350. 两个数组的交集 II 题目描述 给定两个数组，编写一个函数来计算它们的交集。
&amp;nbsp;
示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2]示例 2:
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9]&amp;nbsp;
说明：
输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。我们可以不考虑输出结果的顺序。进阶：
如果给定的数组已经排好序呢？你将如何优化你的算法？如果&amp;nbsp;nums1&amp;nbsp;的大小比&amp;nbsp;nums2&amp;nbsp;小很多，哪种方法更优？如果&amp;nbsp;nums2&amp;nbsp;的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？相关话题  数组 哈希表 双指针 二分查找 排序  相似题目  两个数组的交集 查找共用字符  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/intersection-of-two-arrays/intersection-of-two-arrays.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/intersection-of-two-arrays/intersection-of-two-arrays.java/</guid>
      <description>// @Title: 两个数组的交集 (Intersection of Two Arrays) // @Author: 1394466835@qq.com // @Date: 2020-11-30 17:01:25 // @Runtime: 8 ms // @Memory: 38.9 MB class Solution { public int[] intersection(int[] nums1, int[] nums2) { Set&amp;lt;Integer&amp;gt; set = Arrays.stream(nums2).boxed().collect(Collectors.toSet()); return Arrays.stream(nums1).distinct().filter(set::contains).toArray(); } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/intersection-of-two-arrays/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/intersection-of-two-arrays/readme/</guid>
      <description>| English | 简体中文 |
349. 两个数组的交集 题目描述 给定两个数组，编写一个函数来计算它们的交集。
&amp;nbsp;
示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2]示例 2：
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]&amp;nbsp;
说明：
输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。相关话题  数组 哈希表 双指针 二分查找 排序  相似题目  两个数组的交集 II 三个有序数组的交集  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/invert-binary-tree/invert-binary-tree.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/invert-binary-tree/invert-binary-tree.java/</guid>
      <description>// @Title: 翻转二叉树 (Invert Binary Tree) // @Author: 1394466835@qq.com // @Date: 2020-03-14 17:59:28 // @Runtime: 0 ms // @Memory: 36.2 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) return null; TreeNode left = invertTree(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/invert-binary-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/invert-binary-tree/readme/</guid>
      <description>| English | 简体中文 |
226. 翻转二叉树 题目描述 翻转一棵二叉树。
示例：
输入：
 4/ \2 7/ \ / \1 3 6 9输出：
 4/ \7 2/ \ / \9 6 3 1备注:
这个问题是受到 Max Howell 的 原问题 启发的 ：
谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。相关话题  树 深度优先搜索 广度优先搜索 二叉树  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/jump-game/jump-game.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/jump-game/jump-game.java/</guid>
      <description>// @Title: 跳跃游戏 (Jump Game) // @Author: 1394466835@qq.com // @Date: 2021-08-27 20:34:04 // @Runtime: 1 ms // @Memory: 39.7 MB class Solution { public boolean canJump(int[] nums) { int len = nums.length; int end = len - 1; for (int i = len - 2; i &amp;gt;= 0; i--) { if (nums[i] + i &amp;gt;= end) { end = i; } } return end == 0; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/jump-game/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/jump-game/readme/</guid>
      <description>| English | 简体中文 |
55. 跳跃游戏 题目描述 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标。
 示例 1：
输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。示例 2：
输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示：
1 40 5相关话题  贪心 数组 动态规划  相似题目  跳跃游戏 II  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/kth-smallest-element-in-a-bst/kth-smallest-element-in-a-bst.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/kth-smallest-element-in-a-bst/kth-smallest-element-in-a-bst.java/</guid>
      <description>// @Title: 二叉搜索树中第K小的元素 (Kth Smallest Element in a BST) // @Author: 1394466835@qq.com // @Date: 2020-10-27 18:32:24 // @Runtime: 0 ms // @Memory: 37.9 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/kth-smallest-element-in-a-bst/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/kth-smallest-element-in-a-bst/readme/</guid>
      <description>| English | 简体中文 |
230. 二叉搜索树中第K小的元素 题目描述 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。
 示例 1：
输入：root = [3,1,4,null,2], k = 1输出：1示例 2：
输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3  提示：
树中的节点数为 n 。1 40 4 进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？
相关话题  树 深度优先搜索 二叉搜索树 二叉树  相似题目  二叉树的中序遍历 二叉树中第二小的节点  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/largest-number-at-least-twice-of-others/largest-number-at-least-twice-of-others.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/largest-number-at-least-twice-of-others/largest-number-at-least-twice-of-others.cpp/</guid>
      <description>// @Title: 至少是其他数字两倍的最大数 (Largest Number At Least Twice of Others) // @Author: 1394466835@qq.com // @Date: 2019-04-26 10:25:08 // @Runtime: 8 ms // @Memory: 8.2 MB class Solution { /// Linear Scan /// Time Complexity: O(n) /// Space Complexity: O(1) public: int dominantIndex(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int maxNum = *max_element(nums.begin(), nums.end()); int ret = -1; for (int i = 0; i &amp;lt; nums.size(); ++i) { if (nums[i] != maxNum) { if (2 * nums[i] &amp;gt; maxNum) return -1; } else { ret = i; } } return ret; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/largest-number-at-least-twice-of-others/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/largest-number-at-least-twice-of-others/readme/</guid>
      <description>| English | 简体中文 |
747. 至少是其他数字两倍的最大数 题目描述 给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。
请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。
 示例 1：
输入：nums = [3,6,1,0]输出：1解释：6 是最大的整数，对于数组中的其他整数，6 大于数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。示例 2：
输入：nums = [1,2,3,4]输出：-1解释：4 没有超过 3 的两倍大，所以返回 -1 。示例 3：
输入：nums = [1]输出：0解释：因为不存在其他数字，所以认为现有数字 1 至少是其他数字的两倍。 提示：
1 0 nums 中的最大元素是唯一的相关话题  数组 排序  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/largest-number/largest-number.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/largest-number/largest-number.cpp/</guid>
      <description>// @Title: 最大数 (Largest Number) // @Author: 1394466835@qq.com // @Date: 2019-04-29 13:25:43 // @Runtime: 20 ms // @Memory: 8.9 MB class Solution { public: // compare function  static bool comp (string&amp;amp; s1, string&amp;amp; s2) { return s1+s2 &amp;gt; s2+s1; } string largestNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { //convert into to string  vector&amp;lt;string&amp;gt; v; for (int i = 0; i &amp;lt; nums.size(); i++) { v.push_back(to_string(nums[i])); } //sort the string  sort(v.begin(), v.end(), comp); //generate the result  string result; for (int i = 0; i &amp;lt; v.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/largest-number/largest-number.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/largest-number/largest-number.java/</guid>
      <description>// @Title: 最大数 (Largest Number) // @Author: 1394466835@qq.com // @Date: 2019-04-29 13:19:50 // @Runtime: 60 ms // @Memory: 45.8 MB class Solution { public String largestNumber(int[] nums) { // 冒泡排序实现  for(int i = 0; i &amp;lt; nums.length; i++){ for(int j = 1; j &amp;lt; nums.length - i; j++){ if((&amp;#34;&amp;#34;+nums[j-1]+nums[j]) .compareTo(&amp;#34;&amp;#34;+nums[j]+nums[j-1])&amp;lt;0){ int temp = nums[j]; nums[j] = nums[j-1]; nums[j-1] = temp; } } } StringBuilder sb = new StringBuilder(); for(int i : nums) sb.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/largest-number/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/largest-number/readme/</guid>
      <description>| English | 简体中文 |
179. 最大数 题目描述 给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。
注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。
 示例 1：
输入：nums = [10,2]输出：&#34;210&#34;示例 2：
输入：nums = [3,30,34,5,9]输出：&#34;9534330&#34;示例 3：
输入：nums = [1]输出：&#34;1&#34;示例 4：
输入：nums = [10]输出：&#34;10&#34; 提示：
1 0 9相关话题  贪心 字符串 排序  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/largest-rectangle-in-histogram/largest-rectangle-in-histogram.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/largest-rectangle-in-histogram/largest-rectangle-in-histogram.java/</guid>
      <description>// @Title: 柱状图中最大的矩形 (Largest Rectangle in Histogram) // @Author: 1394466835@qq.com // @Date: 2020-02-16 20:54:34 // @Runtime: 18 ms // @Memory: 39.7 MB class Solution { public int largestRectangleArea(int[] heights) { Stack&amp;lt;Integer&amp;gt; s = new Stack&amp;lt;&amp;gt;(); int area_with_top = 0; int max_area = 0; int tp; int i = 0; while (i &amp;lt; heights.length) { if (s.isEmpty() || heights[i] &amp;gt;= heights[s.peek()]) { s.push(i++); } else { tp = s.pop(); area_with_top = heights[tp] * (s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/largest-rectangle-in-histogram/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/largest-rectangle-in-histogram/readme/</guid>
      <description>| English | 简体中文 |
84. 柱状图中最大的矩形 题目描述 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
求在该柱状图中，能够勾勒出来的矩形的最大面积。
 示例 1:
输入：heights = [2,1,5,6,2,3]输出：10解释：最大的矩形为图中红色区域，面积为 10示例 2：
输入： heights = [2,4]输出： 4 提示：
1 50 4相关话题  栈 数组 单调栈  相似题目  最大矩形  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/letter-case-permutation/letter-case-permutation.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/letter-case-permutation/letter-case-permutation.java/</guid>
      <description>// @Title: 字母大小写全排列 (Letter Case Permutation) // @Author: 1394466835@qq.com // @Date: 2021-08-09 06:14:24 // @Runtime: 1 ms // @Memory: 39.1 MB class Solution { public List&amp;lt;String&amp;gt; letterCasePermutation(String s) { List&amp;lt;String&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); dfs(s.toCharArray(), 0, ans); return ans; } private void dfs(char[] s, int i, List&amp;lt;String&amp;gt; ans) { if (i == s.length) { ans.add(new String(s)); return; } dfs(s, i + 1, ans); if (Character.isDigit(s[i])) { return; } // a-z: 97 - 122 	// A-Z: 65 - 90 	// &amp;#39;a&amp;#39;(b0110 0001) - &amp;#39;A&amp;#39;(b0100 0001) = 32(b0010 0000) 	s[i] ^= (1 &amp;lt;&amp;lt; 5); dfs(s, i + 1, ans); s[i] ^= (1 &amp;lt;&amp;lt; 5); } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/letter-case-permutation/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/letter-case-permutation/readme/</guid>
      <description>| English | 简体中文 |
784. 字母大小写全排列 题目描述 给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。
&amp;nbsp;
示例：输入：S = &amp;quot;a1b2&amp;quot;输出：[&amp;quot;a1b2&amp;quot;, &amp;quot;a1B2&amp;quot;, &amp;quot;A1b2&amp;quot;, &amp;quot;A1B2&amp;quot;]输入：S = &amp;quot;3z4&amp;quot;输出：[&amp;quot;3z4&amp;quot;, &amp;quot;3Z4&amp;quot;]输入：S = &amp;quot;12345&amp;quot;输出：[&amp;quot;12345&amp;quot;]&amp;nbsp;
提示：
S&amp;nbsp;的长度不超过12。S&amp;nbsp;仅由数字和字母组成。相关话题  位运算 字符串 回溯  相似题目  子集 花括号展开  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/letter-combinations-of-a-phone-number/letter-combinations-of-a-phone-number.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/letter-combinations-of-a-phone-number/letter-combinations-of-a-phone-number.java/</guid>
      <description>// @Title: 电话号码的字母组合 (Letter Combinations of a Phone Number) // @Author: 1394466835@qq.com // @Date: 2021-09-29 21:31:12 // @Runtime: 0 ms // @Memory: 37.1 MB class Solution { public List&amp;lt;String&amp;gt; letterCombinations(String digits) { List&amp;lt;String&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); if (digits == null || digits.length() == 0) return ans; String[] keyboard = new String[]{ &amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;abc&amp;#34;, &amp;#34;def&amp;#34;, &amp;#34;ghi&amp;#34;, &amp;#34;jkl&amp;#34;, &amp;#34;mno&amp;#34;, &amp;#34;pqrs&amp;#34;, &amp;#34;tuv&amp;#34;, &amp;#34;wxyz&amp;#34; }; dfs(ans, digits, keyboard, 0, new char[digits.length()]); return ans; } private void dfs(List&amp;lt;String&amp;gt; ans, String digits, String[] keyboard, int i, char[] cur) { if (i == digits.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/letter-combinations-of-a-phone-number/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/letter-combinations-of-a-phone-number/readme/</guid>
      <description>| English | 简体中文 |
17. 电话号码的字母组合 题目描述 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
 示例 1：
输入：digits = &#34;23&#34;输出：[&#34;ad&#34;,&#34;ae&#34;,&#34;af&#34;,&#34;bd&#34;,&#34;be&#34;,&#34;bf&#34;,&#34;cd&#34;,&#34;ce&#34;,&#34;cf&#34;]示例 2：
输入：digits = &#34;&#34;输出：[]示例 3：
输入：digits = &#34;2&#34;输出：[&#34;a&#34;,&#34;b&#34;,&#34;c&#34;] 提示：
0 digits[i] 是范围 [&#39;2&#39;, &#39;9&#39;] 的一个数字。相关话题  哈希表 字符串 回溯  相似题目  括号生成 组合总和 二进制手表  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/license-key-formatting/license-key-formatting.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/license-key-formatting/license-key-formatting.java/</guid>
      <description>// @Title: 密钥格式化 (License Key Formatting) // @Author: 1394466835@qq.com // @Date: 2021-10-04 18:55:24 // @Runtime: 11 ms // @Memory: 38.3 MB class Solution { public String licenseKeyFormatting(String s, int k) { StringBuilder sb = new StringBuilder(); for (int i = s.length() - 1, cnt = 0; i &amp;gt;= 0; i--) { char ch = s.charAt(i); if (ch == &amp;#39;-&amp;#39;) continue; if (cnt == k) { sb.append(&amp;#39;-&amp;#39;); cnt = 0; } sb.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/license-key-formatting/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/license-key-formatting/readme/</guid>
      <description>| English | 简体中文 |
482. 密钥格式化 题目描述 有一个密钥字符串 S ，只包含字母，数字以及 &amp;#39;-&amp;#39;（破折号）。其中， N 个 &amp;#39;-&amp;#39; 将字符串分成了 N+1 组。
给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 &amp;#39;-&amp;#39;（破折号）隔开，并且将所有的小写字母转换为大写字母。
给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。
&amp;nbsp;
示例 1：
输入：S = &amp;quot;5F3Z-2e-9-w&amp;quot;, K = 4输出：&amp;quot;5F3Z-2E9W&amp;quot;解释：字符串 S 被分成了两个部分，每部分 4 个字符；&amp;nbsp; 注意，两个额外的破折号需要删掉。示例 2：
输入：S = &amp;quot;2-5g-3-J&amp;quot;, K = 2输出：&amp;quot;2-5G-3J&amp;quot;解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。&amp;nbsp;
提示:
S 的长度可能很长，请按需分配大小。K 为正整数。S 只包含字母数字（a-z，A-Z，0-9）以及破折号&amp;#39;-&amp;#39;S 非空&amp;nbsp;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/linked-list-cycle-ii/linked-list-cycle-ii.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/linked-list-cycle-ii/linked-list-cycle-ii.java/</guid>
      <description>// @Title: 环形链表 II (Linked List Cycle II) // @Author: 1394466835@qq.com // @Date: 2021-07-04 20:04:55 // @Runtime: 0 ms // @Memory: 38.4 MB /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode detectCycle(ListNode head) { ListNode fast = head, slow = head; do { if (fast==null || fast.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/linked-list-cycle-ii/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/linked-list-cycle-ii/readme/</guid>
      <description>| English | 简体中文 |
142. 环形链表 II 题目描述 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。
说明：不允许修改给定的链表。
进阶：
你是否可以使用 O(1) 空间解决此题？ 示例 1：
输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。示例 2：
输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。示例 3：
输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/linked-list-cycle/linked-list-cycle.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/linked-list-cycle/linked-list-cycle.java/</guid>
      <description>// @Title: 环形链表 (Linked List Cycle) // @Author: 1394466835@qq.com // @Date: 2021-07-03 21:47:51 // @Runtime: 0 ms // @Memory: 39.6 MB /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { if (head == null || head.next == null) return false; ListNode fast = head, slow = head; do { if (fast == null || fast.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/linked-list-cycle/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/linked-list-cycle/readme/</guid>
      <description>| English | 简体中文 |
141. 环形链表 题目描述 给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
&amp;nbsp;
进阶：
你能用 O(1)（即，常量）内存解决此问题吗？
&amp;nbsp;
示例 1：
输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。示例&amp;nbsp;2：
输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。示例 3：
输入：head = [1], pos = -1输出：false解释：链表中没有环。&amp;nbsp;
提示：
链表中节点的数目范围是 [0, 104]-105 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/longest-substring-without-repeating-characters/longest-substring-without-repeating-characters.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/longest-substring-without-repeating-characters/longest-substring-without-repeating-characters.java/</guid>
      <description>// @Title: 无重复字符的最长子串 (Longest Substring Without Repeating Characters) // @Author: 1394466835@qq.com // @Date: 2021-10-08 15:43:24 // @Runtime: 6 ms // @Memory: 38.1 MB class Solution { public int lengthOfLongestSubstring(String s) { Set&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); int n = s.length(); int p = 0; char c; int maxLen = 0; int i = 0; while (i &amp;lt; n) { c = s.charAt(i); if (set.contains(c)) { set.remove(s.charAt(p)); p++; } else { set.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/longest-substring-without-repeating-characters/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/longest-substring-without-repeating-characters/readme/</guid>
      <description>| English | 简体中文 |
3. 无重复字符的最长子串 题目描述 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
 示例 1:
输入: s = &#34;abcabcbb&#34;输出: 3 解释: 因为无重复字符的最长子串是 &#34;abc&#34;，所以其长度为 3。示例 2:
输入: s = &#34;bbbbb&#34;输出: 1解释: 因为无重复字符的最长子串是 &#34;b&#34;，所以其长度为 1。示例 3:
输入: s = &#34;pwwkew&#34;输出: 3解释: 因为无重复字符的最长子串是 &#34;wke&#34;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&#34;pwke&#34; 是一个子序列，不是子串。示例 4:
输入: s = &#34;&#34;输出: 0 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/longest-valid-parentheses/longest-valid-parentheses.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/longest-valid-parentheses/longest-valid-parentheses.cpp/</guid>
      <description>// @Title: 最长有效括号 (Longest Valid Parentheses) // @Author: 1394466835@qq.com // @Date: 2019-04-09 19:52:32 // @Runtime: 12 ms // @Memory: 9.3 MB class Solution { public: int longestValidParentheses(string s) { vector&amp;lt;int&amp;gt; stack; int maxLength = 0; int start = -1; //用于标记第一个（前一个位置 例如()() start = -1; ))() start = 1;  for(int i=0; i&amp;lt;s.size(); ++i) { if(s[i] == &amp;#39;(&amp;#39;) { stack.push_back(i); } else if(s[i] == &amp;#39;)&amp;#39;) { if(stack.empty()) { start = i; } else { stack.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/longest-valid-parentheses/longest-valid-parentheses.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/longest-valid-parentheses/longest-valid-parentheses.java/</guid>
      <description>// @Title: 最长有效括号 (Longest Valid Parentheses) // @Author: 1394466835@qq.com // @Date: 2019-04-09 19:28:13 // @Runtime: 5 ms // @Memory: 36.5 MB class Solution { public int longestValidParentheses(String s) { char[] chars = s.toCharArray(); return Math.max(calc(chars, 0, 1, chars.length, &amp;#39;(&amp;#39;), calc(chars, chars.length -1, -1, -1, &amp;#39;)&amp;#39;)); } private static int calc(char[] chars , int i , int flag,int end, char cTem){ int max = 0, sum = 0, currLen = 0,validLen = 0; for (;i !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/longest-valid-parentheses/longest-valid-parentheses.py/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/longest-valid-parentheses/longest-valid-parentheses.py/</guid>
      <description># @Title: 最长有效括号 (Longest Valid Parentheses) # @Author: 1394466835@qq.com # @Date: 2019-04-09 19:30:01 # @Runtime: 72 ms # @Memory: 13.6 MB class Solution: def longestValidParentheses(self, s: str) -&amp;gt; int: st, b = [], [0]*len(s) for i, val in enumerate(s): if val == &amp;#39;(&amp;#39;: st.append(i) elif st: b[st.pop()], b[i] = 1, 1 c, mc = 0, 0 for i in b: if i: c += 1 else: mc = max(c, mc) c = 0 return max(c, mc) </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/longest-valid-parentheses/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/longest-valid-parentheses/readme/</guid>
      <description>| English | 简体中文 |
32. 最长有效括号 题目描述 给你一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
 示例 1：
输入：s = &#34;(()&#34;输出：2解释：最长有效括号子串是 &#34;()&#34;示例 2：
输入：s = &#34;)()())&#34;输出：4解释：最长有效括号子串是 &#34;()()&#34;示例 3：
输入：s = &#34;&#34;输出：0 提示：
0 4s[i] 为 &#39;(&#39; 或 &#39;)&#39;相关话题  栈 字符串 动态规划  相似题目  有效的括号  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/longest-word-in-dictionary-through-deleting/longest-word-in-dictionary-through-deleting.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/longest-word-in-dictionary-through-deleting/longest-word-in-dictionary-through-deleting.java/</guid>
      <description>// @Title: 通过删除字母匹配到字典里最长单词 (Longest Word in Dictionary through Deleting) // @Author: 1394466835@qq.com // @Date: 2021-05-25 09:16:20 // @Runtime: 33 ms // @Memory: 39 MB class Solution { public String findLongestWord(String s, List&amp;lt;String&amp;gt; dictionary) { dictionary.sort((a, b) -&amp;gt; a.length() != b.length() ? b.length() - a.length() : a.compareTo(b)); for (String dictWord : dictionary) { int i = 0; for (char c : s.toCharArray()) { if (i &amp;lt; dictWord.length() &amp;amp;&amp;amp; c == dictWord.charAt(i)) i++; } if (i == dictWord.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/longest-word-in-dictionary-through-deleting/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/longest-word-in-dictionary-through-deleting/readme/</guid>
      <description>| English | 简体中文 |
524. 通过删除字母匹配到字典里最长单词 题目描述 给你一个字符串 s 和一个字符串数组 dictionary ，找出并返回&amp;nbsp;dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。
如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。
&amp;nbsp;
示例 1：
输入：s = &#34;abpcplea&#34;, dictionary = [&#34;ale&#34;,&#34;apple&#34;,&#34;monkey&#34;,&#34;plea&#34;]输出：&#34;apple&#34;示例 2：
输入：s = &#34;abpcplea&#34;, dictionary = [&#34;a&#34;,&#34;b&#34;,&#34;c&#34;]输出：&#34;a&#34;&amp;nbsp;
提示：
1 &amp;lt;= s.length &amp;lt;= 10001 &amp;lt;= dictionary.length &amp;lt;= 10001 &amp;lt;= dictionary[i].length &amp;lt;= 1000s 和 dictionary[i] 仅由小写英文字母组成相关话题  数组 双指针 字符串 排序  相似题目  词典中最长的单词  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/lowest-common-ancestor-of-a-binary-search-tree/lowest-common-ancestor-of-a-binary-search-tree.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/lowest-common-ancestor-of-a-binary-search-tree/lowest-common-ancestor-of-a-binary-search-tree.java/</guid>
      <description>// @Title: 二叉搜索树的最近公共祖先 (Lowest Common Ancestor of a Binary Search Tree) // @Author: 1394466835@qq.com // @Date: 2020-10-27 18:21:03 // @Runtime: 6 ms // @Memory: 39.3 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/lowest-common-ancestor-of-a-binary-search-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/lowest-common-ancestor-of-a-binary-search-tree/readme/</guid>
      <description>| English | 简体中文 |
235. 二叉搜索树的最近公共祖先 题目描述 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：&amp;ldquo;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。&amp;rdquo;
例如，给定如下二叉搜索树:&amp;nbsp; root =&amp;nbsp;[6,2,8,0,4,7,9,null,null,3,5]
&amp;nbsp;
示例 1:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。示例 2:
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。&amp;nbsp;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/lowest-common-ancestor-of-a-binary-tree/lowest-common-ancestor-of-a-binary-tree.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/lowest-common-ancestor-of-a-binary-tree/lowest-common-ancestor-of-a-binary-tree.java/</guid>
      <description>// @Title: 二叉树的最近公共祖先 (Lowest Common Ancestor of a Binary Tree) // @Author: 1394466835@qq.com // @Date: 2020-03-11 19:23:24 // @Runtime: 9 ms // @Memory: 41.2 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/lowest-common-ancestor-of-a-binary-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/lowest-common-ancestor-of-a-binary-tree/readme/</guid>
      <description>| English | 简体中文 |
236. 二叉树的最近公共祖先 题目描述 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
 示例 1：
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。示例 2：
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。示例 3：
输入：root = [1,2], p = 1, q = 2输出：1 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/lru-cache/lru-cache.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/lru-cache/lru-cache.java/</guid>
      <description>// @Title: LRU 缓存机制 (LRU Cache) // @Author: 1394466835@qq.com // @Date: 2019-12-30 18:29:24 // @Runtime: 32 ms // @Memory: 55.8 MB class LRUCache { private HashMap&amp;lt;Integer, Node&amp;gt; map; private DoubleList cache; private int capacity; public LRUCache(int capacity) { this.capacity = capacity; map = new HashMap(); cache = new DoubleList(); } public int get(int key) { if (!map.containsKey(key)) { return -1; } int val = map.get(key).val; put(key, val); return val; } public void put(int key, int value) { Node newNode = new Node(key, value); if (map.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/lru-cache/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/lru-cache/readme/</guid>
      <description>| English | 简体中文 |
146. LRU 缓存机制 题目描述 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。实现 LRUCache 类：
LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？
 示例：
输入[&#34;LRUCache&#34;, &#34;put&#34;, &#34;put&#34;, &#34;get&#34;, &#34;put&#34;, &#34;get&#34;, &#34;put&#34;, &#34;get&#34;, &#34;get&#34;, &#34;get&#34;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/majority-element/majority-element.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/majority-element/majority-element.java/</guid>
      <description>// @Title: 多数元素 (Majority Element) // @Author: 1394466835@qq.com // @Date: 2021-07-12 21:37:31 // @Runtime: 15 ms // @Memory: 43.8 MB class Solution { public int majorityElement(int[] nums) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); int ret = 0; for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); if (map.get(num) &amp;gt; nums.length / 2) { ret = num; break; } } return ret; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/majority-element/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/majority-element/readme/</guid>
      <description>| English | 简体中文 |
169. 多数元素 题目描述 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
 示例 1：
输入：[3,2,3]输出：3示例 2：
输入：[2,2,1,1,1,2,2]输出：2 进阶：
尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。相关话题  数组 哈希表 分治 计数 排序  相似题目  求众数 II 检查一个数是否在数组中占绝大多数  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/max-area-of-island/max-area-of-island.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/max-area-of-island/max-area-of-island.java/</guid>
      <description>// @Title: 岛屿的最大面积 (Max Area of Island) // @Author: 1394466835@qq.com // @Date: 2021-09-08 20:13:10 // @Runtime: 2 ms // @Memory: 38.5 MB class Solution { public int maxAreaOfIsland(int[][] grid) { int row = grid.length; int col = grid[0].length; int maxArea = 0; for (int i = 0; i &amp;lt; row; i++) { for (int j = 0; j &amp;lt; col; j++) { maxArea = Math.max(maxArea, dfs(grid, i, j)); } } return maxArea; } private int dfs(int[][] grid, int row, int col) { if (row &amp;lt; 0 || row &amp;gt;= grid.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/max-area-of-island/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/max-area-of-island/readme/</guid>
      <description>| English | 简体中文 |
695. 岛屿的最大面积 题目描述 给你一个大小为 m x n 的二进制矩阵 grid 。
岛屿&amp;nbsp;是由一些相邻的&amp;nbsp;1&amp;nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设&amp;nbsp;grid 的四个边缘都被 0（代表水）包围着。
岛屿的面积是岛上值为 1 的单元格的数目。
计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。
&amp;nbsp;
示例 1：
输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]输出：6解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。示例 2：
输入：grid = [[0,0,0,0,0,0,0,0]]输出：0&amp;nbsp;
提示：
m == grid.lengthn == grid[i].length1 &amp;lt;= m, n &amp;lt;= 50grid[i][j] 为 0 或 1相关话题  深度优先搜索 广度优先搜索 并查集 数组 矩阵  相似题目  岛屿数量 岛屿的周长  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/maximize-sum-of-array-after-k-negations/maximize-sum-of-array-after-k-negations.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/maximize-sum-of-array-after-k-negations/maximize-sum-of-array-after-k-negations.java/</guid>
      <description>// @Title: K 次取反后最大化的数组和 (Maximize Sum Of Array After K Negations) // @Author: 1394466835@qq.com // @Date: 2019-12-29 16:50:03 // @Runtime: 2 ms // @Memory: 36.4 MB class Solution { public int largestSumAfterKNegations(int[] A, int K) { Arrays.sort(A); for (int i = 0; i&amp;lt;A.length &amp;amp;&amp;amp; K&amp;gt;0 &amp;amp;&amp;amp; A[i]&amp;lt;0; ++i, --K) { A[i] = -A[i]; } int res = 0, minimum = Integer.MAX_VALUE; for (int n : A) { res += n; if (n &amp;lt; minimum) { minimum = n; } } return res - (K % 2) * minimum * 2; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/maximize-sum-of-array-after-k-negations/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/maximize-sum-of-array-after-k-negations/readme/</guid>
      <description>| English | 简体中文 |
1005. K 次取反后最大化的数组和 题目描述 给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i&amp;nbsp;并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）
以这种方式修改数组后，返回数组可能的最大和。
&amp;nbsp;
示例 1：
输入：A = [4,2,3], K = 1输出：5解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。示例 2：
输入：A = [3,-1,0,2], K = 3输出：6解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。示例 3：
输入：A = [2,-3,-1,5,-4], K = 2输出：13解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。&amp;nbsp;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/maximum-depth-of-binary-tree/maximum-depth-of-binary-tree.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/maximum-depth-of-binary-tree/maximum-depth-of-binary-tree.cpp/</guid>
      <description>// @Title: 二叉树的最大深度 (Maximum Depth of Binary Tree) // @Author: 1394466835@qq.com // @Date: 2019-05-09 17:31:51 // @Runtime: 24 ms // @Memory: 19.1 MB /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int maxDepth(TreeNode* root) { if (root == NULL) return 0; return 1 + max(maxDepth(root-&amp;gt;left), maxDepth(root-&amp;gt;right)); } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/maximum-depth-of-binary-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/maximum-depth-of-binary-tree/readme/</guid>
      <description>| English | 简体中文 |
104. 二叉树的最大深度 题目描述 给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明:&amp;nbsp;叶子节点是指没有子节点的节点。
示例：
给定二叉树 [3,9,20,null,null,15,7]，
 3/ \9 20/ \15 7返回它的最大深度&amp;nbsp;3 。
相关话题  树 深度优先搜索 广度优先搜索 二叉树  相似题目  平衡二叉树 二叉树的最小深度 N 叉树的最大深度  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/maximum-product-of-three-numbers/maximum-product-of-three-numbers.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/maximum-product-of-three-numbers/maximum-product-of-three-numbers.cpp/</guid>
      <description>// @Title: 三个数的最大乘积 (Maximum Product of Three Numbers) // @Author: 1394466835@qq.com // @Date: 2019-04-21 16:49:46 // @Runtime: 52 ms // @Memory: 10.6 MB class Solution { public: int maximumProduct(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int size = nums.size(); //sort(nums.begin(), nums.end());  //Case One ：nums[size - 1] * nums[size - 2] * nums[size - 3] 100 110 444  //case Second：nums[size - 1] * nums[0] * nums[1] -10 -100 600  //return max(nums[size - 1] * nums[size - 2] * nums[size - 3], nums[size - 1] * nums[0] * nums[1]);  //find out the above values manually  int firstMinNum = INT_MAX, secondMinNum = INT_MAX; int firstMaxNum = INT_MIN, secondMaxNum = INT_MIN, thirdMaxNum = INT_MIN; for (auto num : nums) { if (num &amp;gt;= firstMaxNum) { thirdMaxNum = secondMaxNum; secondMaxNum = firstMaxNum; firstMaxNum = num; } else if (num &amp;gt;= secondMaxNum) { thirdMaxNum = secondMaxNum; secondMaxNum = num; } else if (num &amp;gt;= thirdMaxNum) { thirdMaxNum = num; } if (num &amp;lt;= firstMinNum) { secondMinNum = firstMinNum; firstMinNum = num; } else if (num &amp;lt;= secondMinNum) { secondMinNum = num; } } return max(firstMinNum*secondMinNum*firstMaxNum, firstMaxNum*secondMaxNum*thirdMaxNum); } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/maximum-product-of-three-numbers/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/maximum-product-of-three-numbers/readme/</guid>
      <description>| English | 简体中文 |
628. 三个数的最大乘积 题目描述 给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。
 示例 1：
输入：nums = [1,2,3]输出：6示例 2：
输入：nums = [1,2,3,4]输出：24示例 3：
输入：nums = [-1,-2,-3]输出：-6 提示：
3 4-1000 相关话题  数组 数学 排序  相似题目  乘积最大子数组  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/maximum-subarray/maximum-subarray.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/maximum-subarray/maximum-subarray.java/</guid>
      <description>// @Title: 最大子序和 (Maximum Subarray) // @Author: 1394466835@qq.com // @Date: 2021-05-08 21:39:21 // @Runtime: 1 ms // @Memory: 38.6 MB class Solution { //	分治思想 	public int maxSubArray(int[] nums) { return maxSubArray(nums, 0, nums.length); } // 求解[begin, end)里最大子序和 	public int maxSubArray(int[] nums, int begin, int end) { if (end - begin &amp;lt; 2) return nums[begin]; int mid = (begin + end) &amp;gt;&amp;gt; 1; //	三种情况，和在[begin,mid)里，在[mid,end)里，在两区别里 	int leftMax = nums[mid - 1]; int leftSum = leftMax; for (int i = mid - 2; i &amp;gt;= begin; i--) { leftSum += nums[i]; leftMax = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/maximum-subarray/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/maximum-subarray/readme/</guid>
      <description>| English | 简体中文 |
53. 最大子序和 题目描述 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
 示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。示例 2：
输入：nums = [1]输出：1示例 3：
输入：nums = [0]输出：0示例 4：
输入：nums = [-1]输出：-1示例 5：
输入：nums = [-100000]输出：-100000 提示：
1 4-105 5 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/median-of-two-sorted-arrays/median-of-two-sorted-arrays.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/median-of-two-sorted-arrays/median-of-two-sorted-arrays.java/</guid>
      <description>// @Title: 寻找两个正序数组的中位数 (Median of Two Sorted Arrays) // @Author: 1394466835@qq.com // @Date: 2019-11-26 19:02:21 // @Runtime: 3 ms // @Memory: 44.6 MB class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int x = nums1.length; int y = nums2.length; if (x &amp;gt; y) { // 防止第一个数组元素多于第二个数组  return findMedianSortedArrays(nums2,nums1); } int start = 0; int end = x; // binary search  while (start &amp;lt;= end) { int partitionX = (end - start) / 2 + start; int partitionY = (x + y + 1) / 2 - partitionX; int maxLeftX = (partitionX == 0) ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/median-of-two-sorted-arrays/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/median-of-two-sorted-arrays/readme/</guid>
      <description>| English | 简体中文 |
4. 寻找两个正序数组的中位数 题目描述 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
 示例 1：
输入：nums1 = [1,3], nums2 = [2]输出：2.00000解释：合并数组 = [1,2,3] ，中位数 2示例 2：
输入：nums1 = [1,2], nums2 = [3,4]输出：2.50000解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5示例 3：
输入：nums1 = [0,0], nums2 = [0,0]输出：0.00000示例 4：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/merge-k-sorted-lists/merge-k-sorted-lists.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/merge-k-sorted-lists/merge-k-sorted-lists.java/</guid>
      <description>// @Title: 合并K个升序链表 (Merge k Sorted Lists) // @Author: 1394466835@qq.com // @Date: 2021-07-06 18:51:16 // @Runtime: 1 ms // @Memory: 40.2 MB /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeKLists(ListNode[] lists) { if (lists == null || lists.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/merge-k-sorted-lists/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/merge-k-sorted-lists/readme/</guid>
      <description>| English | 简体中文 |
23. 合并K个升序链表 题目描述 给你一个链表数组，每个链表都已经按升序排列。
请你将所有链表合并到一个升序链表中，返回合并后的链表。
&amp;nbsp;
示例 1：
输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[1-&amp;gt;4-&amp;gt;5,1-&amp;gt;3-&amp;gt;4,2-&amp;gt;6]将它们合并到一个有序链表中得到。1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6示例 2：
输入：lists = []输出：[]示例 3：
输入：lists = [[]]输出：[]&amp;nbsp;
提示：
k == lists.length0 &amp;lt;= k &amp;lt;= 10^40 &amp;lt;= lists[i].length &amp;lt;= 500-10^4 &amp;lt;= lists[i][j] &amp;lt;= 10^4lists[i] 按 升序 排列lists[i].length 的总和不超过 10^4相关话题  链表 分治 堆（优先队列） 归并排序  相似题目  合并两个有序链表 丑数 II  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/merge-sorted-array/merge-sorted-array.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/merge-sorted-array/merge-sorted-array.java/</guid>
      <description>// @Title: 合并两个有序数组 (Merge Sorted Array) // @Author: 1394466835@qq.com // @Date: 2021-09-25 09:39:14 // @Runtime: 0 ms // @Memory: 38.3 MB class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int i = m - 1, j = n - 1; int idx = m + n - 1; while (i &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;gt;= 0) { if (nums1[i] &amp;gt; nums2[j]) { nums1[idx] = nums1[i]; i--; } else { nums1[idx] = nums2[j]; j--; } idx--; } while (j &amp;gt;= 0) { nums1[idx] = nums2[j]; j--; idx--; } } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/merge-sorted-array/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/merge-sorted-array/readme/</guid>
      <description>| English | 简体中文 |
88. 合并两个有序数组 题目描述 给你两个按 非递减顺序 排列的整数数组&amp;nbsp;nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
&amp;nbsp;
示例 1：
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。示例 2：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/merge-two-binary-trees/merge-two-binary-trees.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/merge-two-binary-trees/merge-two-binary-trees.java/</guid>
      <description>// @Title: 合并二叉树 (Merge Two Binary Trees) // @Author: 1394466835@qq.com // @Date: 2021-07-22 19:31:37 // @Runtime: 0 ms // @Memory: 38.7 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode mergeTrees(TreeNode t1, TreeNode t2) { if (t2 == null) return t1; else if (t1 == null) return t2; t1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/merge-two-binary-trees/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/merge-two-binary-trees/readme/</guid>
      <description>| English | 简体中文 |
617. 合并二叉树 题目描述 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为&amp;nbsp;NULL 的节点将直接作为新二叉树的节点。
示例&amp;nbsp;1:
输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树:3/ \4 5/ \ \ 5 4 7注意:&amp;nbsp;合并必须从两个树的根节点开始。
相关话题  树 深度优先搜索 广度优先搜索 二叉树  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/merge-two-sorted-lists/merge-two-sorted-lists.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/merge-two-sorted-lists/merge-two-sorted-lists.cpp/</guid>
      <description>// @Title: 合并两个有序链表 (Merge Two Sorted Lists) // @Author: 1394466835@qq.com // @Date: 2019-11-09 19:11:43 // @Runtime: 12 ms // @Memory: 8.8 MB /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if (l1 == NULL) { return l2; } else if (l2 == NULL) { return l1; } else if (l1-&amp;gt;val &amp;lt; l2-&amp;gt;val) { l1-&amp;gt;next = mergeTwoLists(l1-&amp;gt;next,l2); return l1; } else { l2-&amp;gt;next = mergeTwoLists(l1,l2-&amp;gt;next); return l2; } } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/merge-two-sorted-lists/merge-two-sorted-lists.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/merge-two-sorted-lists/merge-two-sorted-lists.java/</guid>
      <description>// @Title: 合并两个有序链表 (Merge Two Sorted Lists) // @Author: 1394466835@qq.com // @Date: 2021-07-25 19:34:36 // @Runtime: 0 ms // @Memory: 37.8 MB /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) return l2; if (l2 == null) return l1; if (l1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/merge-two-sorted-lists/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/merge-two-sorted-lists/readme/</guid>
      <description>| English | 简体中文 |
21. 合并两个有序链表 题目描述 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。  示例 1：
输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]示例 2：
输入：l1 = [], l2 = []输出：[]示例 3：
输入：l1 = [], l2 = [0]输出：[0] 提示：
两个链表的节点数目范围是 [0, 50]-100 l1 和 l2 均按 非递减顺序 排列相关话题  递归 链表  相似题目  合并K个升序链表 合并两个有序数组 排序链表 最短单词距离 II  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/middle-of-the-linked-list/middle-of-the-linked-list.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/middle-of-the-linked-list/middle-of-the-linked-list.java/</guid>
      <description>// @Title: 链表的中间结点 (Middle of the Linked List) // @Author: 1394466835@qq.com // @Date: 2021-10-07 11:25:11 // @Runtime: 0 ms // @Memory: 36.1 MB /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode middleNode(ListNode head) { ListNode fast = head, slow = head; while (fast !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/middle-of-the-linked-list/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/middle-of-the-linked-list/readme/</guid>
      <description>| English | 简体中文 |
876. 链表的中间结点 题目描述 给定一个头结点为 head 的非空单链表，返回链表的中间结点。
如果有两个中间结点，则返回第二个中间结点。
 示例 1：
输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.示例 2：
输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示：
给定链表的结点数介于 1 和 100 之间。相关话题  链表 双指针  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/min-cost-climbing-stairs/min-cost-climbing-stairs.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/min-cost-climbing-stairs/min-cost-climbing-stairs.java/</guid>
      <description>// @Title: 使用最小花费爬楼梯 (Min Cost Climbing Stairs) // @Author: 1394466835@qq.com // @Date: 2021-09-12 20:56:57 // @Runtime: 1 ms // @Memory: 37.9 MB class Solution { public int minCostClimbingStairs(int[] cost) { // 第i阶需要花费的最少体力  int n = cost.length; int[] dp = new int[n + 1]; dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i &amp;lt; n; i++) { dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]; } return Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/min-cost-climbing-stairs/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/min-cost-climbing-stairs/readme/</guid>
      <description>| English | 简体中文 |
746. 使用最小花费爬楼梯 题目描述 数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。
每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。
请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。
 示例 1：
输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。 示例 2：
输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出：6解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。 提示：
cost 的长度范围是 [2, 1000]。cost[i] 将会是一个整型数据，范围为 [0, 999] 。相关话题  数组 动态规划  相似题目  爬楼梯  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/min-stack/min-stack.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/min-stack/min-stack.java/</guid>
      <description>// @Title: 最小栈 (Min Stack) // @Author: 1394466835@qq.com // @Date: 2020-02-13 16:34:12 // @Runtime: 8 ms // @Memory: 52.6 MB class MinStack { private Node head; /** initialize your data structure here. */ public MinStack() { } public void push(int x) { if (head == null) { head = new Node(x,x,null); } else { head = new Node(x,Math.min(x,head.min),head); } } public void pop() { head = head.next; } public int top() { return head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/min-stack/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/min-stack/readme/</guid>
      <description>| English | 简体中文 |
155. 最小栈 题目描述 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) &amp;mdash;&amp;mdash; 将元素 x 推入栈中。pop()&amp;nbsp;&amp;mdash;&amp;mdash; 删除栈顶的元素。top()&amp;nbsp;&amp;mdash;&amp;mdash; 获取栈顶元素。getMin() &amp;mdash;&amp;mdash; 检索栈中的最小元素。&amp;nbsp;
示例:
输入：[&amp;quot;MinStack&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;getMin&amp;quot;,&amp;quot;pop&amp;quot;,&amp;quot;top&amp;quot;,&amp;quot;getMin&amp;quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&amp;gt; 返回 -3.minStack.pop();minStack.top(); --&amp;gt; 返回 0.minStack.getMin(); --&amp;gt; 返回 -2.&amp;nbsp;
提示：
pop、top 和 getMin 操作总是在 非空栈 上调用。相关话题  栈 设计  相似题目  滑动窗口最大值 最大栈  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/minimum-absolute-difference-in-bst/minimum-absolute-difference-in-bst.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-absolute-difference-in-bst/minimum-absolute-difference-in-bst.java/</guid>
      <description>// @Title: 二叉搜索树的最小绝对差 (Minimum Absolute Difference in BST) // @Author: 1394466835@qq.com // @Date: 2020-10-24 21:36:19 // @Runtime: 2 ms // @Memory: 37.8 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int getMinimumDifference(TreeNode root) { int min = Integer.MAX_VALUE; Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); TreeNode cur = root, pre = null; while (cur !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/minimum-absolute-difference-in-bst/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-absolute-difference-in-bst/readme/</guid>
      <description>| English | 简体中文 |
530. 二叉搜索树的最小绝对差 题目描述 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
&amp;nbsp;
示例：
输入：1\3/2输出：1解释：最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。&amp;nbsp;
提示：
树中至少有 2 个节点。本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同相关话题  树 深度优先搜索 广度优先搜索 二叉搜索树 二叉树  相似题目  数组中的 k-diff 数对  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/minimum-cost-to-move-chips-to-the-same-position/minimum-cost-to-move-chips-to-the-same-position.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-cost-to-move-chips-to-the-same-position/minimum-cost-to-move-chips-to-the-same-position.java/</guid>
      <description>// @Title: 玩筹码 (Minimum Cost to Move Chips to The Same Position) // @Author: 1394466835@qq.com // @Date: 2019-10-27 09:33:18 // @Runtime: 0 ms // @Memory: 34.2 MB class Solution { public int minCostToMoveChips(int[] chips) { int odd=0, even=0; for(int n : chips) { if ((n &amp;amp; 1) == 0) { even++; } else { odd++; } } return Math.min(odd,even); } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/minimum-cost-to-move-chips-to-the-same-position/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-cost-to-move-chips-to-the-same-position/readme/</guid>
      <description>| English | 简体中文 |
1217. 玩筹码 题目描述 数轴上放置了一些筹码，每个筹码的位置存在数组&amp;nbsp;chips&amp;nbsp;当中。
你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：
将第 i 个筹码向左或者右移动 2 个单位，代价为 0。将第 i 个筹码向左或者右移动 1 个单位，代价为 1。最开始的时候，同一位置上也可能放着两个或者更多的筹码。
返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。
&amp;nbsp;
示例 1：
输入：chips = [1,2,3]输出：1解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。示例 2：
输入：chips = [2,2,2,3,3]输出：2解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。&amp;nbsp;
提示：
1 &amp;lt;= chips.length &amp;lt;= 1001 &amp;lt;= chips[i] &amp;lt;= 10^9相关话题  贪心 数组 数学  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/minimum-distance-between-bst-nodes/minimum-distance-between-bst-nodes.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-distance-between-bst-nodes/minimum-distance-between-bst-nodes.java/</guid>
      <description>// @Title: 二叉搜索树节点最小距离 (Minimum Distance Between BST Nodes) // @Author: 1394466835@qq.com // @Date: 2020-10-26 08:25:56 // @Runtime: 1 ms // @Memory: 35.9 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int minDiffInBST(TreeNode root) { int min = Integer.MAX_VALUE; Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); TreeNode cur = root, pre = null; while (cur !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/minimum-distance-between-bst-nodes/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-distance-between-bst-nodes/readme/</guid>
      <description>| English | 简体中文 |
783. 二叉搜索树节点最小距离 题目描述 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。
注意：本题与 530：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/ 相同
 示例 1：
输入：root = [4,2,6,1,3]输出：1示例 2：
输入：root = [1,0,48,null,null,12,49]输出：1 提示：
树中节点数目在范围 [2, 100] 内0 5差值是一个正数，其数值等于两值之差的绝对值相关话题  树 深度优先搜索 广度优先搜索 二叉搜索树 二叉树  相似题目  二叉树的中序遍历  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/minimum-number-of-arrows-to-burst-balloons/minimum-number-of-arrows-to-burst-balloons.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-number-of-arrows-to-burst-balloons/minimum-number-of-arrows-to-burst-balloons.java/</guid>
      <description>// @Title: 用最少数量的箭引爆气球 (Minimum Number of Arrows to Burst Balloons) // @Author: 1394466835@qq.com // @Date: 2021-04-27 20:55:26 // @Runtime: 22 ms // @Memory: 47.2 MB class Solution { public int findMinArrowShots(int[][] points) { if (points.length == 0) return 0; Arrays.sort(points, Comparator.comparingInt(p -&amp;gt; p[1])); int count = 1; int prev = points[0][1]; //	[[1,6],[2,8],[7,12],[10,16]] 	for (int i = 1; i &amp;lt; points.length; i++) { if (points[i][0] &amp;gt; prev) { count++; prev = points[i][1]; } } return count; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/minimum-number-of-arrows-to-burst-balloons/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-number-of-arrows-to-burst-balloons/readme/</guid>
      <description>| English | 简体中文 |
452. 用最少数量的箭引爆气球 题目描述 在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。
一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。
给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。
示例 1：
输入：points = [[10,16],[2,8],[1,6],[7,12]]输出：2解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球示例 2：
输入：points = [[1,2],[3,4],[5,6],[7,8]]输出：4示例 3：
输入：points = [[1,2],[2,3],[3,4],[4,5]]输出：2示例 4：
输入：points = [[1,2]]输出：1示例 5：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/minimum-size-subarray-sum/minimum-size-subarray-sum.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-size-subarray-sum/minimum-size-subarray-sum.java/</guid>
      <description>// @Title: 长度最小的子数组 (Minimum Size Subarray Sum) // @Author: 1394466835@qq.com // @Date: 2021-06-04 06:58:08 // @Runtime: 2 ms // @Memory: 38.4 MB class Solution { public int minSubArrayLen(int target, int[] nums) { int result = Integer.MAX_VALUE; int sum = 0; int subLen = 0; // 窗口长度 	int i = 0; // 窗口起始位置 	for (int j = 0; j &amp;lt; nums.length; j++) { sum += nums[j]; while (sum &amp;gt;= target) { subLen = j - i + 1; result = Math.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/minimum-size-subarray-sum/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-size-subarray-sum/readme/</guid>
      <description>| English | 简体中文 |
209. 长度最小的子数组 题目描述 给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
 示例 1：
输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。示例 2：
输入：target = 4, nums = [1,4,4]输出：1示例 3：
输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 提示：
1 91 51 5 进阶：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/minimum-window-substring/minimum-window-substring.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-window-substring/minimum-window-substring.java/</guid>
      <description>// @Title: 最小覆盖子串 (Minimum Window Substring) // @Author: 1394466835@qq.com // @Date: 2021-05-18 06:40:04 // @Runtime: 5 ms // @Memory: 38.1 MB class Solution { public String minWindow(String s, String t) { int[] chars = new int[126]; boolean[] flags = new boolean[126]; t.chars().forEach(c -&amp;gt; { ++chars[c]; flags[c] = true; }); int minLen = Integer.MAX_VALUE; int minStart = 0; int start = 0, count = 0; int len = s.length(); for (int end = 0; end &amp;lt; len; end++) { if (flags[s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/minimum-window-substring/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-window-substring/readme/</guid>
      <description>| English | 简体中文 |
76. 最小覆盖子串 题目描述 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &#34;&#34; 。
 注意：
对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1：
输入：s = &#34;ADOBECODEBANC&#34;, t = &#34;ABC&#34;输出：&#34;BANC&#34;示例 2：
输入：s = &#34;a&#34;, t = &#34;a&#34;输出：&#34;a&#34;示例 3:
输入: s = &#34;a&#34;, t = &#34;aa&#34;输出: &#34;&#34;解释: t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/move-zeroes/move-zeroes.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/move-zeroes/move-zeroes.java/</guid>
      <description>// @Title: 移动零 (Move Zeroes) // @Author: 1394466835@qq.com // @Date: 2021-10-05 17:28:52 // @Runtime: 2 ms // @Memory: 39.6 MB class Solution { public void moveZeroes(int[] nums) { int idx = 0; for (int i = 0; i &amp;lt; nums.length; i++) { if (nums[i] != 0) { if (idx != i) { nums[idx] = nums[i]; nums[i] = 0; } idx++; } } } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/move-zeroes/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/move-zeroes/readme/</guid>
      <description>| English | 简体中文 |
283. 移动零 题目描述 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明:
必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。相关话题  数组 双指针  相似题目  移除元素  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/non-decreasing-array/non-decreasing-array.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/non-decreasing-array/non-decreasing-array.java/</guid>
      <description>// @Title: 非递减数列 (Non-decreasing Array) // @Author: 1394466835@qq.com // @Date: 2021-05-05 13:54:01 // @Runtime: 1 ms // @Memory: 39.7 MB class Solution { public boolean checkPossibility(int[] nums) { int count = 0; for (int i = 1; i &amp;lt; nums.length &amp;amp;&amp;amp; count &amp;lt;= 1; i++) { if (nums[i] &amp;lt; nums[i - 1]) { count++; if (i - 2 &amp;lt; 0 || nums[i - 2] &amp;lt;= nums[i]) nums[i - 1] = nums[i]; else nums[i] = nums[i - 1]; } } return count &amp;lt;= 1; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/non-decreasing-array/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/non-decreasing-array/readme/</guid>
      <description>| English | 简体中文 |
665. 非递减数列 题目描述 给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。
我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 ，总满足 nums[i] 。
 示例 1:
输入: nums = [4,2,3]输出: true解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。示例 2:
输入: nums = [4,2,1]输出: false解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 提示：
1 - 10 ^ 5 相关话题  数组  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/non-overlapping-intervals/non-overlapping-intervals.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/non-overlapping-intervals/non-overlapping-intervals.java/</guid>
      <description>// @Title: 无重叠区间 (Non-overlapping Intervals) // @Author: 1394466835@qq.com // @Date: 2021-04-26 20:47:53 // @Runtime: 5 ms // @Memory: 38.5 MB class Solution { public int eraseOverlapIntervals(int[][] intervals) { if (intervals.length == 0) return 0; //	[ [1,2], [1,3], [2,3], [3,4] ] 	Arrays.sort(intervals, Comparator.comparingInt(a -&amp;gt; a[1])); int removed = 0, prev = intervals[0][1]; for (int i = 1; i &amp;lt; intervals.length; i++) { if (intervals[i][0] &amp;lt; prev) { ++removed; } else { prev = intervals[i][1]; } } return removed; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/non-overlapping-intervals/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/non-overlapping-intervals/readme/</guid>
      <description>| English | 简体中文 |
435. 无重叠区间 题目描述 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
注意:
可以认为区间的终点总是大于它的起点。区间 [1,2] 和 [2,3] 的边界相互&amp;ldquo;接触&amp;rdquo;，但没有相互重叠。示例 1:
输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。示例 2:
输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。示例 3:
输入: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。相关话题  贪心 数组 动态规划 排序  相似题目  用最少数量的箭引爆气球  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/number-of-1-bits/number-of-1-bits.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/number-of-1-bits/number-of-1-bits.java/</guid>
      <description>// @Title: 位1的个数 (Number of 1 Bits) // @Author: 1394466835@qq.com // @Date: 2021-07-15 20:32:44 // @Runtime: 0 ms // @Memory: 34.9 MB public class Solution { // you need to treat n as an unsigned value  public int hammingWeight(int n) { int res = 0; while (n != 0x0) { res += (n &amp;amp; 0x1); n &amp;gt;&amp;gt;&amp;gt;= 1; } return res; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/number-of-1-bits/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/number-of-1-bits/readme/</guid>
      <description>| English | 简体中文 |
191. 位1的个数 题目描述 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 &#39;1&#39; 的个数（也被称为汉明重量）。
 提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1：
输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。示例 2：
输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。示例 3：
输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。 提示：
输入必须是长度为 32 的 二进制串 。 进阶：
如果多次调用这个函数，你将如何优化你的算法？相关话题  位运算  相似题目  颠倒二进制位 2 的幂 比特位计数 二进制手表 汉明距离 交替位二进制数 二进制表示中质数个计算置位  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/number-of-provinces/number-of-provinces.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/number-of-provinces/number-of-provinces.java/</guid>
      <description>// @Title: 省份数量 (Number of Provinces) // @Author: 1394466835@qq.com // @Date: 2021-09-08 20:41:57 // @Runtime: 1 ms // @Memory: 39.6 MB class Solution { public int findCircleNum(int[][] isConnected) { boolean[] visited = new boolean[isConnected.length]; int count = 0; for (int i = 0; i &amp;lt; isConnected.length; i++) { if (!visited[i]) { dfs(visited, i, isConnected); count++; } } return count; } private void dfs(boolean[] visited, int i, int[][] isConnected) { visited[i] = true; for (int j = 0; j &amp;lt; isConnected.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/number-of-provinces/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/number-of-provinces/readme/</guid>
      <description>| English | 简体中文 |
547. 省份数量 题目描述 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。
省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。
返回矩阵中 省份 的数量。
 示例 1：
输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]输出：2示例 2：
输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]输出：3 提示：
1 n == isConnected.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/number-of-segments-in-a-string/number-of-segments-in-a-string.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/number-of-segments-in-a-string/number-of-segments-in-a-string.cpp/</guid>
      <description>// @Title: 字符串中的单词数 (Number of Segments in a String) // @Author: 1394466835@qq.com // @Date: 2021-10-07 11:15:19 // @Runtime: 0 ms // @Memory: 6.1 MB class Solution { public: int countSegments(string s) { s += &amp;#39; &amp;#39;; int ans = 0; for (int i = 0; i &amp;lt; s.size() - 1; i++) { if (s[i] != &amp;#39; &amp;#39; &amp;amp;&amp;amp; s[i + 1] == &amp;#39; &amp;#39;) ans++; } return ans; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/number-of-segments-in-a-string/number-of-segments-in-a-string.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/number-of-segments-in-a-string/number-of-segments-in-a-string.java/</guid>
      <description>// @Title: 字符串中的单词数 (Number of Segments in a String) // @Author: 1394466835@qq.com // @Date: 2021-10-07 11:22:28 // @Runtime: 0 ms // @Memory: 36.1 MB class Solution { public int countSegments(String s) { int cnt = 0; for (int i = 0; i &amp;lt; s.length(); i++) { if (s.charAt(i) != &amp;#39; &amp;#39; &amp;amp;&amp;amp; (i == 0 || s.charAt(i - 1) == &amp;#39; &amp;#39;)) { cnt++; } } return cnt; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/number-of-segments-in-a-string/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/number-of-segments-in-a-string/readme/</guid>
      <description>| English | 简体中文 |
434. 字符串中的单词数 题目描述 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。
请注意，你可以假定字符串里不包括任何不可打印的字符。
示例:
输入: &amp;quot;Hello, my name is John&amp;quot;输出: 5解释: 这里的单词是指连续的不是空格的字符，所以 &amp;quot;Hello,&amp;quot; 算作 1 个单词。相关话题  字符串  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/pacific-atlantic-water-flow/pacific-atlantic-water-flow.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/pacific-atlantic-water-flow/pacific-atlantic-water-flow.java/</guid>
      <description>// @Title: 太平洋大西洋水流问题 (Pacific Atlantic Water Flow) // @Author: 1394466835@qq.com // @Date: 2021-09-19 21:58:59 // @Runtime: 5 ms // @Memory: 39.8 MB class Solution { // DFS O() 	public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; pacificAtlantic(int[][] heights) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); int m = heights.length; int n = heights[0].length; boolean[][] p = new boolean[m][n]; boolean[][] q = new boolean[m][n]; for (int x = 0; x &amp;lt; n; x++) { dfsV2(p, x, 0, 0, heights); dfsV2(q, x, m - 1, heights[m - 1][x], heights); } for (int y = 0; y &amp;lt; m; y++) { dfsV2(p, 0, y, 0, heights); dfsV2(q, n - 1, y, 0, heights); } for (int i = 0; i &amp;lt; heights.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/pacific-atlantic-water-flow/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/pacific-atlantic-water-flow/readme/</guid>
      <description>| English | 简体中文 |
417. 太平洋大西洋水流问题 题目描述 给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。&amp;ldquo;太平洋&amp;rdquo;处于大陆的左边界和上边界，而&amp;ldquo;大西洋&amp;rdquo;处于大陆的右边界和下边界。
规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。
请找出那些水流既可以流动到&amp;ldquo;太平洋&amp;rdquo;，又能流动到&amp;ldquo;大西洋&amp;rdquo;的陆地单元的坐标。
&amp;nbsp;
提示：
输出坐标的顺序不重要m 和 n 都小于150&amp;nbsp;
示例：
&amp;nbsp;
给定下面的 5x5 矩阵:太平洋 ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) *~ 3 2 3 (4) (4) *~ 2 4 (5) 3 1 *~ (6) (7) 1 4 5 *~ (5) 1 1 2 4 ** * * * * 大西洋返回:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/palindrome-number/palindrome-number.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/palindrome-number/palindrome-number.cpp/</guid>
      <description>// @Title: 回文数 (Palindrome Number) // @Author: 1394466835@qq.com // @Date: 2019-05-22 19:33:27 // @Runtime: 8 ms // @Memory: 8.1 MB class Solution { public: bool isPalindrome(int x) { // 判断 负数 末尾为0的情况  if (x &amp;lt; 0 || (x % 10 == 0 &amp;amp;&amp;amp; x != 0)) return false; // 后半部分的数 反转 例 12321 12  int reNumber = 0; while (x &amp;gt; reNumber) { // reNumber = 123; x = 12;  reNumber = reNumber * 10 + x % 10; x /= 10; } return x == reNumber || x == reNumber / 10; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/palindrome-number/palindrome-number.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/palindrome-number/palindrome-number.java/</guid>
      <description>// @Title: 回文数 (Palindrome Number) // @Author: 1394466835@qq.com // @Date: 2020-09-19 21:56:20 // @Runtime: 12 ms // @Memory: 38.4 MB class Solution { public boolean isPalindrome(int x) { if (x &amp;lt; 0) { return false; } if (x &amp;lt;= 9) { return true; } List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); while (x &amp;gt; 0) { list.add(x%10); x /= 10; } for (int i = 0, j = list.size()-1; i &amp;lt;= j; i++, j--) { if (!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/palindrome-number/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/palindrome-number/readme/</guid>
      <description>| English | 简体中文 |
9. 回文数 题目描述 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。
 示例 1：
输入：x = 121输出：true示例 2：
输入：x = -121输出：false解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3：
输入：x = 10输出：false解释：从右向左读, 为 01 。因此它不是一个回文数。示例 4：
输入：x = -101输出：false 提示：
-231 31 - 1 进阶：你能不将整数转为字符串来解决这个问题吗？</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/partition-labels/partition-labels.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/partition-labels/partition-labels.java/</guid>
      <description>// @Title: 划分字母区间 (Partition Labels) // @Author: 1394466835@qq.com // @Date: 2021-05-02 07:00:15 // @Runtime: 2 ms // @Memory: 36.9 MB class Solution { public List&amp;lt;Integer&amp;gt; partitionLabels(String S) { if (S == null || S.isEmpty()) return null; char[] chars = S.toCharArray(); // 记录字符最后出现的索引 	int[] map = new int[26]; for (int i = 0; i &amp;lt; chars.length; i++) { map[chars[i] - &amp;#39;a&amp;#39;] = i; } List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); int last = 0; int start = 0; for (int i = 0; i &amp;lt; chars.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/partition-labels/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/partition-labels/readme/</guid>
      <description>| English | 简体中文 |
763. 划分字母区间 题目描述 字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
 示例：
输入：S = &#34;ababcbacadefegdehijhklij&#34;输出：[9,7,8]解释：划分结果为 &#34;ababcbaca&#34;, &#34;defegde&#34;, &#34;hijhklij&#34;。每个字母最多出现在一个片段中。像 &#34;ababcbacadefegde&#34;, &#34;hijhklij&#34; 的划分是错误的，因为划分的片段数较少。 提示：
S的长度在[1, 500]之间。S只包含小写字母 &#39;a&#39; 到 &#39;z&#39; 。相关话题  贪心 哈希表 双指针 字符串  相似题目  合并区间  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/pascals-triangle-ii/pascals-triangle-ii.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/pascals-triangle-ii/pascals-triangle-ii.java/</guid>
      <description>// @Title: 杨辉三角 II (Pascal&amp;#39;s Triangle II) // @Author: 1394466835@qq.com // @Date: 2020-05-24 10:18:15 // @Runtime: 1 ms // @Memory: 36.6 MB class Solution { public List&amp;lt;Integer&amp;gt; getRow(int rowIndex) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); result.add(1); for (int i = 1; i &amp;lt;= rowIndex; i++) { for (int j = i - 1; j &amp;gt;= 1; j--) { result.set(j, result.get(j-1) + result.get(j)); } result.add(1); } return result; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/pascals-triangle-ii/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/pascals-triangle-ii/readme/</guid>
      <description>| English | 简体中文 |
119. 杨辉三角 II 题目描述 给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
 示例 1:
输入: rowIndex = 3输出: [1,3,3,1]示例 2:
输入: rowIndex = 0输出: [1]示例 3:
输入: rowIndex = 1输出: [1,1] 提示:
0  进阶：
你可以优化你的算法到 O(rowIndex) 空间复杂度吗？
相关话题  数组 动态规划  相似题目  杨辉三角  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/path-sum/path-sum.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/path-sum/path-sum.java/</guid>
      <description>// @Title: 路径总和 (Path Sum) // @Author: 1394466835@qq.com // @Date: 2020-03-16 09:55:43 // @Runtime: 0 ms // @Memory: 38 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean hasPathSum(TreeNode root, int sum) { if (root == null) return false; if (root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/path-sum/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/path-sum/readme/</guid>
      <description>| English | 简体中文 |
112. 路径总和 题目描述 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
叶子节点 是指没有子节点的节点。
 示例 1：
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出：true示例 2：
输入：root = [1,2,3], targetSum = 5输出：false示例 3：
输入：root = [1,2], targetSum = 0输出：false 提示：
树中节点的数目在范围 [0, 5000] 内-1000 -1000 相关话题  树 深度优先搜索 二叉树  相似题目  路径总和 II 二叉树中的最大路径和 求根节点到叶节点数字之和 路径总和 III 路径总和 IV  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/peak-index-in-a-mountain-array/peak-index-in-a-mountain-array.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/peak-index-in-a-mountain-array/peak-index-in-a-mountain-array.java/</guid>
      <description>// @Title: 山脉数组的峰顶索引 (Peak Index in a Mountain Array) // @Author: 1394466835@qq.com // @Date: 2019-12-25 19:45:27 // @Runtime: 0 ms // @Memory: 37.7 MB class Solution { public int peakIndexInMountainArray(int[] A) { int i = 0; while (A[i+1] &amp;gt; A[i]) i++; return i; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/peak-index-in-a-mountain-array/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/peak-index-in-a-mountain-array/readme/</guid>
      <description>| English | 简体中文 |
852. 山脉数组的峰顶索引 题目描述 符合下列属性的数组 arr 称为 山脉数组 ：arr.length = 3存在 i（0 ）使得：arr[0] arr[i]  arr[i+1]  ...  arr[arr.length - 1]给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] arr[i + 1]  ...  arr[arr.length - 1] 的下标 i 。
 示例 1：
输入：arr = [0,1,0]输出：1示例 2：
输入：arr = [0,2,1,0]输出：1示例 3：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/peeking-iterator/peeking-iterator.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/peeking-iterator/peeking-iterator.java/</guid>
      <description>// @Title: 顶端迭代器 (Peeking Iterator) // @Author: 1394466835@qq.com // @Date: 2021-10-05 18:40:46 // @Runtime: 4 ms // @Memory: 38.1 MB // Java Iterator interface reference: // https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html  class PeekingIterator implements Iterator&amp;lt;Integer&amp;gt; { private Iterator&amp;lt;Integer&amp;gt; it; private Integer next; public PeekingIterator(Iterator&amp;lt;Integer&amp;gt; iterator) { // initialize any member here. 	it = iterator; if (it.hasNext()) { next = it.next(); } } // Returns the next element in the iteration without advancing the iterator.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/peeking-iterator/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/peeking-iterator/readme/</guid>
      <description>| English | 简体中文 |
284. 顶端迭代器 题目描述 请你设计一个迭代器，除了支持 hasNext 和 next 操作外，还支持 peek 操作。
实现 PeekingIterator 类：
PeekingIterator(int[] nums) 使用指定整数数组 nums 初始化迭代器。int next() 返回数组中的下一个元素，并将指针移动到下个元素处。bool hasNext() 如果数组中存在下一个元素，返回 true ；否则，返回 false 。int peek() 返回数组中的下一个元素，但 不 移动指针。&amp;nbsp;
示例：
输入：[&#34;PeekingIterator&#34;, &#34;next&#34;, &#34;peek&#34;, &#34;next&#34;, &#34;next&#34;, &#34;hasNext&#34;][[[1, 2, 3]], [], [], [], [], []]输出：[null, 1, 2, 2, 3, false]解释：PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]peekingIterator.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/permutation-in-string/permutation-in-string.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/permutation-in-string/permutation-in-string.cpp/</guid>
      <description>// @Title: 字符串的排列 (Permutation in String) // @Author: 1394466835@qq.com // @Date: 2021-10-08 22:36:19 // @Runtime: 8 ms // @Memory: 7.1 MB class Solution { public: bool checkInclusion(string s1, string s2) { vector&amp;lt;int&amp;gt; v1(26, 0); for (auto c : s1) { v1[c - &amp;#39;a&amp;#39;] += 1; } int n = s1.size(); vector&amp;lt;int&amp;gt; v2(26, 0); for (int i = 0; i &amp;lt; s2.size(); i++) { v2[s2[i] - &amp;#39;a&amp;#39;] += 1; if (i &amp;gt;= n - 1) { if (v1 == v2) { return true; } v2[s2[i - n + 1] - &amp;#39;a&amp;#39;] -= 1; } } return false; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/permutation-in-string/permutation-in-string.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/permutation-in-string/permutation-in-string.java/</guid>
      <description>// @Title: 字符串的排列 (Permutation in String) // @Author: 1394466835@qq.com // @Date: 2021-07-20 17:07:13 // @Runtime: 4 ms // @Memory: 38.2 MB class Solution { public boolean checkInclusion(String s1, String s2) { int[] count = new int[256]; for (char c : s1.toCharArray()) { count[c]++; } int len = 0; int l = 0, r = 0; for (; r &amp;lt; s2.length(); r++) { if(--count[s2.charAt(r)] &amp;gt;= 0) { len++; } while (r - l + 1 &amp;gt; len) { if (++count[s2.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/permutation-in-string/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/permutation-in-string/readme/</guid>
      <description>| English | 简体中文 |
567. 字符串的排列 题目描述 给你两个字符串&amp;nbsp;s1&amp;nbsp;和&amp;nbsp;s2 ，写一个函数来判断 s2 是否包含 s1&amp;nbsp;的排列。如果是，返回 true ；否则，返回 false 。
换句话说，s1 的排列之一是 s2 的 子串 。
&amp;nbsp;
示例 1：
输入：s1 = &#34;ab&#34; s2 = &#34;eidbaooo&#34;输出：true解释：s2 包含 s1 的排列之一 (&#34;ba&#34;).示例 2：
输入：s1= &#34;ab&#34; s2 = &#34;eidboaoo&#34;输出：false&amp;nbsp;
提示：
1 &amp;lt;= s1.length, s2.length &amp;lt;= 104s1 和 s2 仅包含小写字母相关话题  哈希表 双指针 字符串 滑动窗口  相似题目  最小覆盖子串 找到字符串中所有字母异位词  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/permutations-ii/permutations-ii.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/permutations-ii/permutations-ii.java/</guid>
      <description>// @Title: 全排列 II (Permutations II) // @Author: 1394466835@qq.com // @Date: 2021-08-08 14:35:28 // @Runtime: 1 ms // @Memory: 39.1 MB class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique(int[] nums) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; cur = new ArrayList&amp;lt;&amp;gt;(); boolean[] used = new boolean[nums.length]; Arrays.sort(nums); dfs(nums, used, cur, ans); return ans; } private void dfs(int[] nums, boolean[] used, List&amp;lt;Integer&amp;gt; cur, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans) { if (cur.size() == nums.length) { ans.add(new ArrayList&amp;lt;&amp;gt;(cur)); return; } for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/permutations-ii/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/permutations-ii/readme/</guid>
      <description>| English | 简体中文 |
47. 全排列 II 题目描述 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
 示例 1：
输入：nums = [1,1,2]输出：[[1,1,2],[1,2,1],[2,1,1]]示例 2：
输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 提示：
1 -10 相关话题  数组 回溯  相似题目  下一个排列 全排列 回文排列 II 正方形数组的数目  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/permutations/permutations.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/permutations/permutations.java/</guid>
      <description>// @Title: 全排列 (Permutations) // @Author: 1394466835@qq.com // @Date: 2021-09-22 20:49:12 // @Runtime: 1 ms // @Memory: 38.6 MB class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(int[] nums) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); dfs(ans, 0, nums, new boolean[nums.length], new ArrayList&amp;lt;&amp;gt;()); return ans; } private void dfs(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans, int len, int[] nums, boolean[] used, List&amp;lt;Integer&amp;gt; path) { if (len == nums.length) { ans.add(new ArrayList&amp;lt;&amp;gt;(path)); return; } for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/permutations/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/permutations/readme/</guid>
      <description>| English | 简体中文 |
46. 全排列 题目描述 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
 示例 1：
输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]示例 2：
输入：nums = [0,1]输出：[[0,1],[1,0]]示例 3：
输入：nums = [1]输出：[[1]] 提示：
1 -10 nums 中的所有整数 互不相同相关话题  数组 回溯  相似题目  下一个排列 全排列 II 排列序列 组合  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/plus-one/plus-one.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/plus-one/plus-one.java/</guid>
      <description>// @Title: 加一 (Plus One) // @Author: 1394466835@qq.com // @Date: 2020-02-06 15:03:02 // @Runtime: 0 ms // @Memory: 34.4 MB class Solution { public int[] plusOne(int[] digits) { for (int i = digits.length - 1; i &amp;gt;= 0; i--) { digits[i]++; digits[i] %= 10; if (digits[i] != 0) return digits; } digits = new int[digits.length + 1]; digits[0] = 1; return digits; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/plus-one/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/plus-one/readme/</guid>
      <description>| English | 简体中文 |
66. 加一 题目描述 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。
 示例 1：
输入：digits = [1,2,3]输出：[1,2,4]解释：输入数组表示数字 123。示例 2：
输入：digits = [4,3,2,1]输出：[4,3,2,2]解释：输入数组表示数字 4321。示例 3：
输入：digits = [0]输出：[1] 提示：
1 0 相关话题  数组 数学  相似题目  字符串相乘 二进制求和 给单链表加一 数组形式的整数加法  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/populating-next-right-pointers-in-each-node/populating-next-right-pointers-in-each-node.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/populating-next-right-pointers-in-each-node/populating-next-right-pointers-in-each-node.java/</guid>
      <description>// @Title: 填充每个节点的下一个右侧节点指针 (Populating Next Right Pointers in Each Node) // @Author: 1394466835@qq.com // @Date: 2021-07-23 06:58:21 // @Runtime: 0 ms // @Memory: 38.7 MB /* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { Node levelStart = root; while (levelStart !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/populating-next-right-pointers-in-each-node/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/populating-next-right-pointers-in-each-node/readme/</guid>
      <description>| English | 简体中文 |
116. 填充每个节点的下一个右侧节点指针 题目描述 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node {int val;Node *left;Node *right;Node *next;}填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
 进阶：
你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例：
输入：root = [1,2,3,4,5,6,7]输出：[1,#,2,3,#,4,5,6,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。 提示：
树中节点的数量少于 4096-1000 相关话题  树 深度优先搜索 广度优先搜索 二叉树  相似题目  填充每个节点的下一个右侧节点指针 II 二叉树的右视图  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/queue-reconstruction-by-height/queue-reconstruction-by-height.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/queue-reconstruction-by-height/queue-reconstruction-by-height.cpp/</guid>
      <description>// @Title: 根据身高重建队列 (Queue Reconstruction by Height) // @Author: 1394466835@qq.com // @Date: 2019-04-01 17:39:23 // @Runtime: 60 ms // @Memory: 9.9 MB class Solution { public: vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; reconstructQueue(vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;amp; people) { /*根据身高降序排序 如何相同在 按k升序排序*/ auto rul = [](const pair&amp;lt;int,int&amp;gt;&amp;amp; p1, const pair&amp;lt;int,int&amp;gt;&amp;amp; p2) { return p1.first == p2.first ? p1.second &amp;lt; p2.second : p1.first &amp;gt; p2.first;}; sort(people.begin(), people.end(), rul); //身高矮的直接插入k的位置  vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; res; for(auto&amp;amp; p: people) { res.insert(res.begin() + p.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/queue-reconstruction-by-height/queue-reconstruction-by-height.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/queue-reconstruction-by-height/queue-reconstruction-by-height.java/</guid>
      <description>// @Title: 根据身高重建队列 (Queue Reconstruction by Height) // @Author: 1394466835@qq.com // @Date: 2021-05-03 06:54:20 // @Runtime: 9 ms // @Memory: 39.6 MB class Solution { public int[][] reconstructQueue(int[][] people) { Arrays.sort(people, (p1, p2) -&amp;gt; p1[0] == p2[0] ? p1[1] - p2[1] : p2[0] - p1[0]); List&amp;lt;int[]&amp;gt; list = new LinkedList&amp;lt;&amp;gt;(); for (int[] person : people) { list.add(person[1], person); } return list.toArray(new int[0][0]); } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/queue-reconstruction-by-height/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/queue-reconstruction-by-height/readme/</guid>
      <description>| English | 简体中文 |
406. 根据身高重建队列 题目描述 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
 示例 1：
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。示例 2：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/range-sum-of-bst/range-sum-of-bst.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/range-sum-of-bst/range-sum-of-bst.java/</guid>
      <description>// @Title: 二叉搜索树的范围和 (Range Sum of BST) // @Author: 1394466835@qq.com // @Date: 2020-10-26 09:07:57 // @Runtime: 0 ms // @Memory: 46.1 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int rangeSumBST(TreeNode root, int L, int R) { if (root == null) return 0; if (root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/range-sum-of-bst/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/range-sum-of-bst/readme/</guid>
      <description>| English | 简体中文 |
938. 二叉搜索树的范围和 题目描述 给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。
 示例 1：
输入：root = [10,5,15,3,7,null,18], low = 7, high = 15输出：32示例 2：
输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10输出：23 提示：
树中节点数目在范围 [1, 2 * 104] 内1 51 5所有 Node.val 互不相同相关话题  树 深度优先搜索 二叉搜索树 二叉树  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/recover-binary-search-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/recover-binary-search-tree/readme/</guid>
      <description>| English | 简体中文 |
99. 恢复二叉搜索树 题目描述 给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。
进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？
 示例 1：
输入：root = [1,3,null,null,2]输出：[3,1,null,null,2]解释：3 不能是 1 左孩子，因为 3  1 。交换 1 和 3 使二叉搜索树有效。示例 2：
输入：root = [3,1,4,null,null,2]输出：[2,1,4,null,null,3]解释：2 不能在 3 的右子树中，因为 2  提示：
树上节点的数目在范围 [2, 1000] 内-231 31 - 1相关话题  树 深度优先搜索 二叉搜索树 二叉树  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/recover-binary-search-tree/recover-binary-search-tree.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/recover-binary-search-tree/recover-binary-search-tree.cpp/</guid>
      <description>// @Title: 恢复二叉搜索树 (Recover Binary Search Tree) // @Author: 1394466835@qq.com // @Date: 2019-04-29 10:46:37 // @Runtime: 80 ms // @Memory: 17.2 MB /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: /// Using inOrder traverse /// Store all Nodes in an vector and find the mistaked swapped nodes /// /// Time Complexity: O(n) /// Space Complexity: O(n)  void recoverTreeHelper(TreeNode *root) { if (root == NULL) return; recoverTreeHelper(root-&amp;gt;left); if (prev) { if (prev-&amp;gt;val &amp;gt; root-&amp;gt;val){ if (n1==NULL) { n1 = prev; } n2 = root; } } prev = root; recoverTreeHelper(root-&amp;gt;right); } void recoverTree(TreeNode *root) { n1 = n2 = prev = NULL; recoverTreeHelper(root); if (n1 &amp;amp;&amp;amp; n2) { swap(n1-&amp;gt;val, n2-&amp;gt;val); } } private: TreeNode *n1, *n2, *prev; }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/recover-binary-search-tree/recover-binary-search-tree.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/recover-binary-search-tree/recover-binary-search-tree.java/</guid>
      <description>// @Title: 恢复二叉搜索树 (Recover Binary Search Tree) // @Author: 1394466835@qq.com // @Date: 2019-04-29 10:47:15 // @Runtime: 16 ms // @Memory: 38.7 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public void recoverTree(TreeNode root) { ArrayList&amp;lt;TreeNode&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); inOrder(root, list); TreeNode a = null; TreeNode b = null; for(int i = 1 ; i &amp;lt; list.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/remove-duplicates-from-sorted-array/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-duplicates-from-sorted-array/readme/</guid>
      <description>| English | 简体中文 |
26. 删除有序数组中的重复项 题目描述 给你一个有序数组 nums ，请你原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
 说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i 示例 1：
输入：nums = [1,1,2]输出：2, nums = [1,2]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/remove-duplicates-from-sorted-array/remove-duplicates-from-sorted-array.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-duplicates-from-sorted-array/remove-duplicates-from-sorted-array.cpp/</guid>
      <description>// @Title: 删除有序数组中的重复项 (Remove Duplicates from Sorted Array) // @Author: 1394466835@qq.com // @Date: 2019-06-14 09:40:06 // @Runtime: 32 ms // @Memory: 9.7 MB class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 0) return 0; int res = 1; int index = nextDifferentCharacterIndex(nums, 1); int i = 1; while (index != nums.size()) { res++; nums[i++] = nums[index]; index = nextDifferentCharacterIndex(nums, index + 1); } return res; } private: int nextDifferentCharacterIndex(const vector&amp;lt;int&amp;gt; &amp;amp; nums, int p) { for (; p &amp;lt; nums.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/remove-duplicates-from-sorted-array/remove-duplicates-from-sorted-array.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-duplicates-from-sorted-array/remove-duplicates-from-sorted-array.java/</guid>
      <description>// @Title: 删除有序数组中的重复项 (Remove Duplicates from Sorted Array) // @Author: 1394466835@qq.com // @Date: 2021-05-30 19:22:00 // @Runtime: 1 ms // @Memory: 40.3 MB class Solution { public int removeDuplicates(int[] nums) { int j = 1; for (int i = 1; i &amp;lt; nums.length; i++) { if (nums[i] != nums[i - 1]) { nums[j] = nums[i]; j++; } } return j; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/remove-duplicates-from-sorted-array/remove-duplicates-from-sorted-array.py/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-duplicates-from-sorted-array/remove-duplicates-from-sorted-array.py/</guid>
      <description># @Title: 删除有序数组中的重复项 (Remove Duplicates from Sorted Array) # @Author: 1394466835@qq.com # @Date: 2019-06-14 10:09:56 # @Runtime: 776 ms # @Memory: 13.4 MB class Solution(object): def removeDuplicates(self, nums): &amp;#34;&amp;#34;&amp;#34; :type nums: List[int] :rtype: int &amp;#34;&amp;#34;&amp;#34; i = 0 while i &amp;lt; len(nums)-1: if (nums[i] == nums[i + 1]): nums.remove(nums[i]) i -= 1 i += 1 return len(nums) </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/remove-element/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-element/readme/</guid>
      <description>| English | 简体中文 |
27. 移除元素 题目描述 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
 说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i  示例 1：
输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。示例 2：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/remove-element/remove-element.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-element/remove-element.java/</guid>
      <description>// @Title: 移除元素 (Remove Element) // @Author: 1394466835@qq.com // @Date: 2021-05-28 06:53:55 // @Runtime: 0 ms // @Memory: 37.2 MB class Solution { public int removeElement(int[] nums, int val) { int slowIndex = 0; for (int fastIndex = 0; fastIndex &amp;lt; nums.length; fastIndex++) { if (nums[fastIndex] != val) { nums[slowIndex++] = nums[fastIndex]; } } return slowIndex; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/remove-linked-list-elements/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-linked-list-elements/readme/</guid>
      <description>| English | 简体中文 |
203. 移除链表元素 题目描述 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1：
输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5]示例 2：
输入：head = [], val = 1输出：[]示例 3：
输入：head = [7,7,7,7], val = 7输出：[] 提示：
列表中的节点数目在范围 [0, 104] 内1 0 相关话题  递归 链表  相似题目  移除元素 删除链表中的节点  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/remove-linked-list-elements/remove-linked-list-elements.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-linked-list-elements/remove-linked-list-elements.java/</guid>
      <description>// @Title: 移除链表元素 (Remove Linked List Elements) // @Author: 1394466835@qq.com // @Date: 2021-06-06 21:09:22 // @Runtime: 1 ms // @Memory: 40 MB /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/remove-nth-node-from-end-of-list/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-nth-node-from-end-of-list/readme/</guid>
      <description>| English | 简体中文 |
19. 删除链表的倒数第 N 个结点 题目描述 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？
 示例 1：
输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]示例 2：
输入：head = [1], n = 1输出：[]示例 3：
输入：head = [1,2], n = 1输出：[1] 提示：
链表中结点的数目为 sz1 0 1 相关话题  链表 双指针  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/remove-nth-node-from-end-of-list/remove-nth-node-from-end-of-list.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-nth-node-from-end-of-list/remove-nth-node-from-end-of-list.java/</guid>
      <description>// @Title: 删除链表的倒数第 N 个结点 (Remove Nth Node From End of List) // @Author: 1394466835@qq.com // @Date: 2021-10-07 12:39:28 // @Runtime: 0 ms // @Memory: 36.5 MB /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(); dummy.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/remove-palindromic-subsequences/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-palindromic-subsequences/readme/</guid>
      <description>| English | 简体中文 |
1332. 删除回文子序列 题目描述 给你一个字符串&amp;nbsp;s，它仅由字母&amp;nbsp;&#39;a&#39; 和 &#39;b&#39;&amp;nbsp;组成。每一次删除操作都可以从 s 中删除一个回文 子序列。
返回删除给定字符串中所有字符（字符串为空）的最小删除次数。
「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。
「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。
&amp;nbsp;
示例 1：
输入：s = &#34;ababa&#34;输出：1解释：字符串本身就是回文序列，只需要删除一次。示例 2：
输入：s = &#34;abb&#34;输出：2解释：&#34;abb&#34; -&amp;gt; &#34;bb&#34; -&amp;gt; &#34;&#34;. 先删除回文子序列 &#34;a&#34;，然后再删除 &#34;bb&#34;。示例 3：
输入：s = &#34;baabb&#34;输出：2解释：&#34;baabb&#34; -&amp;gt; &#34;b&#34; -&amp;gt; &#34;&#34;. 先删除回文子序列 &#34;baab&#34;，然后再删除 &#34;b&#34;。&amp;nbsp;
提示：
1 &amp;lt;= s.length &amp;lt;= 1000s 仅包含字母&amp;nbsp;&#39;a&#39;&amp;nbsp; 和 &#39;b&#39;相关话题  双指针 字符串  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/remove-palindromic-subsequences/remove-palindromic-subsequences.go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-palindromic-subsequences/remove-palindromic-subsequences.go/</guid>
      <description>// @Title: 删除回文子序列 (Remove Palindromic Subsequences) // @Author: 1394466835@qq.com // @Date: 2021-06-27 19:10:10 // @Runtime: 0 ms // @Memory: 1.9 MB func removePalindromeSub(s string) int { if len(s) == 0 { return 0 } for i := 0; i &amp;lt; len(s)/2; i++ { if s[i] != s[len(s)-i-1] { return 2 } } return 1 } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/repeated-dna-sequences/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/repeated-dna-sequences/readme/</guid>
      <description>| English | 简体中文 |
187. 重复的DNA序列 题目描述 所有 DNA 都由一系列缩写为 &#39;A&#39;，&#39;C&#39;，&#39;G&#39; 和 &#39;T&#39; 的核苷酸组成，例如：&#34;ACGAATTCCG&#34;。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。
编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。
 示例 1：
输入：s = &#34;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&#34;输出：[&#34;AAAAACCCCC&#34;,&#34;CCCCCAAAAA&#34;]示例 2：
输入：s = &#34;AAAAAAAAAAAAA&#34;输出：[&#34;AAAAAAAAAA&#34;] 提示：
0 5s[i] 为 &#39;A&#39;、&#39;C&#39;、&#39;G&#39; 或 &#39;T&#39;相关话题  位运算 哈希表 字符串 滑动窗口 哈希函数 滚动哈希  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/repeated-dna-sequences/repeated-dna-sequences.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/repeated-dna-sequences/repeated-dna-sequences.java/</guid>
      <description>// @Title: 重复的DNA序列 (Repeated DNA Sequences) // @Author: 1394466835@qq.com // @Date: 2021-10-08 22:06:46 // @Runtime: 20 ms // @Memory: 46.7 MB class Solution { public List&amp;lt;String&amp;gt; findRepeatedDnaSequences(String s) { Set&amp;lt;String&amp;gt; set1 = new HashSet&amp;lt;&amp;gt;(); Set&amp;lt;String&amp;gt; set2 = new HashSet&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; s.length() - 10 + 1; i++) { String tmp = s.substring(i, i + 10); if (!set1.contains(tmp)) { set1.add(tmp); } else { set2.add(tmp); } } return new ArrayList&amp;lt;&amp;gt;(set2); } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/reverse-integer/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-integer/readme/</guid>
      <description>| English | 简体中文 |
7. 整数反转 题目描述 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1：
输入：x = 123输出：321示例 2：
输入：x = -123输出：-321示例 3：
输入：x = 120输出：21示例 4：
输入：x = 0输出：0 提示：
-231 31 - 1相关话题  数学  相似题目  字符串转换整数 (atoi) 颠倒二进制位  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/reverse-integer/reverse-integer.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-integer/reverse-integer.java/</guid>
      <description>// @Title: 整数反转 (Reverse Integer) // @Author: 1394466835@qq.com // @Date: 2021-06-11 20:03:46 // @Runtime: 1 ms // @Memory: 35.6 MB class Solution { public int reverse(int x) { int res = 0; while (x != 0) { res = res * 10 + x % 10; if (res % 10 != x % 10) { return 0; } x /= 10; } return res; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/reverse-linked-list/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-linked-list/readme/</guid>
      <description>| English | 简体中文 |
206. 反转链表 题目描述 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1：
输入：head = [1,2,3,4,5]输出：[5,4,3,2,1]示例 2：
输入：head = [1,2]输出：[2,1]示例 3：
输入：head = []输出：[] 提示：
链表中节点的数目范围是 [0, 5000]-5000  进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？
相关话题  递归 链表  相似题目  反转链表 II 上下翻转二叉树 回文链表  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/reverse-linked-list/reverse-linked-list.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-linked-list/reverse-linked-list.java/</guid>
      <description>// @Title: 反转链表 (Reverse Linked List) // @Author: 1394466835@qq.com // @Date: 2021-07-25 19:26:23 // @Runtime: 0 ms // @Memory: 38.4 MB /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode dummy = new ListNode(); ListNode prev = dummy; ListNode next = null; while (head !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/reverse-nodes-in-k-group/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-nodes-in-k-group/readme/</guid>
      <description>| English | 简体中文 |
25. K 个一组翻转链表 题目描述 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
进阶：
你可以设计一个只使用常数额外空间的算法来解决此问题吗？你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 示例 1：
输入：head = [1,2,3,4,5], k = 2输出：[2,1,4,3,5]示例 2：
输入：head = [1,2,3,4,5], k = 3输出：[3,2,1,4,5]示例 3：
输入：head = [1,2,3,4,5], k = 1输出：[1,2,3,4,5]示例 4：
输入：head = [1], k = 1输出：[1]提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/reverse-nodes-in-k-group/reverse-nodes-in-k-group.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-nodes-in-k-group/reverse-nodes-in-k-group.java/</guid>
      <description>// @Title: K 个一组翻转链表 (Reverse Nodes in k-Group) // @Author: 1394466835@qq.com // @Date: 2020-02-01 15:27:39 // @Runtime: 1 ms // @Memory: 37.9 MB /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseKGroup(ListNode head, int k) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; ListNode end = dummy; while (end.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/reverse-string/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-string/readme/</guid>
      <description>| English | 简体中文 |
344. 反转字符串 题目描述 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
&amp;nbsp;
示例 1：
输入：s = [&#34;h&#34;,&#34;e&#34;,&#34;l&#34;,&#34;l&#34;,&#34;o&#34;]输出：[&#34;o&#34;,&#34;l&#34;,&#34;l&#34;,&#34;e&#34;,&#34;h&#34;]示例 2：
输入：s = [&#34;H&#34;,&#34;a&#34;,&#34;n&#34;,&#34;n&#34;,&#34;a&#34;,&#34;h&#34;]输出：[&#34;h&#34;,&#34;a&#34;,&#34;n&#34;,&#34;n&#34;,&#34;a&#34;,&#34;H&#34;]&amp;nbsp;
提示：
1 &amp;lt;= s.length &amp;lt;= 105s[i] 都是 ASCII 码表中的可打印字符相关话题  递归 双指针 字符串  相似题目  反转字符串中的元音字母 反转字符串 II  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/reverse-string/reverse-string.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-string/reverse-string.java/</guid>
      <description>// @Title: 反转字符串 (Reverse String) // @Author: 1394466835@qq.com // @Date: 2021-10-06 16:57:02 // @Runtime: 1 ms // @Memory: 44.8 MB class Solution { public void reverseString(char[] s) { int p1 = 0, p2 = s.length - 1; char tmp; while (p1 &amp;lt; p2) { tmp = s[p1]; s[p1] = s[p2]; s[p2] = tmp; p1++; p2--; } } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/reverse-substrings-between-each-pair-of-parentheses/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-substrings-between-each-pair-of-parentheses/readme/</guid>
      <description>| English | 简体中文 |
1190. 反转每对括号间的子串 题目描述 给出一个字符串 s（仅含有小写英文字母和括号）。
请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。
注意，您的结果中 不应 包含任何括号。
 示例 1：
输入：s = &#34;(abcd)&#34;输出：&#34;dcba&#34;示例 2：
输入：s = &#34;(u(love)i)&#34;输出：&#34;iloveu&#34;解释：先反转子字符串 &#34;love&#34; ，然后反转整个字符串。示例 3：
输入：s = &#34;(ed(et(oc))el)&#34;输出：&#34;leetcode&#34;解释：先反转子字符串 &#34;oc&#34; ，接着反转 &#34;etco&#34; ，然后反转整个字符串。示例 4：
输入：s = &#34;a(bcdefghijkl(mno)p)q&#34;输出：&#34;apmnolkjihgfedcbq&#34; 提示：
0 s 中只有小写英文字母和括号题目测试用例确保所有括号都是成对出现的相关话题  栈 字符串  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/reverse-substrings-between-each-pair-of-parentheses/reverse-substrings-between-each-pair-of-parentheses.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-substrings-between-each-pair-of-parentheses/reverse-substrings-between-each-pair-of-parentheses.java/</guid>
      <description>// @Title: 反转每对括号间的子串 (Reverse Substrings Between Each Pair of Parentheses) // @Author: 1394466835@qq.com // @Date: 2020-03-22 17:17:15 // @Runtime: 1 ms // @Memory: 37.1 MB class Solution { public String reverseParentheses(String s) { Stack&amp;lt;Integer&amp;gt; st = new Stack&amp;lt;&amp;gt;(); char[] res = new char[s.length()]; int index = 0; for (char c : s.toCharArray()) { if (c == &amp;#39;(&amp;#39;) { st.push(index); } else if (c == &amp;#39;)&amp;#39;) { int j = st.pop(); reverse(res, 0 + j, index-1); } else { res[index++] = c; } } return String.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/reverse-words-in-a-string-iii/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-words-in-a-string-iii/readme/</guid>
      <description>| English | 简体中文 |
557. 反转字符串中的单词 III 题目描述 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
&amp;nbsp;
示例：
输入：&amp;quot;Let&amp;#39;s take LeetCode contest&amp;quot;输出：&amp;quot;s&amp;#39;teL ekat edoCteeL tsetnoc&amp;quot;&amp;nbsp;
提示：
在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。相关话题  双指针 字符串  相似题目  反转字符串 II  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/reverse-words-in-a-string-iii/reverse-words-in-a-string-iii.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-words-in-a-string-iii/reverse-words-in-a-string-iii.java/</guid>
      <description>// @Title: 反转字符串中的单词 III (Reverse Words in a String III) // @Author: 1394466835@qq.com // @Date: 2021-10-06 17:07:04 // @Runtime: 4 ms // @Memory: 38.8 MB class Solution { public String reverseWords(String s) { String[] words = s.split(&amp;#34; &amp;#34;); StringBuilder sb = new StringBuilder(); for (String word : words) { sb.append(reverseWord(word)) .append(&amp;#34; &amp;#34;); } sb.deleteCharAt(sb.length() - 1); return sb.toString(); } private String reverseWord(String word) { char[] chs = word.toCharArray(); int p1 = 0, p2 = chs.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/roman-to-integer/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/roman-to-integer/readme/</guid>
      <description>| English | 简体中文 |
13. 罗马数字转整数 题目描述 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/roman-to-integer/roman-to-integer.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/roman-to-integer/roman-to-integer.java/</guid>
      <description>// @Title: 罗马数字转整数 (Roman to Integer) // @Author: 1394466835@qq.com // @Date: 2021-06-11 20:36:14 // @Runtime: 7 ms // @Memory: 38.7 MB class Solution { public int romanToInt(String s) { int sum = 0; char[] chars = s.toCharArray(); for (char c : chars) { if (c == &amp;#39;I&amp;#39;) sum += 1; else if (c == &amp;#39;V&amp;#39;) sum += 5; else if (c == &amp;#39;X&amp;#39;) sum += 10; else if (c == &amp;#39;L&amp;#39;) sum += 50; else if (c == &amp;#39;C&amp;#39;) sum += 100; else if (c == &amp;#39;D&amp;#39;) sum += 500; else if (c == &amp;#39;M&amp;#39;) sum += 1000; } if (s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/rotate-array/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/rotate-array/readme/</guid>
      <description>| English | 简体中文 |
189. 旋转数组 题目描述 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
 进阶：
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ 示例 1:
输入: nums = [1,2,3,4,5,6,7], k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]示例 2:
输入：nums = [-1,-100,3,99], k = 2输出：[3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/rotate-array/rotate-array.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/rotate-array/rotate-array.cpp/</guid>
      <description>// @Title: 旋转数组 (Rotate Array) // @Author: 1394466835@qq.com // @Date: 2019-06-14 16:45:17 // @Runtime: 24 ms // @Memory: 9.3 MB class Solution { public: /// Using Reverse  /// Time Complexity: O(n)  /// Space Complexity: O(1)  void rotate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { k %= nums.size(); reverse(nums, 0, nums.size() - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.size() - 1); } private: void reverse(vector&amp;lt;int&amp;gt;&amp;amp; nums, int start, int end) { for (int i = start, j = end; i &amp;lt; j; i++, j--) { swap(nums[i], nums[j]); } } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/rotate-array/rotate-array.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/rotate-array/rotate-array.java/</guid>
      <description>// @Title: 旋转数组 (Rotate Array) // @Author: 1394466835@qq.com // @Date: 2021-10-04 19:58:07 // @Runtime: 0 ms // @Memory: 55.4 MB class Solution { public void rotate(int[] nums, int k) { k = k % nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); } // [start, end]  private void reverse(int[] nums, int start, int end) { while (start &amp;lt; end) { int tmp = nums[start]; nums[start] = nums[end]; nums[end] = tmp; start++; end--; } } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/rotate-array/rotate-array.py/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/rotate-array/rotate-array.py/</guid>
      <description># @Title: 旋转数组 (Rotate Array) # @Author: 1394466835@qq.com # @Date: 2019-06-14 16:40:46 # @Runtime: 56 ms # @Memory: 11.8 MB class Solution(object): def rotate(self, nums, k): &amp;#34;&amp;#34;&amp;#34; :type nums: List[int] :type k: int :rtype: None Do not return anything, modify nums in-place instead. &amp;#34;&amp;#34;&amp;#34; n = len(nums) k = k % n nums[:] = nums[n-k:] + nums[:n-k] </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/same-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/same-tree/readme/</guid>
      <description>| English | 简体中文 |
100. 相同的树 题目描述 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
 示例 1：
输入：p = [1,2,3], q = [1,2,3]输出：true示例 2：
输入：p = [1,2], q = [1,null,2]输出：false示例 3：
输入：p = [1,2,1], q = [1,1,2]输出：false 提示：
两棵树上的节点数目都在范围 [0, 100] 内-104 4相关话题  树 深度优先搜索 广度优先搜索 二叉树  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/same-tree/same-tree.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/same-tree/same-tree.cpp/</guid>
      <description>// @Title: 相同的树 (Same Tree) // @Author: 1394466835@qq.com // @Date: 2019-05-09 17:35:33 // @Runtime: 12 ms // @Memory: 9.5 MB /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if (!p &amp;amp;&amp;amp; !q) return true; if (!p || !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/search-in-rotated-sorted-array-ii/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/search-in-rotated-sorted-array-ii/readme/</guid>
      <description>| English | 简体中文 |
81. 搜索旋转排序数组 II 题目描述 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。
在传递给函数之前，nums 在预先未知的某个下标 k（0 ）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。
给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。
 示例 1：
输入：nums = [2,5,6,0,0,1,2], target = 0输出：true示例 2：
输入：nums = [2,5,6,0,0,1,2], target = 3输出：false 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/search-in-rotated-sorted-array-ii/search-in-rotated-sorted-array-ii.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/search-in-rotated-sorted-array-ii/search-in-rotated-sorted-array-ii.java/</guid>
      <description>// @Title: 搜索旋转排序数组 II (Search in Rotated Sorted Array II) // @Author: 1394466835@qq.com // @Date: 2021-07-30 20:57:44 // @Runtime: 0 ms // @Memory: 38 MB class Solution { public boolean search(int[] nums, int target) { int l = 0, r = nums.length - 1; int mid; while (l &amp;lt;= r) { mid = (r - l) / 2 + l; if (target == nums[mid] || target == nums[l] || target == nums[r]) { return true; } if (nums[mid] &amp;gt; nums[l]) { // 左区间有序 	if (target &amp;gt;= nums[l] &amp;amp;&amp;amp; target &amp;lt; nums[mid]) { r = mid - 1; } else { l = mid + 1; } } else if (nums[mid] &amp;lt; nums[r]) { // 右区间有序 	if (target &amp;gt; nums[mid] &amp;amp;&amp;amp; target &amp;lt;= nums[r]) { l = mid + 1; } else { r = mid - 1; } } else { // 无法判断是否有序 	l++; } } return false; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/search-insert-position/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/search-insert-position/readme/</guid>
      <description>| English | 简体中文 |
35. 搜索插入位置 题目描述 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
请必须使用时间复杂度为 O(log n) 的算法。
 示例 1:
输入: nums = [1,3,5,6], target = 5输出: 2示例 2:
输入: nums = [1,3,5,6], target = 2输出: 1示例 3:
输入: nums = [1,3,5,6], target = 7输出: 4示例 4:
输入: nums = [1,3,5,6], target = 0输出: 0示例 5:
输入: nums = [1], target = 0输出: 0 提示:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/search-insert-position/search-insert-position.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/search-insert-position/search-insert-position.java/</guid>
      <description>// @Title: 搜索插入位置 (Search Insert Position) // @Author: 1394466835@qq.com // @Date: 2021-10-03 08:05:04 // @Runtime: 0 ms // @Memory: 38.1 MB class Solution { public int searchInsert(int[] nums, int target) { int low = 0, high = nums.length; int mid; // [low, high)  while (low &amp;lt; high) { mid = (high - low) / 2 + low; if (nums[mid] == target) return mid; if (nums[mid] &amp;gt; target) { high = mid; } else { low = mid + 1; } } return low; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/second-highest-salary/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/second-highest-salary/readme/</guid>
      <description>| English | 简体中文 |
176. 第二高的薪水 题目描述 编写一个 SQL 查询，获取 Employee&amp;nbsp;表中第二高的薪水（Salary）&amp;nbsp;。
+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+例如上述&amp;nbsp;Employee&amp;nbsp;表，SQL查询应该返回&amp;nbsp;200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。
+---------------------+| SecondHighestSalary |+---------------------+| 200 |+---------------------+相关话题  数据库  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/second-highest-salary/second-highest-salary.sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/second-highest-salary/second-highest-salary.sql/</guid>
      <description>-- @Title: 第二高的薪水 (Second Highest Salary) -- @Author: 1394466835@qq.com -- @Date: 2019-08-23 13:32:22 -- @Runtime: 222 ms -- @Memory: N/A # Write your MySQL query statement below select (select distinct Salary from Employee order by Salary DESC limit 1,1) as SecondHighestSalary; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/single-number/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/single-number/readme/</guid>
      <description>| English | 简体中文 |
136. 只出现一次的数字 题目描述 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
示例 1:
输入: [2,2,1]输出: 1示例&amp;nbsp;2:
输入: [4,1,2,1,2]输出: 4相关话题  位运算 数组  相似题目  只出现一次的数字 II 只出现一次的数字 III 丢失的数字 寻找重复数 找不同  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/single-number/single-number.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/single-number/single-number.cpp/</guid>
      <description>// @Title: 只出现一次的数字 (Single Number) // @Author: 1394466835@qq.com // @Date: 2019-06-15 09:56:47 // @Runtime: 12 ms // @Memory: 9.6 MB class Solution { public: int singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int res = 0; for (int i : nums) { res ^= i; } return res; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/single-number/single-number.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/single-number/single-number.java/</guid>
      <description>// @Title: 只出现一次的数字 (Single Number) // @Author: 1394466835@qq.com // @Date: 2020-09-18 20:54:36 // @Runtime: 14 ms // @Memory: 39.2 MB class Solution { public int singleNumber(int[] nums) { HashSet&amp;lt;Integer&amp;gt; set = new HashSet(); for (int i = 0; i &amp;lt; nums.length; i++) { if (!set.contains(nums[i])) { set.add(nums[i]); } else { set.remove(nums[i]); } } return set.iterator().next(); } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sliding-window-maximum/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sliding-window-maximum/readme/</guid>
      <description>| English | 简体中文 |
239. 滑动窗口最大值 题目描述 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回滑动窗口中的最大值。
 示例 1：
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 31 [3 -1 -3] 5 3 6 7 31 3 [-1 -3 5] 3 6 7  51 3 -1 [-3 5 3] 6 7 51 3 -1 -3 [5 3 6] 7 61 3 -1 -3 5 [3 6 7] 7示例 2：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sliding-window-maximum/sliding-window-maximum.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sliding-window-maximum/sliding-window-maximum.java/</guid>
      <description>// @Title: 滑动窗口最大值 (Sliding Window Maximum) // @Author: 1394466835@qq.com // @Date: 2020-02-29 16:23:55 // @Runtime: 15 ms // @Memory: 47.8 MB class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if (nums == null || k == 0) return new int[0]; int n = nums.length; int[] r = new int[n-k+1]; int index = 0; Deque&amp;lt;Integer&amp;gt; q = new ArrayDeque&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; n; i++) { // remove numbers out of range k  while (!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sort-colors/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sort-colors/readme/</guid>
      <description>| English | 简体中文 |
75. 颜色分类 题目描述 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
 示例 1：
输入：nums = [2,0,2,1,1,0]输出：[0,0,1,1,2,2]示例 2：
输入：nums = [2,0,1]输出：[0,1,2]示例 3：
输入：nums = [0]输出：[0]示例 4：
输入：nums = [1]输出：[1] 提示：
n == nums.length1 nums[i] 为 0、1 或 2 进阶：
你可以不使用代码库中的排序函数来解决这道题吗？你能想出一个仅使用常数空间的一趟扫描算法吗？相关话题  数组 双指针 排序  相似题目  排序链表 摆动排序 摆动排序 II  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sort-colors/sort-colors.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sort-colors/sort-colors.java/</guid>
      <description>// @Title: 颜色分类 (Sort Colors) // @Author: 1394466835@qq.com // @Date: 2021-09-25 10:22:59 // @Runtime: 0 ms // @Memory: 37 MB class Solution { public void sortColors(int[] nums) { int rp = 0, wp = 0, bp = nums.length - 1; for (int i = 0; i &amp;lt;= bp; i++) { while (nums[i] == 2 &amp;amp;&amp;amp; i &amp;lt; bp) { swap(nums, i, bp); bp--; } while (nums[i] == 0 &amp;amp;&amp;amp; i &amp;gt; rp) { swap(nums, i , rp); rp++; } } } private void swap(int[] array, int i, int j) { int tmp = array[i]; array[i] = array[j]; array[j] = tmp; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sort-list/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sort-list/readme/</guid>
      <description>| English | 简体中文 |
148. 排序链表 题目描述 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。
进阶：
你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？ 示例 1：
输入：head = [4,2,1,3]输出：[1,2,3,4]示例 2：
输入：head = [-1,5,3,4,0]输出：[-1,0,3,4,5]示例 3：
输入：head = []输出：[] 提示：
链表中节点的数目在范围 [0, 5 * 104] 内-105 5相关话题  链表 双指针 分治 排序 归并排序  相似题目  合并两个有序链表 颜色分类 对链表进行插入排序  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sort-list/sort-list.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sort-list/sort-list.java/</guid>
      <description>// @Title: 排序链表 (Sort List) // @Author: 1394466835@qq.com // @Date: 2021-07-07 19:33:30 // @Runtime: 8 ms // @Memory: 43.1 MB /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode sortList(ListNode head) { if (head == null || head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sorted-matrix-search-lcci/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sorted-matrix-search-lcci/readme/</guid>
      <description>| English | 简体中文 |
面试题 10.09. 排序矩阵查找 题目描述 给定M&amp;times;N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。
示例:
现有矩阵 matrix 如下：
[[1, 4, 7, 11, 15],[2, 5, 8, 12, 19],[3, 6, 9, 16, 22],[10, 13, 14, 17, 24],[18, 21, 23, 26, 30]]给定 target&amp;nbsp;=&amp;nbsp;5，返回&amp;nbsp;true。
给定&amp;nbsp;target&amp;nbsp;=&amp;nbsp;20，返回&amp;nbsp;false。
相关话题  数组 二分查找 分治 矩阵  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sorted-matrix-search-lcci/sorted-matrix-search-lcci.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sorted-matrix-search-lcci/sorted-matrix-search-lcci.java/</guid>
      <description>// @Title: 排序矩阵查找 (Sorted Matrix Search LCCI) // @Author: 1394466835@qq.com // @Date: 2020-03-29 19:47:24 // @Runtime: 6 ms // @Memory: 40.8 MB class Solution { public boolean searchMatrix(int[][] matrix, int target) { if (matrix == null || matrix.length == 0) { return false; } int row = 0, col = matrix[0].length-1; while (row &amp;lt; matrix.length &amp;amp;&amp;amp; col &amp;gt;= 0) { if (matrix[row][col] &amp;gt; target) { col--; } else if (matrix[row][col] &amp;lt; target) { row++; } else { return true; } } return false; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sqrtx/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sqrtx/readme/</guid>
      <description>| English | 简体中文 |
69. Sqrt(x) 题目描述 给你一个非负整数 x ，计算并返回&amp;nbsp;x&amp;nbsp;的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
&amp;nbsp;
示例 1：
输入：x = 4输出：2示例 2：
输入：x = 8输出：2解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。&amp;nbsp;
提示：
0 &amp;lt;= x &amp;lt;= 231 - 1相关话题  数学 二分查找  相似题目  Pow(x, n) 有效的完全平方数  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sqrtx/sqrtx.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sqrtx/sqrtx.java/</guid>
      <description>// @Title: Sqrt(x) (Sqrt(x)) // @Author: 1394466835@qq.com // @Date: 2021-05-28 07:05:59 // @Runtime: 2 ms // @Memory: 35.8 MB class Solution { public int mySqrt(int x) { int left = 1, right = x; while (left &amp;lt;= right) { int mid = left + (right - left)/2; if (mid == x / mid) { return mid; } else if (mid &amp;lt; x / mid) { left = mid + 1; } else { right = mid - 1; } } return right; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/squares-of-a-sorted-array/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/squares-of-a-sorted-array/readme/</guid>
      <description>| English | 简体中文 |
977. 有序数组的平方 题目描述 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
 示例 1：
输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]示例 2：
输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 提示：
1 104-104 4nums 已按 非递减顺序 排序 进阶：
请你设计时间复杂度为 O(n) 的算法解决本问题相关话题  数组 双指针 排序  相似题目  合并两个有序数组 有序转化数组  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/squares-of-a-sorted-array/squares-of-a-sorted-array.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/squares-of-a-sorted-array/squares-of-a-sorted-array.java/</guid>
      <description>// @Title: 有序数组的平方 (Squares of a Sorted Array) // @Author: 1394466835@qq.com // @Date: 2021-10-04 19:01:13 // @Runtime: 1 ms // @Memory: 40.2 MB class Solution { public int[] sortedSquares(int[] nums) { int p1 = 0, p2 = nums.length - 1; int idx = p2; int[] ans = new int[nums.length]; while (p1 &amp;lt;= p2) { if (nums[p1] * nums[p1] &amp;gt;= nums[p2] * nums[p2]) { ans[idx] = nums[p1] * nums[p1]; p1++; } else { ans[idx] = nums[p2] * nums[p2]; p2--; } idx--; } return ans; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sub-sort-lcci/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sub-sort-lcci/readme/</guid>
      <description>| English | 简体中文 |
面试题 16.16. 部分排序 题目描述 给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。
示例：
输入： [1,2,4,7,10,11,7,12,6,7,16,18,19]输出： [3,9]提示：
0 相关话题  栈 贪心 数组 双指针 排序 单调栈  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sub-sort-lcci/sub-sort-lcci.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sub-sort-lcci/sub-sort-lcci.java/</guid>
      <description>// @Title: 部分排序 (Sub Sort LCCI) // @Author: 1394466835@qq.com // @Date: 2021-09-27 17:15:30 // @Runtime: 1 ms // @Memory: 61.7 MB class Solution { public int[] subSort(int[] array) { if (array == null || array.length &amp;lt; 1) { return new int[]{-1, -1}; } int max = array[0]; int right = -1; for (int i = 1; i &amp;lt; array.length; i++) { if (array[i] &amp;gt;= max) { max = array[i]; } else { right = i; } } if (right == -1) return new int[]{-1, -1}; int min = array[array.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/subsets-ii/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/subsets-ii/readme/</guid>
      <description>| English | 简体中文 |
90. 子集 II 题目描述 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。
 示例 1：
输入：nums = [1,2,2]输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]示例 2：
输入：nums = [0]输出：[[],[0]] 提示：
1 -10 相关话题  位运算 数组 回溯  相似题目  子集  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/subsets-ii/subsets-ii.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/subsets-ii/subsets-ii.java/</guid>
      <description>// @Title: 子集 II (Subsets II) // @Author: 1394466835@qq.com // @Date: 2021-08-06 21:51:23 // @Runtime: 1 ms // @Memory: 38.7 MB class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsWithDup(int[] nums) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; cur = new ArrayList&amp;lt;&amp;gt;(); Arrays.sort(nums); dfs(nums, 0, cur, ans); return ans; } private void dfs(int[] nums, int start, List&amp;lt;Integer&amp;gt; cur, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans) { ans.add(new ArrayList&amp;lt;&amp;gt;(cur)); for (int i = start; i &amp;lt; nums.length; i++) { if (i &amp;gt; start &amp;amp;&amp;amp; nums[i-1] == nums[i]) continue; cur.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/subsets/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/subsets/readme/</guid>
      <description>| English | 简体中文 |
78. 子集 题目描述 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。
 示例 1：
输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]示例 2：
输入：nums = [0]输出：[[],[0]] 提示：
1 -10 nums 中的所有元素 互不相同相关话题  位运算 数组 回溯  相似题目  子集 II 列举单词的全部缩写 字母大小写全排列  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/subsets/subsets.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/subsets/subsets.java/</guid>
      <description>// @Title: 子集 (Subsets) // @Author: 1394466835@qq.com // @Date: 2021-08-15 19:43:31 // @Runtime: 0 ms // @Memory: 38.3 MB class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; cur = new ArrayList&amp;lt;&amp;gt;(); Arrays.sort(nums); dfs(nums, 0, cur, ans); return ans; } private void dfs(int[] nums, int start, List&amp;lt;Integer&amp;gt; cur, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans) { ans.add(new ArrayList&amp;lt;&amp;gt;(cur)); for (int i = start; i &amp;lt; nums.length; i++) { cur.add(nums[i]); dfs(nums, i + 1, cur, ans); cur.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sum-of-left-leaves/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sum-of-left-leaves/readme/</guid>
      <description>| English | 简体中文 |
404. 左叶子之和 题目描述 计算给定二叉树的所有左叶子之和。
示例：
3/ \9 20/ \15 7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24&amp;nbsp;
相关话题  树 深度优先搜索 广度优先搜索 二叉树  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sum-of-left-leaves/sum-of-left-leaves.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sum-of-left-leaves/sum-of-left-leaves.cpp/</guid>
      <description>// @Title: 左叶子之和 (Sum of Left Leaves) // @Author: 1394466835@qq.com // @Date: 2019-09-03 09:36:49 // @Runtime: 4 ms // @Memory: 13.2 MB /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int sum; int sumOfLeftLeaves(TreeNode* root) { if (root == NULL) { return 0; } if (root-&amp;gt;left !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sum-of-left-leaves/sum-of-left-leaves.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sum-of-left-leaves/sum-of-left-leaves.java/</guid>
      <description>// @Title: 左叶子之和 (Sum of Left Leaves) // @Author: 1394466835@qq.com // @Date: 2019-09-03 09:41:08 // @Runtime: 1 ms // @Memory: 34.7 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { private int sum = 0; public int sumOfLeftLeaves(TreeNode root) { if (root == null) { return 0; } if (root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sum-of-left-leaves/sum-of-left-leaves.py/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sum-of-left-leaves/sum-of-left-leaves.py/</guid>
      <description># @Title: 左叶子之和 (Sum of Left Leaves) # @Author: 1394466835@qq.com # @Date: 2019-09-03 09:47:38 # @Runtime: 40 ms # @Memory: 12.2 MB # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def sumOfLeftLeaves(self, root): &amp;#34;&amp;#34;&amp;#34; :type root: TreeNode :rtype: int &amp;#34;&amp;#34;&amp;#34; if not root: return 0; if root.left and not root.left.left and not root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sum-of-square-numbers/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sum-of-square-numbers/readme/</guid>
      <description>| English | 简体中文 |
633. 平方数之和 题目描述 给定一个非负整数&amp;nbsp;c&amp;nbsp;，你要判断是否存在两个整数 a 和 b，使得&amp;nbsp;a2 + b2 = c 。
&amp;nbsp;
示例 1：
输入：c = 5输出：true解释：1 * 1 + 2 * 2 = 5示例 2：
输入：c = 3输出：false示例 3：
输入：c = 4输出：true示例 4：
输入：c = 2输出：true示例 5：
输入：c = 1输出：true&amp;nbsp;
提示：
0 &amp;lt;= c &amp;lt;= 231 - 1相关话题  数学 双指针 二分查找  相似题目  有效的完全平方数  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/sum-of-square-numbers/sum-of-square-numbers.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sum-of-square-numbers/sum-of-square-numbers.java/</guid>
      <description>// @Title: 平方数之和 (Sum of Square Numbers) // @Author: 1394466835@qq.com // @Date: 2021-05-21 13:48:21 // @Runtime: 2 ms // @Memory: 35.4 MB class Solution { public boolean judgeSquareSum(int c) { int i = 0, j = (int) Math.sqrt(c); while (i &amp;lt;= j) { int cur = i * i + j * j; if (cur &amp;lt; c) { i++; } else if (cur &amp;gt; c) { j--; } else { return true; } } return false; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/swap-nodes-in-pairs/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/swap-nodes-in-pairs/readme/</guid>
      <description>| English | 简体中文 |
24. 两两交换链表中的节点 题目描述 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
 示例 1：
输入：head = [1,2,3,4]输出：[2,1,4,3]示例 2：
输入：head = []输出：[]示例 3：
输入：head = [1]输出：[1] 提示：
链表中节点的数目在范围 [0, 100] 内0  进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）
相关话题  递归 链表  相似题目  K 个一组翻转链表  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/swap-nodes-in-pairs/swap-nodes-in-pairs.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/swap-nodes-in-pairs/swap-nodes-in-pairs.java/</guid>
      <description>// @Title: 两两交换链表中的节点 (Swap Nodes in Pairs) // @Author: 1394466835@qq.com // @Date: 2021-07-13 15:32:22 // @Runtime: 0 ms // @Memory: 35.9 MB /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/swap-salary/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/swap-salary/readme/</guid>
      <description>| English | 简体中文 |
627. 变更性别 题目描述 Salary 表：
+-------------+----------+| Column Name | Type |+-------------+----------+| id | int || name | varchar || sex | ENUM || salary | int |+-------------+----------+id 是这个表的主键。sex 这一列的值是 ENUM 类型，只能从 (&#39;m&#39;, &#39;f&#39;) 中取。本表包含公司雇员的信息。&amp;nbsp;
请你编写一个 SQL 查询来交换所有的 &#39;f&#39; 和 &#39;m&#39; （即，将所有 &#39;f&#39; 变为 &#39;m&#39; ，反之亦然），仅使用 单个 update 语句 ，且不产生中间临时表。
注意，你必须仅使用一条 update 语句，且 不能 使用 select 语句。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/swap-salary/swap-salary.sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/swap-salary/swap-salary.sql/</guid>
      <description>-- @Title: 变更性别 (Swap Salary) -- @Author: 1394466835@qq.com -- @Date: 2019-05-24 16:43:55 -- @Runtime: 296 ms -- @Memory: N/A # Write your MySQL query statement below update salary set sex = if(sex = &amp;#39;m&amp;#39;,&amp;#39;f&amp;#39;,&amp;#39;m&amp;#39;) </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/swapping-nodes-in-a-linked-list/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/swapping-nodes-in-a-linked-list/readme/</guid>
      <description>| English | 简体中文 |
1721. 交换链表中的节点 题目描述 给你链表的头节点 head 和一个整数 k 。
交换 链表正数第 k 个节点和倒数第 k 个节点的值后，返回链表的头节点（链表 从 1 开始索引）。
 示例 1：
输入：head = [1,2,3,4,5], k = 2输出：[1,4,3,2,5]示例 2：
输入：head = [7,9,6,6,7,8,3,0,9,5], k = 5输出：[7,9,6,6,8,7,3,0,9,5]示例 3：
输入：head = [1], k = 1输出：[1]示例 4：
输入：head = [1,2], k = 1输出：[2,1]示例 5：
输入：head = [1,2,3], k = 2输出：[1,2,3] 提示：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/swapping-nodes-in-a-linked-list/swapping-nodes-in-a-linked-list.go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/swapping-nodes-in-a-linked-list/swapping-nodes-in-a-linked-list.go/</guid>
      <description>// @Title: 交换链表中的节点 (Swapping Nodes in a Linked List) // @Author: 1394466835@qq.com // @Date: 2021-06-27 19:23:26 // @Runtime: 196 ms // @Memory: 8.9 MB /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func swapNodes(head *ListNode, k int) *ListNode { var p1, p2 *ListNode count := 1 for node := head; node != nil; node = node.Next { if count == k { p1 = node } count++ } length := count count = 1 for node := head; node !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/symmetric-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/symmetric-tree/readme/</guid>
      <description>| English | 简体中文 |
101. 对称二叉树 题目描述 给定一个二叉树，检查它是否是镜像对称的。
&amp;nbsp;
例如，二叉树&amp;nbsp;[1,2,2,3,4,4,3] 是对称的。
 1/ \2 2/ \ / \3 4 4 3&amp;nbsp;
但是下面这个&amp;nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:
 1/ \2 2\ \3 3&amp;nbsp;
进阶：
你可以运用递归和迭代两种方法解决这个问题吗？
相关话题  树 深度优先搜索 广度优先搜索 二叉树  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/symmetric-tree/symmetric-tree.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/symmetric-tree/symmetric-tree.cpp/</guid>
      <description>// @Title: 对称二叉树 (Symmetric Tree) // @Author: 1394466835@qq.com // @Date: 2019-04-28 19:12:13 // @Runtime: 16 ms // @Memory: 14.6 MB /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { return isSymmetric(root, root); } bool isSymmetric(TreeNode* l, TreeNode* r) { if (l==NULL &amp;amp;&amp;amp; r==NULL) { return true; } if (l==NULL || r==NULL) return false; if (l-&amp;gt;val == r-&amp;gt;val) return isSymmetric(l-&amp;gt;left, r-&amp;gt;right)&amp;amp;&amp;amp;isSymmetric(l-&amp;gt;right, r-&amp;gt;left); return false; } }; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/third-maximum-number/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/third-maximum-number/readme/</guid>
      <description>| English | 简体中文 |
414. 第三大的数 题目描述 给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。
 示例 1：
输入：[3, 2, 1]输出：1解释：第三大的数是 1 。示例 2：
输入：[1, 2]输出：2解释：第三大的数不存在, 所以返回最大的数 2 。示例 3：
输入：[2, 2, 3, 1]输出：1解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。 提示：
1 4-231 31 - 1 进阶：你能设计一个时间复杂度 O(n) 的解决方案吗？
相关话题  数组 排序  相似题目  数组中的第K个最大元素  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/third-maximum-number/third-maximum-number.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/third-maximum-number/third-maximum-number.java/</guid>
      <description>// @Title: 第三大的数 (Third Maximum Number) // @Author: 1394466835@qq.com // @Date: 2021-10-06 16:48:50 // @Runtime: 4 ms // @Memory: 38.2 MB class Solution { public int thirdMax(int[] nums) { Integer max1 = null; Integer max2 = null; Integer max3 = null; for (Integer num : nums) { if (num.equals(max1) || num.equals(max2) || num.equals(max2)) continue; if (max1 == null || num &amp;gt; max1) { max3 = max2; max2 = max1; max1 = num; } else if (max2 == null || num &amp;gt; max2) { max3 = max2; max2 = num; } else if (max3 == null || num &amp;gt; max3) { max3 = num; } } return max3 == null ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/trim-a-binary-search-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/trim-a-binary-search-tree/readme/</guid>
      <description>| English | 简体中文 |
669. 修剪二叉搜索树 题目描述 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。
所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。
 示例 1：
输入：root = [1,0,2], low = 1, high = 2输出：[1,null,2]示例 2：
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3输出：[3,2,null,1]示例 3：
输入：root = [1], low = 1, high = 2输出：[1]示例 4：
输入：root = [1,null,2], low = 1, high = 3输出：[1,null,2]示例 5：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/trim-a-binary-search-tree/trim-a-binary-search-tree.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/trim-a-binary-search-tree/trim-a-binary-search-tree.java/</guid>
      <description>// @Title: 修剪二叉搜索树 (Trim a Binary Search Tree) // @Author: 1394466835@qq.com // @Date: 2020-03-14 18:37:48 // @Runtime: 0 ms // @Memory: 40.3 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode trimBST(TreeNode root, int L, int R) { if (root == null) return null; if (root.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/two-sum-ii-input-array-is-sorted/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/two-sum-ii-input-array-is-sorted/readme/</guid>
      <description>| English | 简体中文 |
167. 两数之和 II - 输入有序数组 题目描述 给定一个已按照 非递减顺序排列&amp;nbsp; 的整数数组&amp;nbsp;numbers ，请你从数组中找出两个数满足相加之和等于目标数&amp;nbsp;target 。
函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &amp;lt;= answer[0] &amp;lt; answer[1] &amp;lt;= numbers.length 。
你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。
&amp;nbsp;示例 1：
输入：numbers = [2,7,11,15], target = 9输出：[1,2]解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。示例 2：
输入：numbers = [2,3,4], target = 6输出：[1,3]示例 3：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/two-sum-ii-input-array-is-sorted/two-sum-ii-input-array-is-sorted.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/two-sum-ii-input-array-is-sorted/two-sum-ii-input-array-is-sorted.java/</guid>
      <description>// @Title: 两数之和 II - 输入有序数组 (Two Sum II - Input array is sorted) // @Author: 1394466835@qq.com // @Date: 2021-10-05 18:21:26 // @Runtime: 0 ms // @Memory: 38.4 MB class Solution { public int[] twoSum(int[] numbers, int target) { int low = 0, high = numbers.length - 1; while (low &amp;lt; high) { int value = numbers[low] + numbers[high]; if (value == target) { return new int[]{low + 1, high + 1}; } else if (value &amp;lt; target) { low++; } else { // &amp;gt;  high--; } } return null; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/two-sum/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/two-sum/readme/</guid>
      <description>| English | 简体中文 |
1. 两数之和 题目描述 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
 示例 1：
输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。示例 2：
输入：nums = [3,2,4], target = 6输出：[1,2]示例 3：
输入：nums = [3,3], target = 6输出：[0,1] 提示：
2 4-109 9-109 9只会存在一个有效答案进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/two-sum/two-sum.c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/two-sum/two-sum.c/</guid>
      <description>// @Title: 两数之和 (Two Sum) // @Author: 1394466835@qq.com // @Date: 2019-01-20 19:54:09 // @Runtime: 68 ms // @Memory: 1.1 MB /** * Note: The returned array must be malloced, assume caller calls free(). */ int* twoSum(int* nums, int numsSize, int target) { for(int i = 0; i &amp;lt; numsSize - 1; ++i) { for(int j = i + 1; j &amp;lt; numsSize; ++j) { if (nums[i] + nums[j] == target) { static int temp[2] = {0, 0}; temp[0] = i; temp[1] = j; return temp; } } } return 0; } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/two-sum/two-sum.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/two-sum/two-sum.java/</guid>
      <description>// @Title: 两数之和 (Two Sum) // @Author: 1394466835@qq.com // @Date: 2021-10-07 17:02:35 // @Runtime: 2 ms // @Memory: 38.6 MB class Solution { public int[] twoSum(int[] nums, int target) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int another = target - nums[i]; if (map.containsKey(another)) { return new int[]{map.get(another), i}; } map.put(nums[i], i); } return null; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/unique-binary-search-trees-ii/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/unique-binary-search-trees-ii/readme/</guid>
      <description>| English | 简体中文 |
95. 不同的二叉搜索树 II 题目描述 给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。
 示例 1：
输入：n = 3输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]示例 2：
输入：n = 1输出：[[1]] 提示：
1 相关话题  树 二叉搜索树 动态规划 回溯 二叉树  相似题目  不同的二叉搜索树 为运算表达式设计优先级  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/unique-binary-search-trees-ii/unique-binary-search-trees-ii.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/unique-binary-search-trees-ii/unique-binary-search-trees-ii.java/</guid>
      <description>// @Title: 不同的二叉搜索树 II (Unique Binary Search Trees II) // @Author: 1394466835@qq.com // @Date: 2019-10-05 16:54:31 // @Runtime: 2 ms // @Memory: 36.8 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public List&amp;lt;TreeNode&amp;gt; generateTrees(int n) { List&amp;lt;TreeNode&amp;gt; list = new ArrayList&amp;lt;TreeNode&amp;gt;(); if (n == 0) return list; return generateBST(1, n); } public List&amp;lt;TreeNode&amp;gt; generateBST(int start, int end) { List&amp;lt;TreeNode&amp;gt; list = new ArrayList&amp;lt;TreeNode&amp;gt;(); if (start &amp;gt; end) { list.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/univalued-binary-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/univalued-binary-tree/readme/</guid>
      <description>| English | 简体中文 |
965. 单值二叉树 题目描述 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。
只有给定的树是单值二叉树时，才返回&amp;nbsp;true；否则返回 false。
&amp;nbsp;
示例 1：
输入：[1,1,1,1,1,null,1]输出：true示例 2：
输入：[2,2,2,5,2]输出：false&amp;nbsp;
提示：
给定树的节点数范围是&amp;nbsp;[1, 100]。每个节点的值都是整数，范围为&amp;nbsp;[0, 99]&amp;nbsp;。相关话题  树 深度优先搜索 广度优先搜索 二叉树  相似题目 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/univalued-binary-tree/univalued-binary-tree.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/univalued-binary-tree/univalued-binary-tree.java/</guid>
      <description>// @Title: 单值二叉树 (Univalued Binary Tree) // @Author: 1394466835@qq.com // @Date: 2020-03-14 18:17:34 // @Runtime: 0 ms // @Memory: 36.6 MB /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { private int v; public boolean isUnivalTree(TreeNode root) { v = root.val; return helper(root); } private boolean helper(TreeNode node) { if (node == null) return true; else if (node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/valid-palindrome-ii/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-palindrome-ii/readme/</guid>
      <description>| English | 简体中文 |
680. 验证回文字符串 Ⅱ 题目描述 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
 示例 1:
输入: s = &#34;aba&#34;输出: true示例 2:
输入: s = &#34;abca&#34;输出: true解释: 你可以删除c字符。示例 3:
输入: s = &#34;abc&#34;输出: false 提示:
1 5s 由小写英文字母组成相关话题  贪心 双指针 字符串  相似题目  验证回文串  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/valid-palindrome-ii/valid-palindrome-ii.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-palindrome-ii/valid-palindrome-ii.java/</guid>
      <description>// @Title: 验证回文字符串 Ⅱ (Valid Palindrome II) // @Author: 1394466835@qq.com // @Date: 2021-05-22 15:44:27 // @Runtime: 10 ms // @Memory: 38.6 MB class Solution { public boolean validPalindrome(String s) { int i = -1, j = s.length(); while (++i &amp;lt; --j) { if (s.charAt(i) != s.charAt(j)) { return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j); } } return true; } private boolean isPalindrome(String s, int l, int r) { while (l &amp;lt; r) { if (s.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/valid-palindrome/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-palindrome/readme/</guid>
      <description>| English | 简体中文 |
125. 验证回文串 题目描述 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
 示例 1:
输入: &#34;A man, a plan, a canal: Panama&#34;输出: true解释：&#34;amanaplanacanalpanama&#34; 是回文串示例 2:
输入: &#34;race a car&#34;输出: false解释：&#34;raceacar&#34; 不是回文串 提示：
1 5字符串 s 由 ASCII 字符组成相关话题  双指针 字符串  相似题目  回文链表 验证回文字符串 Ⅱ  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/valid-palindrome/valid-palindrome.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-palindrome/valid-palindrome.java/</guid>
      <description>// @Title: 验证回文串 (Valid Palindrome) // @Author: 1394466835@qq.com // @Date: 2021-01-18 08:42:31 // @Runtime: 3 ms // @Memory: 38.3 MB class Solution { public boolean isPalindrome(String s) { final char[] chars = s.toCharArray(); for (int i = 0, j = chars.length - 1; i &amp;lt; j; ) { if (!Character.isLetterOrDigit(chars[i])) { i++; } else if (!Character.isLetterOrDigit(chars[j])) { j--; } else if (Character.toLowerCase(chars[i++]) != Character.toLowerCase(chars[j--])) { return false; } } return true; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/valid-parentheses/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-parentheses/readme/</guid>
      <description>| English | 简体中文 |
20. 有效的括号 题目描述 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。 示例 1：
输入：s = &#34;()&#34;输出：true示例 2：
输入：s = &#34;()[]{}&#34;输出：true示例 3：
输入：s = &#34;(]&#34;输出：false示例 4：
输入：s = &#34;([)]&#34;输出：false示例 5：
输入：s = &#34;{[]}&#34;输出：true 提示：
1 4s 仅由括号 &#39;()[]{}&#39; 组成相关话题  栈 字符串  相似题目  括号生成 最长有效括号 删除无效的括号 检查替换后的词是否有效  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/valid-parentheses/valid-parentheses.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-parentheses/valid-parentheses.cpp/</guid>
      <description>// @Title: 有效的括号 (Valid Parentheses) // @Author: 1394466835@qq.com // @Date: 2019-05-03 20:33:24 // @Runtime: 8 ms // @Memory: 8.5 MB class Solution { public: bool isValid(string s) { stack&amp;lt;char&amp;gt; stack; for (int i = 0; i &amp;lt; s.size(); i++) { if (s[i] == &amp;#39;(&amp;#39; || s[i] == &amp;#39;[&amp;#39; || s[i] == &amp;#39;{&amp;#39;) stack.push(s[i]); else { if (stack.size() == 0) return false; char c = stack.top(); stack.pop(); char match; if (s[i] == &amp;#39;)&amp;#39;) match = &amp;#39;(&amp;#39;; else if (s[i] == &amp;#39;]&amp;#39;) match = &amp;#39;[&amp;#39;; else { assert(s[i] == &amp;#39;}&amp;#39;); match = &amp;#39;{&amp;#39;; } if (c !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/valid-parentheses/valid-parentheses.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-parentheses/valid-parentheses.java/</guid>
      <description>// @Title: 有效的括号 (Valid Parentheses) // @Author: 1394466835@qq.com // @Date: 2020-02-16 20:48:22 // @Runtime: 2 ms // @Memory: 40.4 MB class Solution { public boolean isValid(String s) { Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for (char c : s.toCharArray()) { if (c == &amp;#39;(&amp;#39;) { stack.push(&amp;#39;)&amp;#39;); } else if (c == &amp;#39;[&amp;#39;) { stack.push(&amp;#39;]&amp;#39;); } else if (c == &amp;#39;{&amp;#39;) { stack.push(&amp;#39;}&amp;#39;); } else if (stack.isEmpty() || stack.pop() != c) { return false; } } return stack.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/valid-parentheses/valid-parentheses.py/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-parentheses/valid-parentheses.py/</guid>
      <description># @Title: 有效的括号 (Valid Parentheses) # @Author: 1394466835@qq.com # @Date: 2020-02-12 20:33:46 # @Runtime: 44 ms # @Memory: 12.8 MB class Solution: def isValid(self, s: str) -&amp;gt; bool: dic = {&amp;#39;{&amp;#39;:&amp;#39;}&amp;#39;, &amp;#39;[&amp;#39;:&amp;#39;]&amp;#39;, &amp;#39;(&amp;#39;:&amp;#39;)&amp;#39;, &amp;#39;1&amp;#39;:&amp;#39;1&amp;#39;} stack = [&amp;#39;1&amp;#39;] for c in s: if c in dic: stack.append(c) elif dic[stack.pop()] != c: return False return len(stack) == 1 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/valid-perfect-square/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-perfect-square/readme/</guid>
      <description>| English | 简体中文 |
367. 有效的完全平方数 题目描述 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。
进阶：不要 使用任何内置的库函数，如 sqrt 。
 示例 1：
输入：num = 16输出：true示例 2：
输入：num = 14输出：false 提示：
1 相关话题  数学 二分查找  相似题目  Sqrt(x) 平方数之和  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/valid-perfect-square/valid-perfect-square.java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-perfect-square/valid-perfect-square.java/</guid>
      <description>// @Title: 有效的完全平方数 (Valid Perfect Square) // @Author: 1394466835@qq.com // @Date: 2021-05-28 07:31:33 // @Runtime: 0 ms // @Memory: 35.2 MB class Solution { public boolean isPerfectSquare(int num) { int left = 1, right = num; while (left &amp;lt;= right) { int mid = left + (right - left) / 2; int res = num / mid, tail = num % mid; if (tail == 0 &amp;amp;&amp;amp; res == mid) { return true; } else if (res &amp;lt; mid) { right = mid - 1; } else { left = mid + 1; } } return false; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/validate-binary-search-tree/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/validate-binary-search-tree/readme/</guid>
      <description>| English | 简体中文 |
98. 验证二叉搜索树 题目描述 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
有效 二叉搜索树定义如下：
节点的左子树只包含 小于 当前节点的数。节点的右子树只包含 大于 当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。&amp;nbsp;
示例 1：
输入：root = [2,1,3]输出：true示例 2：
输入：root = [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。&amp;nbsp;
提示：
树中节点数目范围在[1, 104] 内-231 &amp;lt;= Node.val &amp;lt;= 231 - 1相关话题  树 深度优先搜索 二叉搜索树 二叉树  相似题目  二叉树的中序遍历 二叉搜索树中的众数  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://xmchxup.github.io/problemset/validate-binary-search-tree/validate-binary-search-tree.cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/validate-binary-search-tree/validate-binary-search-tree.cpp/</guid>
      <description>// @Title: 验证二叉搜索树 (Validate Binary Search Tree) // @Author: 1394466835@qq.com // @Date: 2019-04-01 08:42:26 // @Runtime: 40 ms // @Memory: 19.9 MB /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isValidBST(TreeNode* root) { return isValidBST(root, LONG_MIN, LONG_MAX); } bool isValidBST(TreeNode* root, long x, long y) { if (!</description>
    </item>
    
    <item>
      <title>[1. Two Sum](https://leetcode-cn.com/problems/two-sum/)</title>
      <link>https://xmchxup.github.io/problemset/two-sum/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/two-sum/readme_en/</guid>
      <description>| English | 简体中文 |
1. Two Sum Description Given an array of integers nums&amp;nbsp;and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
&amp;nbsp;
Example 1:
Input: nums = [2,7,11,15], target = 9Output: [0,1]Output: Because nums[0] + nums[1] == 9, we return [0, 1].</description>
    </item>
    
    <item>
      <title>[100. Same Tree](https://leetcode-cn.com/problems/same-tree/)</title>
      <link>https://xmchxup.github.io/problemset/same-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/same-tree/readme_en/</guid>
      <description>| English | 简体中文 |
100. Same Tree Description Given the roots of two binary trees p and q, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
&amp;nbsp;
Example 1:
Input: p = [1,2,3], q = [1,2,3]Output: trueExample 2:
Input: p = [1,2], q = [1,null,2]Output: falseExample 3:</description>
    </item>
    
    <item>
      <title>[1005. Maximize Sum Of Array After K Negations](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)</title>
      <link>https://xmchxup.github.io/problemset/maximize-sum-of-array-after-k-negations/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/maximize-sum-of-array-after-k-negations/readme_en/</guid>
      <description>| English | 简体中文 |
1005. Maximize Sum Of Array After K Negations Description Given an integer array nums and an integer k, modify the array in the following way:
choose an index i and replace nums[i] with -nums[i].You should apply this process exactly k times. You may choose the same index i multiple times.
Return the largest possible sum of the array after modifying it in this way.</description>
    </item>
    
    <item>
      <title>[101. Symmetric Tree](https://leetcode-cn.com/problems/symmetric-tree/)</title>
      <link>https://xmchxup.github.io/problemset/symmetric-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/symmetric-tree/readme_en/</guid>
      <description>| English | 简体中文 |
101. Symmetric Tree Description Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
&amp;nbsp;
Example 1:
Input: root = [1,2,2,3,4,4,3]Output: trueExample 2:
Input: root = [1,2,2,null,3,null,3]Output: false&amp;nbsp;
Constraints:
The number of nodes in the tree is in the range [1, 1000].-100 &amp;lt;= Node.val &amp;lt;= 100&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[1017. Convert to Base -2](https://leetcode-cn.com/problems/convert-to-base-2/)</title>
      <link>https://xmchxup.github.io/problemset/convert-to-base-2/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/convert-to-base-2/readme_en/</guid>
      <description>| English | 简体中文 |
1017. Convert to Base -2 Description Given an integer n, return a binary string representing its representation in base -2.
Note that the returned string should not have leading zeros unless the string is &amp;quot;0&amp;quot;.
&amp;nbsp;
Example 1:
Input: n = 2Output: &amp;quot;110&amp;quot;Explantion: (-2)2 + (-2)1 = 2Example 2:
Input: n = 3Output: &amp;quot;111&amp;quot;Explantion: (-2)2 + (-2)1 + (-2)0 = 3Example 3:</description>
    </item>
    
    <item>
      <title>[102. Binary Tree Level Order Traversal](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)</title>
      <link>https://xmchxup.github.io/problemset/binary-tree-level-order-traversal/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-level-order-traversal/readme_en/</guid>
      <description>| English | 简体中文 |
102. Binary Tree Level Order Traversal Description Given the root of a binary tree, return the level order traversal of its nodes&amp;#39; values. (i.e., from left to right, level by level).
&amp;nbsp;
Example 1:
Input: root = [3,9,20,null,null,15,7]Output: [[3],[9,20],[15,7]]Example 2:
Input: root = [1]Output: [[1]]Example 3:
Input: root = []Output: []&amp;nbsp;
Constraints:
The number of nodes in the tree is in the range [0, 2000].</description>
    </item>
    
    <item>
      <title>[104. Maximum Depth of Binary Tree](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)</title>
      <link>https://xmchxup.github.io/problemset/maximum-depth-of-binary-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/maximum-depth-of-binary-tree/readme_en/</guid>
      <description>| English | 简体中文 |
104. Maximum Depth of Binary Tree Description Given the root of a binary tree, return its maximum depth.
A binary tree&amp;#39;s maximum depth&amp;nbsp;is the number of nodes along the longest path from the root node down to the farthest leaf node.
&amp;nbsp;
Example 1:
Input: root = [3,9,20,null,null,15,7]Output: 3Example 2:
Input: root = [1,null,2]Output: 2Example 3:
Input: root = []Output: 0Example 4:</description>
    </item>
    
    <item>
      <title>[108. Convert Sorted Array to Binary Search Tree](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)</title>
      <link>https://xmchxup.github.io/problemset/convert-sorted-array-to-binary-search-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/convert-sorted-array-to-binary-search-tree/readme_en/</guid>
      <description>| English | 简体中文 |
108. Convert Sorted Array to Binary Search Tree Description Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.
A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.
&amp;nbsp;
Example 1:
Input: nums = [-10,-3,0,5,9]Output: [0,-3,9,-10,null,5]Explanation: [0,-10,5,null,-3,null,9] is also accepted:Example 2:</description>
    </item>
    
    <item>
      <title>[11. Container With Most Water](https://leetcode-cn.com/problems/container-with-most-water/)</title>
      <link>https://xmchxup.github.io/problemset/container-with-most-water/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/container-with-most-water/readme_en/</guid>
      <description>| English | 简体中文 |
11. Container With Most Water Description Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.
Notice that you may not slant the container.</description>
    </item>
    
    <item>
      <title>[110. Balanced Binary Tree](https://leetcode-cn.com/problems/balanced-binary-tree/)</title>
      <link>https://xmchxup.github.io/problemset/balanced-binary-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/balanced-binary-tree/readme_en/</guid>
      <description>| English | 简体中文 |
110. Balanced Binary Tree Description Given a binary tree, determine if it is height-balanced.
For this problem, a height-balanced binary tree is defined as:
a binary tree in which the left and right subtrees of every node differ in height by no more than 1.
&amp;nbsp;
Example 1:
Input: root = [3,9,20,null,null,15,7]Output: trueExample 2:
Input: root = [1,2,2,3,3,null,null,4,4]Output: falseExample 3:</description>
    </item>
    
    <item>
      <title>[112. Path Sum](https://leetcode-cn.com/problems/path-sum/)</title>
      <link>https://xmchxup.github.io/problemset/path-sum/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/path-sum/readme_en/</guid>
      <description>| English | 简体中文 |
112. Path Sum Description Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.
A leaf is a node with no children.
&amp;nbsp;
Example 1:
Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22Output: trueExample 2:
Input: root = [1,2,3], targetSum = 5Output: falseExample 3:</description>
    </item>
    
    <item>
      <title>[116. Populating Next Right Pointers in Each Node](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)</title>
      <link>https://xmchxup.github.io/problemset/populating-next-right-pointers-in-each-node/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/populating-next-right-pointers-in-each-node/readme_en/</guid>
      <description>| English | 简体中文 |
116. Populating Next Right Pointers in Each Node Description You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:
struct Node {int val;Node *left;Node *right;Node *next;}Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</description>
    </item>
    
    <item>
      <title>[119. Pascal&#39;s Triangle II](https://leetcode-cn.com/problems/pascals-triangle-ii/)</title>
      <link>https://xmchxup.github.io/problemset/pascals-triangle-ii/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/pascals-triangle-ii/readme_en/</guid>
      <description>| English | 简体中文 |
119. Pascal&amp;rsquo;s Triangle II Description Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal&amp;#39;s triangle.
In Pascal&amp;#39;s triangle, each number is the sum of the two numbers directly above it as shown:
&amp;nbsp;
Example 1:
Input: rowIndex = 3Output: [1,3,3,1]Example 2:
Input: rowIndex = 0Output: [1]Example 3:
Input: rowIndex = 1Output: [1,1]&amp;nbsp;
Constraints:
0 &amp;lt;= rowIndex &amp;lt;= 33&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[1190. Reverse Substrings Between Each Pair of Parentheses](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/)</title>
      <link>https://xmchxup.github.io/problemset/reverse-substrings-between-each-pair-of-parentheses/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-substrings-between-each-pair-of-parentheses/readme_en/</guid>
      <description>| English | 简体中文 |
1190. Reverse Substrings Between Each Pair of Parentheses Description You are given a string s that consists of lower case English letters and brackets.&amp;nbsp;
Reverse the strings&amp;nbsp;in each&amp;nbsp;pair of matching parentheses, starting&amp;nbsp;from the innermost one.
Your result should not contain any brackets.
&amp;nbsp;
Example 1:
Input: s = &amp;quot;(abcd)&amp;quot;Output: &amp;quot;dcba&amp;quot;Example 2:
Input: s = &amp;quot;(u(love)i)&amp;quot;Output: &amp;quot;iloveu&amp;quot;Explanation:&amp;nbsp;The substring &amp;quot;love&amp;quot; is reversed first, then the whole string is reversed.</description>
    </item>
    
    <item>
      <title>[1217. Minimum Cost to Move Chips to The Same Position](https://leetcode-cn.com/problems/minimum-cost-to-move-chips-to-the-same-position/)</title>
      <link>https://xmchxup.github.io/problemset/minimum-cost-to-move-chips-to-the-same-position/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-cost-to-move-chips-to-the-same-position/readme_en/</guid>
      <description>| English | 简体中文 |
1217. Minimum Cost to Move Chips to The Same Position Description We have n chips, where the position of the ith chip is position[i].
We need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to:
position[i] + 2 or position[i] - 2 with cost = 0.position[i] + 1 or position[i] - 1 with cost = 1.</description>
    </item>
    
    <item>
      <title>[122. Best Time to Buy and Sell Stock II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)</title>
      <link>https://xmchxup.github.io/problemset/best-time-to-buy-and-sell-stock-ii/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/best-time-to-buy-and-sell-stock-ii/readme_en/</guid>
      <description>| English | 简体中文 |
122. Best Time to Buy and Sell Stock II Description You are given an integer array prices where prices[i] is the price of a given stock on the ith day.
On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.</description>
    </item>
    
    <item>
      <title>[124. Binary Tree Maximum Path Sum](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)</title>
      <link>https://xmchxup.github.io/problemset/binary-tree-maximum-path-sum/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-maximum-path-sum/readme_en/</guid>
      <description>| English | 简体中文 |
124. Binary Tree Maximum Path Sum Description A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.
The path sum of a path is the sum of the node&amp;#39;s values in the path.</description>
    </item>
    
    <item>
      <title>[125. Valid Palindrome](https://leetcode-cn.com/problems/valid-palindrome/)</title>
      <link>https://xmchxup.github.io/problemset/valid-palindrome/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-palindrome/readme_en/</guid>
      <description>| English | 简体中文 |
125. Valid Palindrome Description Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
&amp;nbsp;
Example 1:
Input: s = &amp;quot;A man, a plan, a canal: Panama&amp;quot;Output: trueExplanation: &amp;quot;amanaplanacanalpanama&amp;quot; is a palindrome.Example 2:
Input: s = &amp;quot;race a car&amp;quot;Output: falseExplanation: &amp;quot;raceacar&amp;quot; is not a palindrome.&amp;nbsp;
Constraints:
1 &amp;lt;= s.</description>
    </item>
    
    <item>
      <title>[13. Roman to Integer](https://leetcode-cn.com/problems/roman-to-integer/)</title>
      <link>https://xmchxup.github.io/problemset/roman-to-integer/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/roman-to-integer/readme_en/</guid>
      <description>| English | 简体中文 |
13. Roman to Integer Description Roman numerals are represented by seven different symbols:&amp;nbsp;I, V, X, L, C, D and M.
Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example,&amp;nbsp;2 is written as II&amp;nbsp;in Roman numeral, just two one&amp;#39;s added together. 12 is written as&amp;nbsp;XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</description>
    </item>
    
    <item>
      <title>[1332. Remove Palindromic Subsequences](https://leetcode-cn.com/problems/remove-palindromic-subsequences/)</title>
      <link>https://xmchxup.github.io/problemset/remove-palindromic-subsequences/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-palindromic-subsequences/readme_en/</guid>
      <description>| English | 简体中文 |
1332. Remove Palindromic Subsequences Description You are given a string s consisting only of letters &amp;#39;a&amp;#39; and &amp;#39;b&amp;#39;. In a single step you can remove one palindromic subsequence from s.
Return the minimum number of steps to make the given string empty.
A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order.</description>
    </item>
    
    <item>
      <title>[135. Candy](https://leetcode-cn.com/problems/candy/)</title>
      <link>https://xmchxup.github.io/problemset/candy/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/candy/readme_en/</guid>
      <description>| English | 简体中文 |
135. Candy Description There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.
You are giving candies to these children subjected to the following requirements:
Each child must have at least one candy.Children with a higher rating get more candies than their neighbors.Return the minimum number of candies you need to have to distribute the candies to the children.</description>
    </item>
    
    <item>
      <title>[136. Single Number](https://leetcode-cn.com/problems/single-number/)</title>
      <link>https://xmchxup.github.io/problemset/single-number/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/single-number/readme_en/</guid>
      <description>| English | 简体中文 |
136. Single Number Description Given a non-empty&amp;nbsp;array of integers nums, every element appears twice except for one. Find that single one.
You must&amp;nbsp;implement a solution with a linear runtime complexity and use&amp;nbsp;only constant&amp;nbsp;extra space.
&amp;nbsp;
Example 1:
Input: nums = [2,2,1]Output: 1Example 2:
Input: nums = [4,1,2,1,2]Output: 4Example 3:
Input: nums = [1]Output: 1&amp;nbsp;
Constraints:
1 &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title>[141. Linked List Cycle](https://leetcode-cn.com/problems/linked-list-cycle/)</title>
      <link>https://xmchxup.github.io/problemset/linked-list-cycle/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/linked-list-cycle/readme_en/</guid>
      <description>| English | 简体中文 |
141. Linked List Cycle Description Given head, the head of a linked list, determine if the linked list has a cycle in it.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&amp;nbsp;next&amp;nbsp;pointer. Internally, pos&amp;nbsp;is used to denote the index of the node that&amp;nbsp;tail&amp;#39;s&amp;nbsp;next&amp;nbsp;pointer is connected to.&amp;nbsp;Note that&amp;nbsp;pos&amp;nbsp;is not passed as a parameter.</description>
    </item>
    
    <item>
      <title>[142. Linked List Cycle II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)</title>
      <link>https://xmchxup.github.io/problemset/linked-list-cycle-ii/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/linked-list-cycle-ii/readme_en/</guid>
      <description>| English | 简体中文 |
142. Linked List Cycle II Description Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;#39;s next pointer is connected to (0-indexed).</description>
    </item>
    
    <item>
      <title>[1436. Destination City](https://leetcode-cn.com/problems/destination-city/)</title>
      <link>https://xmchxup.github.io/problemset/destination-city/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/destination-city/readme_en/</guid>
      <description>| English | 简体中文 |
1436. Destination City Description You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.
It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.
&amp;nbsp;
Example 1:</description>
    </item>
    
    <item>
      <title>[146. LRU Cache](https://leetcode-cn.com/problems/lru-cache/)</title>
      <link>https://xmchxup.github.io/problemset/lru-cache/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/lru-cache/readme_en/</guid>
      <description>| English | 简体中文 |
146. LRU Cache Description Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
Implement the LRUCache class:
LRUCache(int capacity) Initialize the LRU cache with positive size capacity.int get(int key) Return the value of the key if the key exists, otherwise return -1.void put(int key, int value)&amp;nbsp;Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache.</description>
    </item>
    
    <item>
      <title>[147. Insertion Sort List](https://leetcode-cn.com/problems/insertion-sort-list/)</title>
      <link>https://xmchxup.github.io/problemset/insertion-sort-list/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/insertion-sort-list/readme_en/</guid>
      <description>| English | 简体中文 |
147. Insertion Sort List Description Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list&amp;#39;s head.
The steps of the insertion sort algorithm:
Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.</description>
    </item>
    
    <item>
      <title>[148. Sort List](https://leetcode-cn.com/problems/sort-list/)</title>
      <link>https://xmchxup.github.io/problemset/sort-list/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sort-list/readme_en/</guid>
      <description>| English | 简体中文 |
148. Sort List Description Given the head of a linked list, return the list after sorting it in ascending order.
&amp;nbsp;
Example 1:
Input: head = [4,2,1,3]Output: [1,2,3,4]Example 2:
Input: head = [-1,5,3,4,0]Output: [-1,0,3,4,5]Example 3:
Input: head = []Output: []&amp;nbsp;
Constraints:
The number of nodes in the list is in the range [0, 5 * 104].</description>
    </item>
    
    <item>
      <title>[15. 3Sum](https://leetcode-cn.com/problems/3sum/)</title>
      <link>https://xmchxup.github.io/problemset/3sum/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/3sum/readme_en/</guid>
      <description>| English | 简体中文 |
15. 3Sum Description Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
&amp;nbsp;
Example 1:
Input: nums = [-1,0,1,2,-1,-4]Output: [[-1,-1,2],[-1,0,1]]Example 2:
Input: nums = []Output: []Example 3:
Input: nums = [0]Output: []&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[155. Min Stack](https://leetcode-cn.com/problems/min-stack/)</title>
      <link>https://xmchxup.github.io/problemset/min-stack/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/min-stack/readme_en/</guid>
      <description>| English | 简体中文 |
155. Min Stack Description Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
Implement the MinStack class:
MinStack() initializes the stack object.void push(int val) pushes the element val onto the stack.void pop() removes the element on the top of the stack.int top() gets the top element of the stack.int getMin() retrieves the minimum element in the stack.</description>
    </item>
    
    <item>
      <title>[16. 3Sum Closest](https://leetcode-cn.com/problems/3sum-closest/)</title>
      <link>https://xmchxup.github.io/problemset/3sum-closest/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/3sum-closest/readme_en/</guid>
      <description>| English | 简体中文 |
16. 3Sum Closest Description Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.
Return the sum of the three integers.
You may assume that each input would have exactly one solution.
&amp;nbsp;
Example 1:
Input: nums = [-1,2,1,-4], target = 1Output: 2Explanation: The sum that is closest to the target is 2.</description>
    </item>
    
    <item>
      <title>[166. Fraction to Recurring Decimal](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)</title>
      <link>https://xmchxup.github.io/problemset/fraction-to-recurring-decimal/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/fraction-to-recurring-decimal/readme_en/</guid>
      <description>| English | 简体中文 |
166. Fraction to Recurring Decimal Description Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.
If the fractional part is repeating, enclose the repeating part in parentheses.
If multiple answers are possible, return any of them.
It is guaranteed that the length of the answer string is less than 104 for all the given inputs.
&amp;nbsp;
Example 1:</description>
    </item>
    
    <item>
      <title>[167. Two Sum II - Input array is sorted](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)</title>
      <link>https://xmchxup.github.io/problemset/two-sum-ii-input-array-is-sorted/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/two-sum-ii-input-array-is-sorted/readme_en/</guid>
      <description>| English | 简体中文 |
167. Two Sum II - Input array is sorted Description Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;lt;= first &amp;lt; second &amp;lt;= numbers.length.
Return the indices of the two numbers, index1 and index2, as an integer array [index1, index2] of length 2.</description>
    </item>
    
    <item>
      <title>[169. Majority Element](https://leetcode-cn.com/problems/majority-element/)</title>
      <link>https://xmchxup.github.io/problemset/majority-element/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/majority-element/readme_en/</guid>
      <description>| English | 简体中文 |
169. Majority Element Description Given an array nums of size n, return the majority element.
The majority element is the element that appears more than &amp;lfloor;n / 2&amp;rfloor; times. You may assume that the majority element always exists in the array.
&amp;nbsp;
Example 1:
Input: nums = [3,2,3]Output: 3Example 2:
Input: nums = [2,2,1,1,1,2,2]Output: 2&amp;nbsp;
Constraints:
n == nums.length1 &amp;lt;= n &amp;lt;= 5 * 104-231 &amp;lt;= nums[i] &amp;lt;= 231 - 1&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[17. Letter Combinations of a Phone Number](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)</title>
      <link>https://xmchxup.github.io/problemset/letter-combinations-of-a-phone-number/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/letter-combinations-of-a-phone-number/readme_en/</guid>
      <description>| English | 简体中文 |
17. Letter Combinations of a Phone Number Description Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
&amp;nbsp;
Example 1:
Input: digits = &amp;quot;23&amp;quot;Output: [&amp;quot;ad&amp;quot;,&amp;quot;ae&amp;quot;,&amp;quot;af&amp;quot;,&amp;quot;bd&amp;quot;,&amp;quot;be&amp;quot;,&amp;quot;bf&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ce&amp;quot;,&amp;quot;cf&amp;quot;]Example 2:</description>
    </item>
    
    <item>
      <title>[1721. Swapping Nodes in a Linked List](https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/)</title>
      <link>https://xmchxup.github.io/problemset/swapping-nodes-in-a-linked-list/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/swapping-nodes-in-a-linked-list/readme_en/</guid>
      <description>| English | 简体中文 |
1721. Swapping Nodes in a Linked List Description You are given the head of a linked list, and an integer k.
Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).
&amp;nbsp;
Example 1:
Input: head = [1,2,3,4,5], k = 2Output: [1,4,3,2,5]Example 2:</description>
    </item>
    
    <item>
      <title>[173. Binary Search Tree Iterator](https://leetcode-cn.com/problems/binary-search-tree-iterator/)</title>
      <link>https://xmchxup.github.io/problemset/binary-search-tree-iterator/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-search-tree-iterator/readme_en/</guid>
      <description>| English | 简体中文 |
173. Binary Search Tree Iterator Description Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):
BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.</description>
    </item>
    
    <item>
      <title>[175. Combine Two Tables](https://leetcode-cn.com/problems/combine-two-tables/)</title>
      <link>https://xmchxup.github.io/problemset/combine-two-tables/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combine-two-tables/readme_en/</guid>
      <description>| English | 简体中文 |
175. Combine Two Tables Description Table: Person
+-------------+---------+| Column Name | Type |+-------------+---------+| PersonId | int || FirstName | varchar || LastName | varchar |+-------------+---------+PersonId is the primary key column for this table.This table contains information about the ID of some persons and their first and last names.&amp;nbsp;
Table: Address
+-------------+---------+| Column Name | Type |+-------------+---------+| AddressId | int || PersonId | int || City | varchar || State | varchar |+-------------+---------+AddressId is the primary key column for this table.</description>
    </item>
    
    <item>
      <title>[176. Second Highest Salary](https://leetcode-cn.com/problems/second-highest-salary/)</title>
      <link>https://xmchxup.github.io/problemset/second-highest-salary/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/second-highest-salary/readme_en/</guid>
      <description>| English | 简体中文 |
176. Second Highest Salary Description Table: Employee
+-------------+------+| Column Name | Type |+-------------+------+| Id | int || Salary | int |+-------------+------+Id is the primary key column for this table.Each row of this table contains information about the salary of an employee.&amp;nbsp;
Write an SQL query to report the second highest salary from the Employee table. If there is no second highest salary, the query should report null.</description>
    </item>
    
    <item>
      <title>[179. Largest Number](https://leetcode-cn.com/problems/largest-number/)</title>
      <link>https://xmchxup.github.io/problemset/largest-number/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/largest-number/readme_en/</guid>
      <description>| English | 简体中文 |
179. Largest Number Description Given a list of non-negative integers nums, arrange them such that they form the largest number.
Note: The result may be very large, so you need to return a string instead of an integer.
&amp;nbsp;
Example 1:
Input: nums = [10,2]Output: &amp;quot;210&amp;quot;Example 2:
Input: nums = [3,30,34,5,9]Output: &amp;quot;9534330&amp;quot;Example 3:
Input: nums = [1]Output: &amp;quot;1&amp;quot;Example 4:</description>
    </item>
    
    <item>
      <title>[183. Customers Who Never Order](https://leetcode-cn.com/problems/customers-who-never-order/)</title>
      <link>https://xmchxup.github.io/problemset/customers-who-never-order/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/customers-who-never-order/readme_en/</guid>
      <description>| English | 简体中文 |
183. Customers Who Never Order Description Table: Customers
+-------------+---------+| Column Name | Type |+-------------+---------+| Id | int || Name | varchar |+-------------+---------+Id is the primary key column for this table.Each row of this table indicates the ID and name of a customer.&amp;nbsp;
Table: Orders
+-------------+------+| Column Name | Type |+-------------+------+| Id | int || CustomerId | int |+-------------+------+Id is the primary key column for this table.</description>
    </item>
    
    <item>
      <title>[187. Repeated DNA Sequences](https://leetcode-cn.com/problems/repeated-dna-sequences/)</title>
      <link>https://xmchxup.github.io/problemset/repeated-dna-sequences/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/repeated-dna-sequences/readme_en/</guid>
      <description>| English | 简体中文 |
187. Repeated DNA Sequences Description The DNA sequence is composed of a series of nucleotides abbreviated as &amp;#39;A&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;G&amp;#39;, and &amp;#39;T&amp;#39;.
For example, &amp;quot;ACGAATTCCG&amp;quot; is a DNA sequence.When studying DNA, it is useful to identify repeated sequences within the DNA.
Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</description>
    </item>
    
    <item>
      <title>[189. Rotate Array](https://leetcode-cn.com/problems/rotate-array/)</title>
      <link>https://xmchxup.github.io/problemset/rotate-array/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/rotate-array/readme_en/</guid>
      <description>| English | 简体中文 |
189. Rotate Array Description Given an array, rotate the array to the right by k steps, where k is non-negative.
&amp;nbsp;
Example 1:
Input: nums = [1,2,3,4,5,6,7], k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4]Example 2:
Input: nums = [-1,-100,3,99], k = 2Output: [3,99,-1,-100]Explanation: rotate 1 steps to the right: [99,-1,-100,3]rotate 2 steps to the right: [3,99,-1,-100]&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[19. Remove Nth Node From End of List](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)</title>
      <link>https://xmchxup.github.io/problemset/remove-nth-node-from-end-of-list/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-nth-node-from-end-of-list/readme_en/</guid>
      <description>| English | 简体中文 |
19. Remove Nth Node From End of List Description Given the head of a linked list, remove the nth node from the end of the list and return its head.
&amp;nbsp;
Example 1:
Input: head = [1,2,3,4,5], n = 2Output: [1,2,3,5]Example 2:
Input: head = [1], n = 1Output: []Example 3:
Input: head = [1,2], n = 1Output: [1]&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[191. Number of 1 Bits](https://leetcode-cn.com/problems/number-of-1-bits/)</title>
      <link>https://xmchxup.github.io/problemset/number-of-1-bits/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/number-of-1-bits/readme_en/</guid>
      <description>| English | 简体中文 |
191. Number of 1 Bits Description Write a function that takes an unsigned integer and returns the number of &amp;#39;1&amp;#39; bits it has (also known as the Hamming weight).
Note:
Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer&amp;#39;s internal binary representation is the same, whether it is signed or unsigned.</description>
    </item>
    
    <item>
      <title>[2. Add Two Numbers](https://leetcode-cn.com/problems/add-two-numbers/)</title>
      <link>https://xmchxup.github.io/problemset/add-two-numbers/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-two-numbers/readme_en/</guid>
      <description>| English | 简体中文 |
2. Add Two Numbers Description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum&amp;nbsp;as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
&amp;nbsp;
Example 1:
Input: l1 = [2,4,3], l2 = [5,6,4]Output: [7,0,8]Explanation: 342 + 465 = 807.</description>
    </item>
    
    <item>
      <title>[20. Valid Parentheses](https://leetcode-cn.com/problems/valid-parentheses/)</title>
      <link>https://xmchxup.github.io/problemset/valid-parentheses/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-parentheses/readme_en/</guid>
      <description>| English | 简体中文 |
20. Valid Parentheses Description Given a string s containing just the characters &amp;#39;(&amp;#39;, &amp;#39;)&amp;#39;, &amp;#39;{&amp;#39;, &amp;#39;}&amp;#39;, &amp;#39;[&amp;#39; and &amp;#39;]&amp;#39;, determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.&amp;nbsp;
Example 1:
Input: s = &amp;quot;()&amp;quot;Output: trueExample 2:</description>
    </item>
    
    <item>
      <title>[202. Happy Number](https://leetcode-cn.com/problems/happy-number/)</title>
      <link>https://xmchxup.github.io/problemset/happy-number/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/happy-number/readme_en/</guid>
      <description>| English | 简体中文 |
202. Happy Number Description Write an algorithm to determine if a number n is happy.
A happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits.Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</description>
    </item>
    
    <item>
      <title>[203. Remove Linked List Elements](https://leetcode-cn.com/problems/remove-linked-list-elements/)</title>
      <link>https://xmchxup.github.io/problemset/remove-linked-list-elements/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-linked-list-elements/readme_en/</guid>
      <description>| English | 简体中文 |
203. Remove Linked List Elements Description Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.
&amp;nbsp;
Example 1:
Input: head = [1,2,6,3,4,5,6], val = 6Output: [1,2,3,4,5]Example 2:
Input: head = [], val = 1Output: []Example 3:
Input: head = [7,7,7,7], val = 7Output: []&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[206. Reverse Linked List](https://leetcode-cn.com/problems/reverse-linked-list/)</title>
      <link>https://xmchxup.github.io/problemset/reverse-linked-list/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-linked-list/readme_en/</guid>
      <description>| English | 简体中文 |
206. Reverse Linked List Description Given the head of a singly linked list, reverse the list, and return the reversed list.
&amp;nbsp;
Example 1:
Input: head = [1,2,3,4,5]Output: [5,4,3,2,1]Example 2:
Input: head = [1,2]Output: [2,1]Example 3:
Input: head = []Output: []&amp;nbsp;
Constraints:
The number of nodes in the list is the range [0, 5000].</description>
    </item>
    
    <item>
      <title>[209. Minimum Size Subarray Sum](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)</title>
      <link>https://xmchxup.github.io/problemset/minimum-size-subarray-sum/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-size-subarray-sum/readme_en/</guid>
      <description>| English | 简体中文 |
209. Minimum Size Subarray Sum Description Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.
&amp;nbsp;
Example 1:
Input: target = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: The subarray [4,3] has the minimal length under the problem constraint.</description>
    </item>
    
    <item>
      <title>[21. Merge Two Sorted Lists](https://leetcode-cn.com/problems/merge-two-sorted-lists/)</title>
      <link>https://xmchxup.github.io/problemset/merge-two-sorted-lists/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/merge-two-sorted-lists/readme_en/</guid>
      <description>| English | 简体中文 |
21. Merge Two Sorted Lists Description Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.
&amp;nbsp;
Example 1:
Input: l1 = [1,2,4], l2 = [1,3,4]Output: [1,1,2,3,4,4]Example 2:
Input: l1 = [], l2 = []Output: []Example 3:
Input: l1 = [], l2 = [0]Output: [0]&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[216. Combination Sum III](https://leetcode-cn.com/problems/combination-sum-iii/)</title>
      <link>https://xmchxup.github.io/problemset/combination-sum-iii/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combination-sum-iii/readme_en/</guid>
      <description>| English | 简体中文 |
216. Combination Sum III Description Find all valid combinations of k numbers that sum up to n such that the following conditions are true:
Only numbers 1 through 9 are used.Each number is used at most once.Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.</description>
    </item>
    
    <item>
      <title>[217. Contains Duplicate](https://leetcode-cn.com/problems/contains-duplicate/)</title>
      <link>https://xmchxup.github.io/problemset/contains-duplicate/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/contains-duplicate/readme_en/</guid>
      <description>| English | 简体中文 |
217. Contains Duplicate Description Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.
&amp;nbsp;
Example 1:
Input: nums = [1,2,3,1]Output: trueExample 2:
Input: nums = [1,2,3,4]Output: falseExample 3:
Input: nums = [1,1,1,3,3,4,3,2,4,2]Output: true&amp;nbsp;
Constraints:
1 &amp;lt;= nums.length &amp;lt;= 105-109 &amp;lt;= nums[i] &amp;lt;= 109Related Topics  Array Hash Table Sorting  Similar Questions  Contains Duplicate II Contains Duplicate III  </description>
    </item>
    
    <item>
      <title>[226. Invert Binary Tree](https://leetcode-cn.com/problems/invert-binary-tree/)</title>
      <link>https://xmchxup.github.io/problemset/invert-binary-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/invert-binary-tree/readme_en/</guid>
      <description>| English | 简体中文 |
226. Invert Binary Tree Description Given the root of a binary tree, invert the tree, and return its root.
&amp;nbsp;
Example 1:
Input: root = [4,2,7,1,3,6,9]Output: [4,7,2,9,6,3,1]Example 2:
Input: root = [2,1,3]Output: [2,3,1]Example 3:
Input: root = []Output: []&amp;nbsp;
Constraints:
The number of nodes in the tree is in the range [0, 100].</description>
    </item>
    
    <item>
      <title>[23. Merge k Sorted Lists](https://leetcode-cn.com/problems/merge-k-sorted-lists/)</title>
      <link>https://xmchxup.github.io/problemset/merge-k-sorted-lists/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/merge-k-sorted-lists/readme_en/</guid>
      <description>| English | 简体中文 |
23. Merge k Sorted Lists Description You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.
&amp;nbsp;
Example 1:
Input: lists = [[1,4,5],[1,3,4],[2,6]]Output: [1,1,2,3,4,4,5,6]Explanation: The linked-lists are:[1-&amp;gt;4-&amp;gt;5,1-&amp;gt;3-&amp;gt;4,2-&amp;gt;6]merging them into one sorted list:1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6Example 2:
Input: lists = []Output: []Example 3:</description>
    </item>
    
    <item>
      <title>[230. Kth Smallest Element in a BST](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)</title>
      <link>https://xmchxup.github.io/problemset/kth-smallest-element-in-a-bst/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/kth-smallest-element-in-a-bst/readme_en/</guid>
      <description>| English | 简体中文 |
230. Kth Smallest Element in a BST Description Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.
&amp;nbsp;
Example 1:
Input: root = [3,1,4,null,2], k = 1Output: 1Example 2:
Input: root = [5,3,6,2,4,null,null,1], k = 3Output: 3&amp;nbsp;
Constraints:</description>
    </item>
    
    <item>
      <title>[235. Lowest Common Ancestor of a Binary Search Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)</title>
      <link>https://xmchxup.github.io/problemset/lowest-common-ancestor-of-a-binary-search-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/lowest-common-ancestor-of-a-binary-search-tree/readme_en/</guid>
      <description>| English | 简体中文 |
235. Lowest Common Ancestor of a Binary Search Tree Description Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: &amp;ldquo;The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).</description>
    </item>
    
    <item>
      <title>[236. Lowest Common Ancestor of a Binary Tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)</title>
      <link>https://xmchxup.github.io/problemset/lowest-common-ancestor-of-a-binary-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/lowest-common-ancestor-of-a-binary-tree/readme_en/</guid>
      <description>| English | 简体中文 |
236. Lowest Common Ancestor of a Binary Tree Description Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the definition of LCA on Wikipedia: &amp;ldquo;The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).</description>
    </item>
    
    <item>
      <title>[239. Sliding Window Maximum](https://leetcode-cn.com/problems/sliding-window-maximum/)</title>
      <link>https://xmchxup.github.io/problemset/sliding-window-maximum/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sliding-window-maximum/readme_en/</guid>
      <description>| English | 简体中文 |
239. Sliding Window Maximum Description You are given an array of integers&amp;nbsp;nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.
Return the max sliding window.
&amp;nbsp;
Example 1:
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3Output: [3,3,5,5,6,7]Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 31 [3 -1 -3] 5 3 6 7 31 3 [-1 -3 5] 3 6 7  51 3 -1 [-3 5 3] 6 7 51 3 -1 -3 [5 3 6] 7 61 3 -1 -3 5 [3 6 7] 7Example 2:</description>
    </item>
    
    <item>
      <title>[24. Swap Nodes in Pairs](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)</title>
      <link>https://xmchxup.github.io/problemset/swap-nodes-in-pairs/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/swap-nodes-in-pairs/readme_en/</guid>
      <description>| English | 简体中文 |
24. Swap Nodes in Pairs Description Given a&amp;nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&amp;nbsp;modifying the values in the list&amp;#39;s nodes (i.e., only nodes themselves may be changed.)
&amp;nbsp;
Example 1:
Input: head = [1,2,3,4]Output: [2,1,4,3]Example 2:
Input: head = []Output: []Example 3:
Input: head = [1]Output: [1]&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[25. Reverse Nodes in k-Group](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)</title>
      <link>https://xmchxup.github.io/problemset/reverse-nodes-in-k-group/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-nodes-in-k-group/readme_en/</guid>
      <description>| English | 简体中文 |
25. Reverse Nodes in k-Group Description Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.</description>
    </item>
    
    <item>
      <title>[258. Add Digits](https://leetcode-cn.com/problems/add-digits/)</title>
      <link>https://xmchxup.github.io/problemset/add-digits/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-digits/readme_en/</guid>
      <description>| English | 简体中文 |
258. Add Digits Description Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.
&amp;nbsp;
Example 1:
Input: num = 38Output: 2Explanation: The process is38 --&amp;gt; 3 + 8 --&amp;gt; 1111 --&amp;gt; 1 + 1 --&amp;gt; 2 Since 2 has only one digit, return it.Example 2:
Input: num = 0Output: 0&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[26. Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)</title>
      <link>https://xmchxup.github.io/problemset/remove-duplicates-from-sorted-array/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-duplicates-from-sorted-array/readme_en/</guid>
      <description>| English | 简体中文 |
26. Remove Duplicates from Sorted Array Description Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums.</description>
    </item>
    
    <item>
      <title>[27. Remove Element](https://leetcode-cn.com/problems/remove-element/)</title>
      <link>https://xmchxup.github.io/problemset/remove-element/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/remove-element/readme_en/</guid>
      <description>| English | 简体中文 |
27. Remove Element Description Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result.</description>
    </item>
    
    <item>
      <title>[278. First Bad Version](https://leetcode-cn.com/problems/first-bad-version/)</title>
      <link>https://xmchxup.github.io/problemset/first-bad-version/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/first-bad-version/readme_en/</guid>
      <description>| English | 简体中文 |
278. First Bad Version Description You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</description>
    </item>
    
    <item>
      <title>[283. Move Zeroes](https://leetcode-cn.com/problems/move-zeroes/)</title>
      <link>https://xmchxup.github.io/problemset/move-zeroes/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/move-zeroes/readme_en/</guid>
      <description>| English | 简体中文 |
283. Move Zeroes Description Given an integer array nums, move all 0&amp;#39;s to the end of it while maintaining the relative order of the non-zero elements.
Note that you must do this in-place without making a copy of the array.
&amp;nbsp;
Example 1:
Input: nums = [0,1,0,3,12]Output: [1,3,12,0,0]Example 2:
Input: nums = [0]Output: [0]&amp;nbsp;
Constraints:
1 &amp;lt;= nums.length &amp;lt;= 104-231 &amp;lt;= nums[i] &amp;lt;= 231 - 1&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[284. Peeking Iterator](https://leetcode-cn.com/problems/peeking-iterator/)</title>
      <link>https://xmchxup.github.io/problemset/peeking-iterator/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/peeking-iterator/readme_en/</guid>
      <description>| English | 简体中文 |
284. Peeking Iterator Description Design an iterator that supports the peek operation on a list in addition to the hasNext and the next operations.
Implement the PeekingIterator class:
PeekingIterator(int[] nums) Initializes the object with the given integer array nums.int next() Returns the next element in the array and moves the pointer to the next element.bool hasNext() Returns true if there are still elements in the array.</description>
    </item>
    
    <item>
      <title>[3. Longest Substring Without Repeating Characters](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)</title>
      <link>https://xmchxup.github.io/problemset/longest-substring-without-repeating-characters/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/longest-substring-without-repeating-characters/readme_en/</guid>
      <description>| English | 简体中文 |
3. Longest Substring Without Repeating Characters Description Given a string s, find the length of the longest substring without repeating characters.
&amp;nbsp;
Example 1:
Input: s = &amp;quot;abcabcbb&amp;quot;Output: 3Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3.Example 2:
Input: s = &amp;quot;bbbbb&amp;quot;Output: 1Explanation: The answer is &amp;quot;b&amp;quot;, with the length of 1.Example 3:
Input: s = &amp;quot;pwwkew&amp;quot;Output: 3Explanation: The answer is &amp;quot;wke&amp;quot;, with the length of 3.</description>
    </item>
    
    <item>
      <title>[32. Longest Valid Parentheses](https://leetcode-cn.com/problems/longest-valid-parentheses/)</title>
      <link>https://xmchxup.github.io/problemset/longest-valid-parentheses/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/longest-valid-parentheses/readme_en/</guid>
      <description>| English | 简体中文 |
32. Longest Valid Parentheses Description Given a string containing just the characters &amp;#39;(&amp;#39; and &amp;#39;)&amp;#39;, find the length of the longest valid (well-formed) parentheses substring.
&amp;nbsp;
Example 1:
Input: s = &amp;quot;(()&amp;quot;Output: 2Explanation: The longest valid parentheses substring is &amp;quot;()&amp;quot;.Example 2:
Input: s = &amp;quot;)()())&amp;quot;Output: 4Explanation: The longest valid parentheses substring is &amp;quot;()()&amp;quot;.Example 3:
Input: s = &amp;quot;&amp;quot;Output: 0&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[34. Find First and Last Position of Element in Sorted Array](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)</title>
      <link>https://xmchxup.github.io/problemset/find-first-and-last-position-of-element-in-sorted-array/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/find-first-and-last-position-of-element-in-sorted-array/readme_en/</guid>
      <description>| English | 简体中文 |
34. Find First and Last Position of Element in Sorted Array Description Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must&amp;nbsp;write an algorithm with&amp;nbsp;O(log n) runtime complexity.
&amp;nbsp;
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]Example 2:</description>
    </item>
    
    <item>
      <title>[344. Reverse String](https://leetcode-cn.com/problems/reverse-string/)</title>
      <link>https://xmchxup.github.io/problemset/reverse-string/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-string/readme_en/</guid>
      <description>| English | 简体中文 |
344. Reverse String Description Write a function that reverses a string. The input string is given as an array of characters s.
&amp;nbsp;
Example 1:
Input: s = [&#34;h&#34;,&#34;e&#34;,&#34;l&#34;,&#34;l&#34;,&#34;o&#34;]Output: [&#34;o&#34;,&#34;l&#34;,&#34;l&#34;,&#34;e&#34;,&#34;h&#34;]Example 2:
Input: s = [&#34;H&#34;,&#34;a&#34;,&#34;n&#34;,&#34;n&#34;,&#34;a&#34;,&#34;h&#34;]Output: [&#34;h&#34;,&#34;a&#34;,&#34;n&#34;,&#34;n&#34;,&#34;a&#34;,&#34;H&#34;]&amp;nbsp;
Constraints:
1 &amp;lt;= s.length &amp;lt;= 105s[i] is a printable ascii character.&amp;nbsp;
Follow up: Do not allocate extra space for another array.</description>
    </item>
    
    <item>
      <title>[349. Intersection of Two Arrays](https://leetcode-cn.com/problems/intersection-of-two-arrays/)</title>
      <link>https://xmchxup.github.io/problemset/intersection-of-two-arrays/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/intersection-of-two-arrays/readme_en/</guid>
      <description>| English | 简体中文 |
349. Intersection of Two Arrays Description Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.
&amp;nbsp;
Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2]Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [9,4]Explanation: [4,9] is also accepted.</description>
    </item>
    
    <item>
      <title>[35. Search Insert Position](https://leetcode-cn.com/problems/search-insert-position/)</title>
      <link>https://xmchxup.github.io/problemset/search-insert-position/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/search-insert-position/readme_en/</guid>
      <description>| English | 简体中文 |
35. Search Insert Position Description Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You must&amp;nbsp;write an algorithm with&amp;nbsp;O(log n) runtime complexity.
&amp;nbsp;
Example 1:
Input: nums = [1,3,5,6], target = 5Output: 2Example 2:
Input: nums = [1,3,5,6], target = 2Output: 1Example 3:</description>
    </item>
    
    <item>
      <title>[350. Intersection of Two Arrays II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)</title>
      <link>https://xmchxup.github.io/problemset/intersection-of-two-arrays-ii/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/intersection-of-two-arrays-ii/readme_en/</guid>
      <description>| English | 简体中文 |
350. Intersection of Two Arrays II Description Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.
&amp;nbsp;
Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2]Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [4,9]Explanation: [9,4] is also accepted.</description>
    </item>
    
    <item>
      <title>[367. Valid Perfect Square](https://leetcode-cn.com/problems/valid-perfect-square/)</title>
      <link>https://xmchxup.github.io/problemset/valid-perfect-square/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-perfect-square/readme_en/</guid>
      <description>| English | 简体中文 |
367. Valid Perfect Square Description Given a positive integer num, write a function which returns True if num is a perfect square else False.
Follow up: Do not use any built-in library function such as sqrt.
&amp;nbsp;
Example 1:
Input: num = 16Output: trueExample 2:
Input: num = 14Output: false&amp;nbsp;
Constraints:
1 &amp;lt;= num &amp;lt;= 2^31 - 1Related Topics  Math Binary Search  Similar Questions  Sqrt(x) Sum of Square Numbers  </description>
    </item>
    
    <item>
      <title>[374. Guess Number Higher or Lower](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)</title>
      <link>https://xmchxup.github.io/problemset/guess-number-higher-or-lower/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/guess-number-higher-or-lower/readme_en/</guid>
      <description>| English | 简体中文 |
374. Guess Number Higher or Lower Description We are playing the Guess Game. The game is as follows:
I pick a number from 1 to n. You have to guess which number I picked.
Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.
You call a pre-defined API int guess(int num), which returns 3 possible results:</description>
    </item>
    
    <item>
      <title>[389. Find the Difference](https://leetcode-cn.com/problems/find-the-difference/)</title>
      <link>https://xmchxup.github.io/problemset/find-the-difference/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/find-the-difference/readme_en/</guid>
      <description>| English | 简体中文 |
389. Find the Difference Description You are given two strings s and t.
String t is generated by random shuffling string s and then add one more letter at a random position.
Return the letter that was added to t.
&amp;nbsp;
Example 1:
Input: s = &amp;quot;abcd&amp;quot;, t = &amp;quot;abcde&amp;quot;Output: &amp;quot;e&amp;quot;Explanation: &amp;#39;e&amp;#39; is the letter that was added.Example 2:
Input: s = &amp;quot;&amp;quot;, t = &amp;quot;y&amp;quot;Output: &amp;quot;y&amp;quot;Example 3:</description>
    </item>
    
    <item>
      <title>[39. Combination Sum](https://leetcode-cn.com/problems/combination-sum/)</title>
      <link>https://xmchxup.github.io/problemset/combination-sum/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combination-sum/readme_en/</guid>
      <description>| English | 简体中文 |
39. Combination Sum Description Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.
The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</description>
    </item>
    
    <item>
      <title>[4. Median of Two Sorted Arrays](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)</title>
      <link>https://xmchxup.github.io/problemset/median-of-two-sorted-arrays/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/median-of-two-sorted-arrays/readme_en/</guid>
      <description>| English | 简体中文 |
4. Median of Two Sorted Arrays Description Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
The overall run time complexity should be O(log (m+n)).
&amp;nbsp;
Example 1:
Input: nums1 = [1,3], nums2 = [2]Output: 2.00000Explanation: merged array = [1,2,3] and median is 2.Example 2:
Input: nums1 = [1,2], nums2 = [3,4]Output: 2.</description>
    </item>
    
    <item>
      <title>[40. Combination Sum II](https://leetcode-cn.com/problems/combination-sum-ii/)</title>
      <link>https://xmchxup.github.io/problemset/combination-sum-ii/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combination-sum-ii/readme_en/</guid>
      <description>| English | 简体中文 |
40. Combination Sum II Description Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates&amp;nbsp;where the candidate numbers sum to target.
Each number in candidates&amp;nbsp;may only be used once in the combination.
Note:&amp;nbsp;The solution set must not contain duplicate combinations.
&amp;nbsp;
Example 1:
Input: candidates = [10,1,2,7,6,1,5], target = 8Output: [[1,1,6],[1,2,5],[1,7],[2,6]]Example 2:</description>
    </item>
    
    <item>
      <title>[404. Sum of Left Leaves](https://leetcode-cn.com/problems/sum-of-left-leaves/)</title>
      <link>https://xmchxup.github.io/problemset/sum-of-left-leaves/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sum-of-left-leaves/readme_en/</guid>
      <description>| English | 简体中文 |
404. Sum of Left Leaves Description Given the root of a binary tree, return the sum of all left leaves.
&amp;nbsp;
Example 1:
Input: root = [3,9,20,null,null,15,7]Output: 24Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.Example 2:
Input: root = [1]Output: 0&amp;nbsp;
Constraints:
The number of nodes in the tree is in the range [1, 1000].</description>
    </item>
    
    <item>
      <title>[405. Convert a Number to Hexadecimal](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/)</title>
      <link>https://xmchxup.github.io/problemset/convert-a-number-to-hexadecimal/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/convert-a-number-to-hexadecimal/readme_en/</guid>
      <description>| English | 简体中文 |
405. Convert a Number to Hexadecimal Description Given an integer num, return a string representing its hexadecimal representation. For negative integers, two&amp;rsquo;s complement method is used.
All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.
Note:&amp;nbsp;You are not allowed to use any built-in library method to directly solve this problem.</description>
    </item>
    
    <item>
      <title>[406. Queue Reconstruction by Height](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)</title>
      <link>https://xmchxup.github.io/problemset/queue-reconstruction-by-height/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/queue-reconstruction-by-height/readme_en/</guid>
      <description>| English | 简体中文 |
406. Queue Reconstruction by Height Description You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.
Reconstruct and return the queue that is represented by the input array people.</description>
    </item>
    
    <item>
      <title>[414. Third Maximum Number](https://leetcode-cn.com/problems/third-maximum-number/)</title>
      <link>https://xmchxup.github.io/problemset/third-maximum-number/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/third-maximum-number/readme_en/</guid>
      <description>| English | 简体中文 |
414. Third Maximum Number Description Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.
&amp;nbsp;
Example 1:
Input: nums = [3,2,1]Output: 1Explanation:The first distinct maximum is 3.The second distinct maximum is 2.The third distinct maximum is 1.Example 2:
Input: nums = [1,2]Output: 2Explanation:The first distinct maximum is 2.</description>
    </item>
    
    <item>
      <title>[417. Pacific Atlantic Water Flow](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)</title>
      <link>https://xmchxup.github.io/problemset/pacific-atlantic-water-flow/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/pacific-atlantic-water-flow/readme_en/</guid>
      <description>| English | 简体中文 |
417. Pacific Atlantic Water Flow Description There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island&amp;#39;s left and top edges, and the Atlantic Ocean touches the island&amp;#39;s right and bottom edges.
The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).</description>
    </item>
    
    <item>
      <title>[434. Number of Segments in a String](https://leetcode-cn.com/problems/number-of-segments-in-a-string/)</title>
      <link>https://xmchxup.github.io/problemset/number-of-segments-in-a-string/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/number-of-segments-in-a-string/readme_en/</guid>
      <description>| English | 简体中文 |
434. Number of Segments in a String Description You are given a string s, return the number of segments in the string.&amp;nbsp;
A segment is defined to be a contiguous sequence of non-space characters.
&amp;nbsp;
Example 1:
Input: s = &amp;quot;Hello, my name is John&amp;quot;Output: 5Explanation: The five segments are [&amp;quot;Hello,&amp;quot;, &amp;quot;my&amp;quot;, &amp;quot;name&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;John&amp;quot;]Example 2:
Input: s = &amp;quot;Hello&amp;quot;Output: 1Example 3:</description>
    </item>
    
    <item>
      <title>[435. Non-overlapping Intervals](https://leetcode-cn.com/problems/non-overlapping-intervals/)</title>
      <link>https://xmchxup.github.io/problemset/non-overlapping-intervals/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/non-overlapping-intervals/readme_en/</guid>
      <description>| English | 简体中文 |
435. Non-overlapping Intervals Description Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.
&amp;nbsp;
Example 1:
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]Output: 1Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.Example 2:
Input: intervals = [[1,2],[1,2],[1,2]]Output: 2Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.</description>
    </item>
    
    <item>
      <title>[441. Arranging Coins](https://leetcode-cn.com/problems/arranging-coins/)</title>
      <link>https://xmchxup.github.io/problemset/arranging-coins/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/arranging-coins/readme_en/</guid>
      <description>| English | 简体中文 |
441. Arranging Coins Description You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.
Given the integer n, return the number of complete rows of the staircase you will build.
&amp;nbsp;
Example 1:
Input: n = 5Output: 2Explanation: Because the 3rd row is incomplete, we return 2.</description>
    </item>
    
    <item>
      <title>[445. Add Two Numbers II](https://leetcode-cn.com/problems/add-two-numbers-ii/)</title>
      <link>https://xmchxup.github.io/problemset/add-two-numbers-ii/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-two-numbers-ii/readme_en/</guid>
      <description>| English | 简体中文 |
445. Add Two Numbers II Description You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
&amp;nbsp;
Example 1:
Input: l1 = [7,2,4,3], l2 = [5,6,4]Output: [7,8,0,7]Example 2:</description>
    </item>
    
    <item>
      <title>[450. Delete Node in a BST](https://leetcode-cn.com/problems/delete-node-in-a-bst/)</title>
      <link>https://xmchxup.github.io/problemset/delete-node-in-a-bst/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/delete-node-in-a-bst/readme_en/</guid>
      <description>| English | 简体中文 |
450. Delete Node in a BST Description Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.
Basically, the deletion can be divided into two stages:
Search for a node to remove.If the node is found, delete the node.&amp;nbsp;
Example 1:</description>
    </item>
    
    <item>
      <title>[452. Minimum Number of Arrows to Burst Balloons](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)</title>
      <link>https://xmchxup.github.io/problemset/minimum-number-of-arrows-to-burst-balloons/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-number-of-arrows-to-burst-balloons/readme_en/</guid>
      <description>| English | 简体中文 |
452. Minimum Number of Arrows to Burst Balloons Description There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.
Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis.</description>
    </item>
    
    <item>
      <title>[455. Assign Cookies](https://leetcode-cn.com/problems/assign-cookies/)</title>
      <link>https://xmchxup.github.io/problemset/assign-cookies/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/assign-cookies/readme_en/</guid>
      <description>| English | 简体中文 |
455. Assign Cookies Description Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.
Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &amp;gt;= g[i], we can assign the cookie j to the child i, and the child i will be content.</description>
    </item>
    
    <item>
      <title>[46. Permutations](https://leetcode-cn.com/problems/permutations/)</title>
      <link>https://xmchxup.github.io/problemset/permutations/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/permutations/readme_en/</guid>
      <description>| English | 简体中文 |
46. Permutations Description Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
&amp;nbsp;
Example 1:
Input: nums = [1,2,3]Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]Example 2:
Input: nums = [0,1]Output: [[0,1],[1,0]]Example 3:
Input: nums = [1]Output: [[1]]&amp;nbsp;
Constraints:
1 &amp;lt;= nums.length &amp;lt;= 6-10 &amp;lt;= nums[i] &amp;lt;= 10All the integers of nums are unique.</description>
    </item>
    
    <item>
      <title>[47. Permutations II](https://leetcode-cn.com/problems/permutations-ii/)</title>
      <link>https://xmchxup.github.io/problemset/permutations-ii/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/permutations-ii/readme_en/</guid>
      <description>| English | 简体中文 |
47. Permutations II Description Given a collection of numbers, nums,&amp;nbsp;that might contain duplicates, return all possible unique permutations in any order.
&amp;nbsp;
Example 1:
Input: nums = [1,1,2]Output:[[1,1,2],[1,2,1],[2,1,1]]Example 2:
Input: nums = [1,2,3]Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]&amp;nbsp;
Constraints:
1 &amp;lt;= nums.length &amp;lt;= 8-10 &amp;lt;= nums[i] &amp;lt;= 10Related Topics  Array Backtracking  Similar Questions  Next Permutation Permutations Palindrome Permutation II Number of Squareful Arrays  </description>
    </item>
    
    <item>
      <title>[482. License Key Formatting](https://leetcode-cn.com/problems/license-key-formatting/)</title>
      <link>https://xmchxup.github.io/problemset/license-key-formatting/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/license-key-formatting/readme_en/</guid>
      <description>| English | 简体中文 |
482. License Key Formatting Description You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.
We want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character.</description>
    </item>
    
    <item>
      <title>[49. Group Anagrams](https://leetcode-cn.com/problems/group-anagrams/)</title>
      <link>https://xmchxup.github.io/problemset/group-anagrams/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/group-anagrams/readme_en/</guid>
      <description>| English | 简体中文 |
49. Group Anagrams Description Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
&amp;nbsp;
Example 1:
Input: strs = [&#34;eat&#34;,&#34;tea&#34;,&#34;tan&#34;,&#34;ate&#34;,&#34;nat&#34;,&#34;bat&#34;]Output: [[&#34;bat&#34;],[&#34;nat&#34;,&#34;tan&#34;],[&#34;ate&#34;,&#34;eat&#34;,&#34;tea&#34;]]Example 2:
Input: strs = [&#34;&#34;]Output: [[&#34;&#34;]]Example 3:</description>
    </item>
    
    <item>
      <title>[524. Longest Word in Dictionary through Deleting](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)</title>
      <link>https://xmchxup.github.io/problemset/longest-word-in-dictionary-through-deleting/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/longest-word-in-dictionary-through-deleting/readme_en/</guid>
      <description>| English | 简体中文 |
524. Longest Word in Dictionary through Deleting Description Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.
&amp;nbsp;
Example 1:</description>
    </item>
    
    <item>
      <title>[53. Maximum Subarray](https://leetcode-cn.com/problems/maximum-subarray/)</title>
      <link>https://xmchxup.github.io/problemset/maximum-subarray/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/maximum-subarray/readme_en/</guid>
      <description>| English | 简体中文 |
53. Maximum Subarray Description Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
A subarray is a contiguous part of an array.
&amp;nbsp;
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]Output: 6Explanation: [4,-1,2,1] has the largest sum = 6.Example 2:
Input: nums = [1]Output: 1Example 3:</description>
    </item>
    
    <item>
      <title>[530. Minimum Absolute Difference in BST](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)</title>
      <link>https://xmchxup.github.io/problemset/minimum-absolute-difference-in-bst/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-absolute-difference-in-bst/readme_en/</guid>
      <description>| English | 简体中文 |
530. Minimum Absolute Difference in BST Description Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.
&amp;nbsp;
Example 1:
Input: root = [4,2,6,1,3]Output: 1Example 2:
Input: root = [1,0,48,null,null,12,49]Output: 1&amp;nbsp;
Constraints:
The number of nodes in the tree is in the range [2, 104].</description>
    </item>
    
    <item>
      <title>[538. Convert BST to Greater Tree](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)</title>
      <link>https://xmchxup.github.io/problemset/convert-bst-to-greater-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/convert-bst-to-greater-tree/readme_en/</guid>
      <description>| English | 简体中文 |
538. Convert BST to Greater Tree Description Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.
As a reminder, a binary search tree is a tree that satisfies these constraints:
The left subtree of a node contains only nodes with keys less than the node&amp;#39;s key.</description>
    </item>
    
    <item>
      <title>[542. 01 Matrix](https://leetcode-cn.com/problems/01-matrix/)</title>
      <link>https://xmchxup.github.io/problemset/01-matrix/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/01-matrix/readme_en/</guid>
      <description>| English | 简体中文 |
542. 01 Matrix Description Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.
The distance between two adjacent cells is 1.
&amp;nbsp;
Example 1:
Input: mat = [[0,0,0],[0,1,0],[0,0,0]]Output: [[0,0,0],[0,1,0],[0,0,0]]Example 2:
Input: mat = [[0,0,0],[0,1,0],[1,1,1]]Output: [[0,0,0],[0,1,0],[1,2,1]]&amp;nbsp;
Constraints:
m == mat.lengthn == mat[i].length1 &amp;lt;= m, n &amp;lt;= 1041 &amp;lt;= m * n &amp;lt;= 104mat[i][j] is either 0 or 1.</description>
    </item>
    
    <item>
      <title>[543. Diameter of Binary Tree](https://leetcode-cn.com/problems/diameter-of-binary-tree/)</title>
      <link>https://xmchxup.github.io/problemset/diameter-of-binary-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/diameter-of-binary-tree/readme_en/</guid>
      <description>| English | 简体中文 |
543. Diameter of Binary Tree Description Given the root of a binary tree, return the length of the diameter of the tree.
The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
The length of a path between two nodes is represented by the number of edges between them.</description>
    </item>
    
    <item>
      <title>[547. Number of Provinces](https://leetcode-cn.com/problems/number-of-provinces/)</title>
      <link>https://xmchxup.github.io/problemset/number-of-provinces/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/number-of-provinces/readme_en/</guid>
      <description>| English | 简体中文 |
547. Number of Provinces Description There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.
A province is a group of directly or indirectly connected cities and no other cities outside of the group.
You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.</description>
    </item>
    
    <item>
      <title>[55. Jump Game](https://leetcode-cn.com/problems/jump-game/)</title>
      <link>https://xmchxup.github.io/problemset/jump-game/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/jump-game/readme_en/</guid>
      <description>| English | 简体中文 |
55. Jump Game Description You are given an integer array nums. You are initially positioned at the array&amp;#39;s first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
&amp;nbsp;
Example 1:
Input: nums = [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</description>
    </item>
    
    <item>
      <title>[557. Reverse Words in a String III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)</title>
      <link>https://xmchxup.github.io/problemset/reverse-words-in-a-string-iii/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-words-in-a-string-iii/readme_en/</guid>
      <description>| English | 简体中文 |
557. Reverse Words in a String III Description Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
&amp;nbsp;
Example 1:
Input: s = &#34;Let&#39;s take LeetCode contest&#34;Output: &#34;s&#39;teL ekat edoCteeL tsetnoc&#34;Example 2:
Input: s = &#34;God Ding&#34;Output: &#34;doG gniD&#34;&amp;nbsp;
Constraints:
1 &amp;lt;= s.length &amp;lt;= 5 * 104s contains printable ASCII characters.</description>
    </item>
    
    <item>
      <title>[563. Binary Tree Tilt](https://leetcode-cn.com/problems/binary-tree-tilt/)</title>
      <link>https://xmchxup.github.io/problemset/binary-tree-tilt/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-tilt/readme_en/</guid>
      <description>| English | 简体中文 |
563. Binary Tree Tilt Description Given the root of a binary tree, return the sum of every tree node&amp;#39;s tilt.
The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0.</description>
    </item>
    
    <item>
      <title>[565. Array Nesting](https://leetcode-cn.com/problems/array-nesting/)</title>
      <link>https://xmchxup.github.io/problemset/array-nesting/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/array-nesting/readme_en/</guid>
      <description>| English | 简体中文 |
565. Array Nesting Description You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].
You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:
The first element in s[k] starts with the selection of the element nums[k] of index = k.The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.</description>
    </item>
    
    <item>
      <title>[567. Permutation in String](https://leetcode-cn.com/problems/permutation-in-string/)</title>
      <link>https://xmchxup.github.io/problemset/permutation-in-string/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/permutation-in-string/readme_en/</guid>
      <description>| English | 简体中文 |
567. Permutation in String Description Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
In other words, return true if one of s1&amp;#39;s permutations is the substring of s2.
&amp;nbsp;
Example 1:
Input: s1 = &amp;quot;ab&amp;quot;, s2 = &amp;quot;eidbaooo&amp;quot;Output: trueExplanation: s2 contains one permutation of s1 (&amp;quot;ba&amp;quot;).Example 2:
Input: s1 = &amp;quot;ab&amp;quot;, s2 = &amp;quot;eidboaoo&amp;quot;Output: false&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[605. Can Place Flowers](https://leetcode-cn.com/problems/can-place-flowers/)</title>
      <link>https://xmchxup.github.io/problemset/can-place-flowers/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/can-place-flowers/readme_en/</guid>
      <description>| English | 简体中文 |
605. Can Place Flowers Description You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.
Given an integer array flowerbed containing 0&amp;#39;s and 1&amp;#39;s, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.</description>
    </item>
    
    <item>
      <title>[617. Merge Two Binary Trees](https://leetcode-cn.com/problems/merge-two-binary-trees/)</title>
      <link>https://xmchxup.github.io/problemset/merge-two-binary-trees/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/merge-two-binary-trees/readme_en/</guid>
      <description>| English | 简体中文 |
617. Merge Two Binary Trees Description You are given two binary trees root1 and root2.
Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node.</description>
    </item>
    
    <item>
      <title>[627. Swap Salary](https://leetcode-cn.com/problems/swap-salary/)</title>
      <link>https://xmchxup.github.io/problemset/swap-salary/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/swap-salary/readme_en/</guid>
      <description>| English | 简体中文 |
627. Swap Salary Description Table: Salary
+-------------+----------+| Column Name | Type |+-------------+----------+| id | int || name | varchar || sex | ENUM || salary | int |+-------------+----------+id is the primary key for this table.The sex column is ENUM value of type (&amp;#39;m&amp;#39;, &amp;#39;f&amp;#39;).The table contains information about an employee.&amp;nbsp;
Write an SQL query to swap all &amp;#39;f&amp;#39; and &amp;#39;m&amp;#39; values (i.</description>
    </item>
    
    <item>
      <title>[628. Maximum Product of Three Numbers](https://leetcode-cn.com/problems/maximum-product-of-three-numbers/)</title>
      <link>https://xmchxup.github.io/problemset/maximum-product-of-three-numbers/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/maximum-product-of-three-numbers/readme_en/</guid>
      <description>| English | 简体中文 |
628. Maximum Product of Three Numbers Description Given an integer array nums, find three numbers whose product is maximum and return the maximum product.
&amp;nbsp;
Example 1:
Input: nums = [1,2,3]Output: 6Example 2:
Input: nums = [1,2,3,4]Output: 24Example 3:
Input: nums = [-1,-2,-3]Output: -6&amp;nbsp;
Constraints:
3 &amp;lt;= nums.length &amp;lt;=&amp;nbsp;104-1000 &amp;lt;= nums[i] &amp;lt;= 1000Related Topics  Array Math Sorting  Similar Questions  Maximum Product Subarray  </description>
    </item>
    
    <item>
      <title>[633. Sum of Square Numbers](https://leetcode-cn.com/problems/sum-of-square-numbers/)</title>
      <link>https://xmchxup.github.io/problemset/sum-of-square-numbers/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sum-of-square-numbers/readme_en/</guid>
      <description>| English | 简体中文 |
633. Sum of Square Numbers Description Given a non-negative integer c, decide whether there&amp;#39;re two integers a and b such that a2 + b2 = c.
&amp;nbsp;
Example 1:
Input: c = 5Output: trueExplanation: 1 * 1 + 2 * 2 = 5Example 2:
Input: c = 3Output: falseExample 3:
Input: c = 4Output: trueExample 4:</description>
    </item>
    
    <item>
      <title>[66. Plus One](https://leetcode-cn.com/problems/plus-one/)</title>
      <link>https://xmchxup.github.io/problemset/plus-one/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/plus-one/readme_en/</guid>
      <description>| English | 简体中文 |
66. Plus One Description You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&amp;#39;s.
Increment the large integer by one and return the resulting array of digits.
&amp;nbsp;
Example 1:
Input: digits = [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.</description>
    </item>
    
    <item>
      <title>[665. Non-decreasing Array](https://leetcode-cn.com/problems/non-decreasing-array/)</title>
      <link>https://xmchxup.github.io/problemset/non-decreasing-array/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/non-decreasing-array/readme_en/</guid>
      <description>| English | 简体中文 |
665. Non-decreasing Array Description Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.
We define an array is non-decreasing if nums[i] &amp;lt;= nums[i + 1] holds for every i (0-based) such that (0 &amp;lt;= i &amp;lt;= n - 2).
&amp;nbsp;
Example 1:
Input: nums = [4,2,3]Output: trueExplanation: You could modify the first 4 to 1 to get a non-decreasing array.</description>
    </item>
    
    <item>
      <title>[669. Trim a Binary Search Tree](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)</title>
      <link>https://xmchxup.github.io/problemset/trim-a-binary-search-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/trim-a-binary-search-tree/readme_en/</guid>
      <description>| English | 简体中文 |
669. Trim a Binary Search Tree Description Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&amp;#39;s descendant should remain a descendant). It can be proven that there is a unique answer.</description>
    </item>
    
    <item>
      <title>[67. Add Binary](https://leetcode-cn.com/problems/add-binary/)</title>
      <link>https://xmchxup.github.io/problemset/add-binary/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/add-binary/readme_en/</guid>
      <description>| English | 简体中文 |
67. Add Binary Description Given two binary strings a and b, return their sum as a binary string.
&amp;nbsp;
Example 1:
Input: a = &#34;11&#34;, b = &#34;1&#34;Output: &#34;100&#34;Example 2:
Input: a = &#34;1010&#34;, b = &#34;1011&#34;Output: &#34;10101&#34;&amp;nbsp;
Constraints:
1 &amp;lt;= a.length, b.length &amp;lt;= 104a and b consist&amp;nbsp;only of &amp;#39;0&amp;#39; or &amp;#39;1&amp;#39; characters.Each string does not contain leading zeros except for the zero itself.</description>
    </item>
    
    <item>
      <title>[680. Valid Palindrome II](https://leetcode-cn.com/problems/valid-palindrome-ii/)</title>
      <link>https://xmchxup.github.io/problemset/valid-palindrome-ii/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/valid-palindrome-ii/readme_en/</guid>
      <description>| English | 简体中文 |
680. Valid Palindrome II Description Given a string s, return true if the s can be palindrome after deleting at most one character from it.
&amp;nbsp;
Example 1:
Input: s = &amp;quot;aba&amp;quot;Output: trueExample 2:
Input: s = &amp;quot;abca&amp;quot;Output: trueExplanation: You could delete the character &amp;#39;c&amp;#39;.Example 3:
Input: s = &amp;quot;abc&amp;quot;Output: false&amp;nbsp;
Constraints:</description>
    </item>
    
    <item>
      <title>[69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)</title>
      <link>https://xmchxup.github.io/problemset/sqrtx/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sqrtx/readme_en/</guid>
      <description>| English | 简体中文 |
69. Sqrt(x) Description Given a non-negative integer x,&amp;nbsp;compute and return the square root of x.
Since the return type&amp;nbsp;is an integer, the decimal digits are truncated, and only the integer part of the result&amp;nbsp;is returned.
Note:&amp;nbsp;You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or&amp;nbsp;x ** 0.5.
&amp;nbsp;
Example 1:
Input: x = 4Output: 2Example 2:</description>
    </item>
    
    <item>
      <title>[695. Max Area of Island](https://leetcode-cn.com/problems/max-area-of-island/)</title>
      <link>https://xmchxup.github.io/problemset/max-area-of-island/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/max-area-of-island/readme_en/</guid>
      <description>| English | 简体中文 |
695. Max Area of Island Description You are given an m x n binary matrix grid. An island is a group of 1&amp;#39;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.
The area of an island is the number of cells with a value 1 in the island.
Return the maximum area of an island in grid.</description>
    </item>
    
    <item>
      <title>[7. Reverse Integer](https://leetcode-cn.com/problems/reverse-integer/)</title>
      <link>https://xmchxup.github.io/problemset/reverse-integer/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/reverse-integer/readme_en/</guid>
      <description>| English | 简体中文 |
7. Reverse Integer Description Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
&amp;nbsp;
Example 1:
Input: x = 123Output: 321Example 2:
Input: x = -123Output: -321Example 3:</description>
    </item>
    
    <item>
      <title>[70. Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/)</title>
      <link>https://xmchxup.github.io/problemset/climbing-stairs/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/climbing-stairs/readme_en/</guid>
      <description>| English | 简体中文 |
70. Climbing Stairs Description You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
&amp;nbsp;
Example 1:
Input: n = 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 stepsExample 2:</description>
    </item>
    
    <item>
      <title>[704. Binary Search](https://leetcode-cn.com/problems/binary-search/)</title>
      <link>https://xmchxup.github.io/problemset/binary-search/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-search/readme_en/</guid>
      <description>| English | 简体中文 |
704. Binary Search Description Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
You must write an algorithm with O(log n) runtime complexity.
&amp;nbsp;
Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4Example 2:</description>
    </item>
    
    <item>
      <title>[707. Design Linked List](https://leetcode-cn.com/problems/design-linked-list/)</title>
      <link>https://xmchxup.github.io/problemset/design-linked-list/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/design-linked-list/readme_en/</guid>
      <description>| English | 简体中文 |
707. Design Linked List Description Design your implementation of the linked list. You can choose to use a singly or doubly linked list.
A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node.
If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list.</description>
    </item>
    
    <item>
      <title>[733. Flood Fill](https://leetcode-cn.com/problems/flood-fill/)</title>
      <link>https://xmchxup.github.io/problemset/flood-fill/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/flood-fill/readme_en/</guid>
      <description>| English | 简体中文 |
733. Flood Fill Description An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.
You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc].
To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on.</description>
    </item>
    
    <item>
      <title>[746. Min Cost Climbing Stairs](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)</title>
      <link>https://xmchxup.github.io/problemset/min-cost-climbing-stairs/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/min-cost-climbing-stairs/readme_en/</guid>
      <description>| English | 简体中文 |
746. Min Cost Climbing Stairs Description You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.
You can either start from the step with index 0, or the step with index 1.
Return the minimum cost to reach the top of the floor.
&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[747. Largest Number At Least Twice of Others](https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/)</title>
      <link>https://xmchxup.github.io/problemset/largest-number-at-least-twice-of-others/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/largest-number-at-least-twice-of-others/readme_en/</guid>
      <description>| English | 简体中文 |
747. Largest Number At Least Twice of Others Description You are given an integer array nums where the largest integer is unique.
Determine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise.
&amp;nbsp;
Example 1:
Input: nums = [3,6,1,0]Output: 1Explanation: 6 is the largest integer.</description>
    </item>
    
    <item>
      <title>[75. Sort Colors](https://leetcode-cn.com/problems/sort-colors/)</title>
      <link>https://xmchxup.github.io/problemset/sort-colors/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sort-colors/readme_en/</guid>
      <description>| English | 简体中文 |
75. Sort Colors Description Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
You must solve this problem without using the library&amp;#39;s sort function.</description>
    </item>
    
    <item>
      <title>[76. Minimum Window Substring](https://leetcode-cn.com/problems/minimum-window-substring/)</title>
      <link>https://xmchxup.github.io/problemset/minimum-window-substring/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-window-substring/readme_en/</guid>
      <description>| English | 简体中文 |
76. Minimum Window Substring Description Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &amp;quot;&amp;quot;.
The testcases will be generated such that the answer is unique.
A substring is a contiguous sequence of characters within the string.</description>
    </item>
    
    <item>
      <title>[763. Partition Labels](https://leetcode-cn.com/problems/partition-labels/)</title>
      <link>https://xmchxup.github.io/problemset/partition-labels/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/partition-labels/readme_en/</guid>
      <description>| English | 简体中文 |
763. Partition Labels Description You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.
Return a list of integers representing the size of these parts.
&amp;nbsp;
Example 1:
Input: s = &amp;quot;ababcbacadefegdehijhklij&amp;quot;Output: [9,7,8]Explanation:The partition is &amp;quot;ababcbaca&amp;quot;, &amp;quot;defegde&amp;quot;, &amp;quot;hijhklij&amp;quot;.This is a partition so that each letter appears in at most one part.</description>
    </item>
    
    <item>
      <title>[77. Combinations](https://leetcode-cn.com/problems/combinations/)</title>
      <link>https://xmchxup.github.io/problemset/combinations/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/combinations/readme_en/</guid>
      <description>| English | 简体中文 |
77. Combinations Description Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].
You may return the answer in any order.
&amp;nbsp;
Example 1:
Input: n = 4, k = 2Output:[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],]Example 2:
Input: n = 1, k = 1Output: [[1]]&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[78. Subsets](https://leetcode-cn.com/problems/subsets/)</title>
      <link>https://xmchxup.github.io/problemset/subsets/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/subsets/readme_en/</guid>
      <description>| English | 简体中文 |
78. Subsets Description Given an integer array nums of unique elements, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.
&amp;nbsp;
Example 1:
Input: nums = [1,2,3]Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]Example 2:
Input: nums = [0]Output: [[],[0]]&amp;nbsp;
Constraints:
1 &amp;lt;= nums.length &amp;lt;= 10-10 &amp;lt;= nums[i] &amp;lt;= 10All the numbers of&amp;nbsp;nums are unique.</description>
    </item>
    
    <item>
      <title>[783. Minimum Distance Between BST Nodes](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/)</title>
      <link>https://xmchxup.github.io/problemset/minimum-distance-between-bst-nodes/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/minimum-distance-between-bst-nodes/readme_en/</guid>
      <description>| English | 简体中文 |
783. Minimum Distance Between BST Nodes Description Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree.
&amp;nbsp;
Example 1:
Input: root = [4,2,6,1,3]Output: 1Example 2:
Input: root = [1,0,48,null,null,12,49]Output: 1&amp;nbsp;
Constraints:
The number of nodes in the tree is in the range [2, 100].</description>
    </item>
    
    <item>
      <title>[784. Letter Case Permutation](https://leetcode-cn.com/problems/letter-case-permutation/)</title>
      <link>https://xmchxup.github.io/problemset/letter-case-permutation/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/letter-case-permutation/readme_en/</guid>
      <description>| English | 简体中文 |
784. Letter Case Permutation Description Given a string s, we can transform every letter individually to be lowercase or uppercase to create another string.
Return a list of all possible strings we could create. You can return the output&amp;nbsp;in any order.
&amp;nbsp;
Example 1:
Input: s = &amp;quot;a1b2&amp;quot;Output: [&amp;quot;a1b2&amp;quot;,&amp;quot;a1B2&amp;quot;,&amp;quot;A1b2&amp;quot;,&amp;quot;A1B2&amp;quot;]Example 2:
Input: s = &amp;quot;3z4&amp;quot;Output: [&amp;quot;3z4&amp;quot;,&amp;quot;3Z4&amp;quot;]Example 3:
Input: s = &amp;quot;12345&amp;quot;Output: [&amp;quot;12345&amp;quot;]Example 4:</description>
    </item>
    
    <item>
      <title>[81. Search in Rotated Sorted Array II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)</title>
      <link>https://xmchxup.github.io/problemset/search-in-rotated-sorted-array-ii/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/search-in-rotated-sorted-array-ii/readme_en/</guid>
      <description>| English | 简体中文 |
81. Search in Rotated Sorted Array II Description There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).
Before being passed to your function, nums is rotated at an unknown pivot index k (0 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].</description>
    </item>
    
    <item>
      <title>[84. Largest Rectangle in Histogram](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)</title>
      <link>https://xmchxup.github.io/problemset/largest-rectangle-in-histogram/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/largest-rectangle-in-histogram/readme_en/</guid>
      <description>| English | 简体中文 |
84. Largest Rectangle in Histogram Description Given an array of integers heights representing the histogram&amp;#39;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.
&amp;nbsp;
Example 1:
Input: heights = [2,1,5,6,2,3]Output: 10Explanation: The above is a histogram where width of each bar is 1.The largest rectangle is shown in the red area, which has an area = 10 units.</description>
    </item>
    
    <item>
      <title>[844. Backspace String Compare](https://leetcode-cn.com/problems/backspace-string-compare/)</title>
      <link>https://xmchxup.github.io/problemset/backspace-string-compare/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/backspace-string-compare/readme_en/</guid>
      <description>| English | 简体中文 |
844. Backspace String Compare Description Given two strings s and t, return true if they are equal when both are typed into empty text editors. &amp;#39;#&amp;#39; means a backspace character.
Note that after backspacing an empty text, the text will continue empty.
&amp;nbsp;
Example 1:
Input: s = &amp;quot;ab#c&amp;quot;, t = &amp;quot;ad#c&amp;quot;Output: trueExplanation: Both s and t become &amp;quot;ac&amp;quot;.Example 2:</description>
    </item>
    
    <item>
      <title>[852. Peak Index in a Mountain Array](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)</title>
      <link>https://xmchxup.github.io/problemset/peak-index-in-a-mountain-array/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/peak-index-in-a-mountain-array/readme_en/</guid>
      <description>| English | 简体中文 |
852. Peak Index in a Mountain Array Description Let&amp;#39;s call an array arr a mountain&amp;nbsp;if the following properties hold:
arr.length &amp;gt;= 3There exists some i with&amp;nbsp;0 &amp;lt; i&amp;nbsp;&amp;lt; arr.length - 1&amp;nbsp;such that:arr[0] &amp;lt; arr[1] &amp;lt; ... arr[i-1] &amp;lt; arr[i] arr[i] &amp;gt; arr[i+1] &amp;gt; ... &amp;gt; arr[arr.length - 1]Given an integer array arr that is guaranteed to be&amp;nbsp;a mountain, return any&amp;nbsp;i&amp;nbsp;such that&amp;nbsp;arr[0] &amp;lt; arr[1] &amp;lt; .</description>
    </item>
    
    <item>
      <title>[876. Middle of the Linked List](https://leetcode-cn.com/problems/middle-of-the-linked-list/)</title>
      <link>https://xmchxup.github.io/problemset/middle-of-the-linked-list/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/middle-of-the-linked-list/readme_en/</guid>
      <description>| English | 简体中文 |
876. Middle of the Linked List Description Given the head of a singly linked list, return the middle node of the linked list.
If there are two middle nodes, return the second middle node.
&amp;nbsp;
Example 1:
Input: head = [1,2,3,4,5]Output: [3,4,5]Explanation: The middle node of the list is node 3.Example 2:
Input: head = [1,2,3,4,5,6]Output: [4,5,6]Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.</description>
    </item>
    
    <item>
      <title>[88. Merge Sorted Array](https://leetcode-cn.com/problems/merge-sorted-array/)</title>
      <link>https://xmchxup.github.io/problemset/merge-sorted-array/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/merge-sorted-array/readme_en/</guid>
      <description>| English | 简体中文 |
88. Merge Sorted Array Description You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored.</description>
    </item>
    
    <item>
      <title>[880. Decoded String at Index](https://leetcode-cn.com/problems/decoded-string-at-index/)</title>
      <link>https://xmchxup.github.io/problemset/decoded-string-at-index/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/decoded-string-at-index/readme_en/</guid>
      <description>| English | 简体中文 |
880. Decoded String at Index Description You are given an encoded string s. To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken:
If the character read is a letter, that letter is written onto the tape.If the character read is a digit d, the entire current tape is repeatedly written d - 1 more times in total.</description>
    </item>
    
    <item>
      <title>[9. Palindrome Number](https://leetcode-cn.com/problems/palindrome-number/)</title>
      <link>https://xmchxup.github.io/problemset/palindrome-number/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/palindrome-number/readme_en/</guid>
      <description>| English | 简体中文 |
9. Palindrome Number Description Given an integer x, return true if x is palindrome integer.
An integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.
&amp;nbsp;
Example 1:
Input: x = 121Output: trueExample 2:
Input: x = -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-.</description>
    </item>
    
    <item>
      <title>[90. Subsets II](https://leetcode-cn.com/problems/subsets-ii/)</title>
      <link>https://xmchxup.github.io/problemset/subsets-ii/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/subsets-ii/readme_en/</guid>
      <description>| English | 简体中文 |
90. Subsets II Description Given an integer array nums that may contain duplicates, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.
&amp;nbsp;
Example 1:
Input: nums = [1,2,2]Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]Example 2:
Input: nums = [0]Output: [[],[0]]&amp;nbsp;
Constraints:
1 &amp;lt;= nums.length &amp;lt;= 10-10 &amp;lt;= nums[i] &amp;lt;= 10Related Topics  Bit Manipulation Array Backtracking  Similar Questions  Subsets  </description>
    </item>
    
    <item>
      <title>[938. Range Sum of BST](https://leetcode-cn.com/problems/range-sum-of-bst/)</title>
      <link>https://xmchxup.github.io/problemset/range-sum-of-bst/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/range-sum-of-bst/readme_en/</guid>
      <description>| English | 简体中文 |
938. Range Sum of BST Description Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].
&amp;nbsp;
Example 1:
Input: root = [10,5,15,3,7,null,18], low = 7, high = 15Output: 32Explanation: Nodes 7, 10, and 15 are in the range [7, 15].</description>
    </item>
    
    <item>
      <title>[94. Binary Tree Inorder Traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)</title>
      <link>https://xmchxup.github.io/problemset/binary-tree-inorder-traversal/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/binary-tree-inorder-traversal/readme_en/</guid>
      <description>| English | 简体中文 |
94. Binary Tree Inorder Traversal Description Given the root of a binary tree, return the inorder traversal of its nodes&amp;#39; values.
&amp;nbsp;
Example 1:
Input: root = [1,null,2,3]Output: [1,3,2]Example 2:
Input: root = []Output: []Example 3:
Input: root = [1]Output: [1]Example 4:
Input: root = [1,2]Output: [2,1]Example 5:
Input: root = [1,null,2]Output: [1,2]&amp;nbsp;</description>
    </item>
    
    <item>
      <title>[95. Unique Binary Search Trees II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)</title>
      <link>https://xmchxup.github.io/problemset/unique-binary-search-trees-ii/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/unique-binary-search-trees-ii/readme_en/</guid>
      <description>| English | 简体中文 |
95. Unique Binary Search Trees II Description Given an integer n, return all the structurally unique BST&amp;#39;s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.
&amp;nbsp;
Example 1:
Input: n = 3Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]Example 2:
Input: n = 1Output: [[1]]&amp;nbsp;
Constraints:
1 &amp;lt;= n &amp;lt;= 8Related Topics  Tree Binary Search Tree Dynamic Programming Backtracking Binary Tree  Similar Questions  Unique Binary Search Trees Different Ways to Add Parentheses  </description>
    </item>
    
    <item>
      <title>[965. Univalued Binary Tree](https://leetcode-cn.com/problems/univalued-binary-tree/)</title>
      <link>https://xmchxup.github.io/problemset/univalued-binary-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/univalued-binary-tree/readme_en/</guid>
      <description>| English | 简体中文 |
965. Univalued Binary Tree Description A binary tree is uni-valued if every node in the tree has the same value.
Given the root of a binary tree, return true if the given tree is uni-valued, or false otherwise.
&amp;nbsp;
Example 1:
Input: root = [1,1,1,1,1,null,1]Output: trueExample 2:
Input: root = [2,2,2,5,2]Output: false&amp;nbsp;
Constraints:
The number of nodes in the tree is in the range [1, 100].</description>
    </item>
    
    <item>
      <title>[977. Squares of a Sorted Array](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)</title>
      <link>https://xmchxup.github.io/problemset/squares-of-a-sorted-array/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/squares-of-a-sorted-array/readme_en/</guid>
      <description>| English | 简体中文 |
977. Squares of a Sorted Array Description Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.
&amp;nbsp;
Example 1:
Input: nums = [-4,-1,0,3,10]Output: [0,1,9,16,100]Explanation: After squaring, the array becomes [16,1,0,9,100].After sorting, it becomes [0,1,9,16,100].Example 2:
Input: nums = [-7,-3,2,3,11]Output: [4,9,9,49,121]&amp;nbsp;
Constraints:
1 &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title>[98. Validate Binary Search Tree](https://leetcode-cn.com/problems/validate-binary-search-tree/)</title>
      <link>https://xmchxup.github.io/problemset/validate-binary-search-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/validate-binary-search-tree/readme_en/</guid>
      <description>| English | 简体中文 |
98. Validate Binary Search Tree Description Given the root of a binary tree, determine if it is a valid binary search tree (BST).
A valid BST is defined as follows:
The left subtree of a node contains only nodes with keys less than the node&amp;#39;s key.The right subtree of a node contains only nodes with keys greater than the node&amp;#39;s key.Both the left and right subtrees must also be binary search trees.</description>
    </item>
    
    <item>
      <title>[99. Recover Binary Search Tree](https://leetcode-cn.com/problems/recover-binary-search-tree/)</title>
      <link>https://xmchxup.github.io/problemset/recover-binary-search-tree/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/recover-binary-search-tree/readme_en/</guid>
      <description>| English | 简体中文 |
99. Recover Binary Search Tree Description You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.
&amp;nbsp;
Example 1:
Input: root = [1,3,null,null,2]Output: [3,1,null,null,2]Explanation: 3 cannot be a left child of 1 because 3 &amp;gt; 1. Swapping 1 and 3 makes the BST valid.</description>
    </item>
    
    <item>
      <title>[剑指 Offer 55 - I. 二叉树的深度 LCOF](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)</title>
      <link>https://xmchxup.github.io/problemset/er-cha-shu-de-shen-du-lcof/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/er-cha-shu-de-shen-du-lcof/readme_en/</guid>
      <description>| English | 简体中文 |
剑指 Offer 55 - I. 二叉树的深度 LCOF Description English description is not available for the problem. Please switch to Chinese.
Related Topics  Tree Depth-First Search Breadth-First Search Binary Tree  Similar Questions </description>
    </item>
    
    <item>
      <title>[剑指 Offer 59 - II. 队列的最大值 LCOF](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)</title>
      <link>https://xmchxup.github.io/problemset/dui-lie-de-zui-da-zhi-lcof/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/dui-lie-de-zui-da-zhi-lcof/readme_en/</guid>
      <description>| English | 简体中文 |
剑指 Offer 59 - II. 队列的最大值 LCOF Description English description is not available for the problem. Please switch to Chinese.
Related Topics  Design Queue Monotonic Queue  Similar Questions </description>
    </item>
    
    <item>
      <title>[面试题 10.09. Sorted Matrix Search LCCI](https://leetcode-cn.com/problems/sorted-matrix-search-lcci/)</title>
      <link>https://xmchxup.github.io/problemset/sorted-matrix-search-lcci/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sorted-matrix-search-lcci/readme_en/</guid>
      <description>| English | 简体中文 |
面试题 10.09. Sorted Matrix Search LCCI Description Given an M x N matrix in which each row and each column is sorted in ascending order, write a method to find an element.
Example:
Given matrix:
[[1, 4, 7, 11, 15],[2, 5, 8, 12, 19],[3, 6, 9, 16, 22],[10, 13, 14, 17, 24],[18, 21, 23, 26, 30]]Given target&amp;nbsp;=&amp;nbsp;5,&amp;nbsp;return&amp;nbsp;true.</description>
    </item>
    
    <item>
      <title>[面试题 16.16. Sub Sort LCCI](https://leetcode-cn.com/problems/sub-sort-lcci/)</title>
      <link>https://xmchxup.github.io/problemset/sub-sort-lcci/readme_en/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xmchxup.github.io/problemset/sub-sort-lcci/readme_en/</guid>
      <description>| English | 简体中文 |
面试题 16.16. Sub Sort LCCI Description Given an array of integers, write a method to find indices m and n such that if you sorted&amp;nbsp;elements m through n, the entire array would be sorted. Minimize n - m (that is, find the smallest such sequence).
Return [m,n]. If there are no such m and n (e.g. the array is already sorted), return [-1, -1].
Example:</description>
    </item>
    
  </channel>
</rss>
